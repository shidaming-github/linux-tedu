
   damin 

date 1

Linux系统简介        
Linux是一种操作系统!

Unix/Linux发展史

• UNIX诞生,1970-1-1

Linux的诞生
• Linux之父,Linus Torwalds
– 1991年10月,发布0.02版(第一个公开版)内核
– 1994年03月,发布1.0版内核
– 标准读音:“哩呐科斯”

– 内核版本号:主版本.次版本.修订号       4.10.123
        用户------>内核------>硬件
内核分为（ 进程管理系统   ） 、（ 内存管理系统   ）、（ I\O管理系统   ） 和（ 文件管理系统  ） 等四个子系统。
Linux内核引导时，从文件（    /etc/fstab    ）中读取要加载的文件系统

#################################################
Linux版本及应用
• 发行版的名称/版本由发行方决定
– Red Hat Enterprise Linux 5/6/7
– Suse Linux Enterprise 12
– Debian Linux 7.8
– Ubuntu Linux 14.10/15.04

#############################################
利用虚拟机Linux安装:CentOS7.5
  CentOS需要内存2G
 
  Ctrl+Alt=鼠标回到真机

################################################
预备知识
Linux目录结构

   根目录(/): 所有的数据都在此目录下(Linux系统的起点)
   /dev:存放设备(键盘\鼠标\显示器\磁盘\光驱等)相关的数据
   
    路径:/dev/abc/mp3.txt

– Unix/Linux的基本哲学理念:一切皆文件

利用root登录系统:
  点击"未列出"---->输入用户名root----->输入密码 

###################################################
Linux磁盘表示

hd,表示IDE设备
sd,表示SCSI设备

       /dev/sda :表示SCSI设备,第一块
       /dev/sdb :表示SCSI设备,第二块
       /dev/sdc :表示SCSI设备,第三块

       /dev/hdd :表示IDE设备,第四块

Linux系统中第三块SCSI硬盘如何表示?
     /dev/sdc

###################################################
获取命令行界面      

• 虚拟控制台切换( Ctrl + Alt + Fn 组合键)
– tty1:图形桌面
– tty2~tty6:字符控制台

图形命令行界面:鼠标右击--->打开终端

 快捷键:  
    变大:Ctrl  shift  +
    变小:Ctrl  -

命令行提示符:
    [当前登录的用户@当前主机名 当前所在位置]#

    #:代表当前身份为超级管理员 root
    $:代表当前身份为普通用户

二、TCP/IP协议简介
1.什么是协议
协议就是一组规则
TCP/IP协议就是一组通信协议的集合
2.计算机通信三要素
IP地址
子网掩码
网关
3.什么是IP地址
标识网络中某一个节点的地址
ipv4	32位二进数
ipv6	128位二进数
ip地址每一个字段最大范围255

172.60.50.150(十进制)
10101100.00111100.00110010.10010110(二进制)

00000000.00000000.00000000.00000000 ~ 0.0.0.0
11111111.11111111.11111111.11111111 ~ 255.255.255.255
4. IP地址分类
A 	1 ~ 127		
B	128 ~ 191	
C	192 ~ 223

D  组播	224 ~ 239
E  科研	240 ~ 254

IP地址：网络位+主机位
网络位 = 电话号码的区号：标识一个网络
主机位 = 具体的电话号码：标识具体的一个主机
电话号码：区号+座机号
北京：010-63527788	
广州：020-63527788
A	网络+主机+主机+主机		10.1.1.10
B	网络+网络+主机+主机		173.5.5.10
C	网络+网络+网络+主机		192.168.10.10

相同网络位的主机可以直接通信
192.168.10.10	192.168.10.0
192.168.10.20	192.168.10.0
5.子网掩码
设置IP时必须有子网掩码
作用：判断IP地址的网络位，相同网络位的主机可以直接通信
默认子网掩码
A类地址	255.0.0.0
B类地址	255.255.0.0
C类地址	255.255.255.0

192.168.10.10	11000000.10101000.00001010.00001010
255.255.255.0	11111111.11111111.11111111.00000000
		        11000000.10101000.00001010.00000000
			192.168.10.0
192.168.10.20	11000000.10101000.00001010.00010100
255.255.255.0
6.网关
在同一个网络里面通信不需要网关
和另外网络中的计算机通信需要网关
网关：从你当前网络去往对方网络的出口
网关一定和你当前IP在同一网段
在实际生产环境中一般网关是路由器或者防火墙
10.0.0.10	255.255.255.0  = 10.0.0.10/24

三、基本环境配置
1.为虚拟机win2008配置IP地址。利用管理员进行登录，密码为：tedu
配置IP地址：　　192.168.1.1　　子网掩码：255.255.255.0
– 右击桌面网络 --＞属性 --＞更改适配器设置
– 双击“本地连接” --＞ 属性
– 双击“Internet协议版本4(TCP/IPv4)”　　　
– 配置完成后,单击“确定”完成

查看IP地址：　
– 右击桌面网络 --＞属性 --＞更改适配器设置
– 双击“本地连接” --＞ 详细信息

采用ipconfig命令的方式，查看IP地址：
   　windows键　＋　ｒ＝　开始＋运行
　　　输入cmd-->敲回车--＞输入　ipconfig-->敲回车
　　　--＞输入　exit　关闭命令行界面

案例一：配置win2008网络参数，确保连通性
克隆虚拟机win2008　　　　　　　　　　
1.双击桌面windows还原,打开桌面虚拟系统管理器,双击win2008,选择查看,详情,把内存4096修改成2048,应用.
2.进行虚拟机克隆
　双击＂虚拟系统管理器＂--＞右击＂win2008＂--＞克隆--＞克隆
3. 配置二台win2008的网络参数
配置win2008的IP地址	192.168.1.10  
			子网掩码	255.255.255.0
			网关	192.168.1.254
			dns	202.106.0.20　
 – 右击桌面网络 --＞属性 --＞更改适配器设置
 – 双击“本地连接” --＞ 属性
 – 双击“Internet协议版本4(TCP/IPv4)”　　　
 – 配置完成后,单击“确定”完成

配置win2008-clone的IP地址：192.168.1.20  
			子网掩码	255.255.255.0
			网关	192.168.1.254
			dns	202.106.0.20　
 – 右击桌面网络 --＞属性 --＞更改适配器设置
 – 双击“本地连接” --＞ 属性
 – 双击“Internet协议版本4(TCP/IPv4)”　　　
 – 配置完成后,单击“确定”完成

采用ipconfig命令的方式，查看IP地址：
   　windows键　＋　ｒ＝　开始＋运行
　　　输入cmd-->敲回车--＞输入　ipconfig-->敲回车
　　　--＞输入　exit　关闭命令行界面

采用命令方式，测试网络联通性：
　　ping　　命令
　　ping   对方IP地址　　　ping命令是双向，有去有回
　　ping 　192.168.1.20　

　　ping 　192.168.1.２　

DNS服务器：将网站的域名解析为,对应的IP地址
  
         www.qq.com-------＞腾讯的服务器
         www.baidu.com-------＞百度的服务器

1. 访问京东查看主流服务器价格和硬件配置信息
2. 为什么IDC数据中心的服务器没有显示器,键盘,鼠标
3. 为什么企业会把核心服务器放到IDC数据中心
4. 传一个ipv4-ipv6激情小视频
5. 为什么主机设置的网关地址都和本机IP在同一网段
6. 请问ABC三类地址,哪类地址容纳主机数最多?哪些容纳主机数最少?
7. 假设主机选择自动获取IP,但是网络中没有dhcp服务器可以分配地址的时候怎么办?
8. 电脑能够正常上QQ,但是打不开baidu,sina等网站?		          
			  
#########################################################################
   date 2
﻿早自习默写
1.IP地址的分类及范围？
2.子网掩码的作用？
3.网关的作用？ 
4.ABC类IP地址默认子网掩码是？

一、Linux系统简介
1.什么是Linux?
Linux是一种操作系统，主要用在企业服务器上面
2.Linux系统内核
版本号:主版本.次版本.修订号
3.RedHat系列版本
– Red Hat Enterprise Linux（RHEL） 5/6/7/8
– CentOS
– Fedora Core社区版

二、安装Linux系统
1.Linux 一切皆文件
  Linux严格区分大小写
2.建议内存2G以上
3.Linux磁盘表示
/dev/xdy
/dev	表示/dev目录
xd	hd	ide接口硬盘
	sd	非ide接口硬盘（SATA、SCSI）
	vd	虚拟机磁盘
y	a	第一块硬盘
	b	第二块硬盘
	c	第三块硬盘
	...
/dev/hdb		第二块IDE接口的硬盘
/dev/vda3	第一块虚拟磁盘第三个分区
/dev/sdd1	第四块非IDE接口的第一个分区



4.默认Linux管理员 root
5.Ctrl + Alt = 鼠标回到真机
6.目录结构
/	Linux文件系统的起点，所有Linux数据全部存放在/下
/dev	存放设备相关的
/root	管理员的家目录
/home	普通用户的家目录


三、命令行基本操作
1.Linux虚拟控制台
tty1 ~ tty6
tty1 		图形
tty2~tty6	字符
切换：
图形切换到字符	ctrl+alt+(F2~F6)
字符之间切换	alt+(F2~F6)
字符到图形	alt+F1
2.Linux命令行提示符
[登录用户@主机名 工作目录] 身份标识
# 代表管理员
$ 代表普通用户
3.Linux基本命令
# pwd		//显示当前工作目录
# cd		//切换路径
# cd .		//当前不变
# cd ..		//返回上一层目录
# cd ../..	//返回上一层的上一层
# cd -		//返回上一次工作目录
# cd ~ = cd 	//进入当前用户家目录
绝对路径：以/开始的路径
相对路径：不以/开始的路径
eg:
[student@room9pc01 home]$ cd
[student@room9pc01 ~]$ pwd
/home/student
[student@room9pc01 ~]$ cd .
[student@room9pc01 ~]$ pwd
/home/student
[student@room9pc01 ~]$ cd ..
[student@room9pc01 home]$ pwd
/home
[student@room9pc01 home]$ cd -
/home/student
[student@room9pc01 ~]$ pwd
/home/student
[student@room9pc01 ~]$ cd ../..
[student@room9pc01 /]$ pwd
/

# ls		//列出目录内容/文件权限
# cat		//查看文件内容
eg:
[student@room9pc01 /]$ cd
[student@room9pc01 ~]$ pwd
/home/student
[student@room9pc01 ~]$ ls
[student@room9pc01 ~]$ cd /etc/redhat-release 
-bash: cd: /etc/redhat-release: 不是目录
[student@room9pc01 ~]$ cat /etc/redhat-release 
CentOS Linux release 7.5.1804 (Core) 

# lscpu		//查看cpu信息
# cat /proc/meminfo	//查看内存信息
eg:
[student@room9pc01 ~]$ lscpu 
[student@room9pc01 ~]$ cat /proc/meminfo
		16:10  -  16:30
# hostname		//查看主机名
# ifconfig		//查看ip地址
# mkdir			//创建目录
# touch			//创建文件
eg:
[student@room9pc01 ~]$ hostname
[student@room9pc01 ~]$ ifconfig
[student@room9pc01 ~]$ ls /tmp/
[student@room9pc01 ~]$ mkdir /tmp/vod
[student@room9pc01 ~]$ ls /tmp/
vod
[student@room9pc01 ~]$ ls /tmp/
vod
[student@room9pc01 ~]$ touch /tmp/nsd1907.txt
[student@room9pc01 ~]$ ls /tmp/
nsd1907.txt  vod

# less			//查看大文件内容分屏查看
# head			//默认查看文件头10行
# tail			//默认查看文件尾10行
# grep			//过滤包含关键字的行
# nmtui			//配置网络参数（ip地址、子网掩码、网关、dns、主机名）
# poweroff		//关机
# reboot		//重启

# cd /root
# cd root	
5.编辑命令或路径的技巧：　Tab可以进行补全       
# if(tab)(tab)
if         ifdown     ifup
ifcfg      ifenslave  
ifconfig   ifstat     
# ifco(tab)
# cat /et(tab)/red(tab)
CentOS Linux release 7.5.1804 (Core)
# ls /etc/sysconfig/network-scripts/ifcfg-eth0 
# ls /et(tab)/sysco(tab)/netw(tab)-(tab)/ifc(tab)-e(tab)

补充: Linux下的颜色
蓝色 --> 目录
红色 --> 压缩文件
绿色 --> 可执行文件

课外作业：
1. 为什么计算机的时间是从1970年1月1开始?
https://mixer-b.iteye.com/blog/1563869
2.C语言之父
3. 什么是Linux?
4. 如何破解Linux密码?
5.


###########################################################

date 3

早自习默写
1. Linux下目录作用（day02讲解的四个）
2. Linux命令行提示符
3. 写出10个以上的Linux命令

一、命令行基础
1. 命令行的格式
命令字   [选项]…   [参数1] [参数2]…
[ ] 表示里面的内容可有可无
在执行一个命令的时候，命令字必须存在，选项和参数可有可无
命令字 选项 参数之间必须有空格
选项：用来调控执行方式
     单个字符一般用-
     单词一般用--
eg：
（以下命令不需要理解意思，只需要知道谁是命令字，谁是选项，选项什么时候-，什么时候用--）
# ls
# ls -l
# ls -l -h  = # ls -lh
# ls --help
# ls -ld /home
# ls -ld /home  /boot
参数：命令的操作对象，如文档的存放路径、用户名等
2.快捷编辑
tab键功能：
命令或者路径的补齐，如果输入的内容唯一标识某一个命令或者路径，tab一次会自动补齐。如果不唯一则tab2次显示出以输入内容开头的所有的命令或者路径
      排错
eg：
# if(tab)(tab)
if         ifdown     ifup
ifcfg      ifenslave  
ifconfig   ifstat     
# ifco(tab)
# cat /et(tab)/red(tab)
CentOS Linux release 7.5.1804 (Core)
# ls /etc/sysconfig/network-scripts/ifcfg-eth0 
# ls /et(tab)/sysco(tab)/netw(tab)-(tab)/ifc(tab)-e(tab)
快捷键
Ctrl + l	清空整个屏幕
Ctrl + c	废弃当前编辑的命令行
Esc+.		粘贴上一个命令的参数
3.mount挂载操作
挂载
将光盘/U盘/分区/网络存储等设备装到某个Linux目录，通过访问这个目录来操作设备上的文档
mount 设备 挂载点（一定是目录）
卸载
umount 设备
umount 挂载点
Linux下的光驱设备
/dev/sr0
/dev/cdrom

eg:访问centos7安装镜像文件内容
1.把centos7镜像放入光驱
点击虚拟机图形的查看/详情/，找到IDE CDROM1，选择连接。选择ISO映像位置，浏览/iso/CentOS7-1804.iso/选择卷/确定
2.mount命令挂载
[root@localhost ~]# ls /mnt/
[root@localhost ~]# mount /dev/cdrom  /mnt/
3.验证是否挂载成功
[root@localhost ~]# ls /mnt/
4.umount命令卸载
[root@localhost ~]# umount /dev/cdrom
或者
[root@localhost ~]# umount /mnt
5.验证是否卸载成功
[root@localhost ~]# ls /mnt/

注意事项:
1.卸载不要在当前的挂载点(访问点)目录下
[root@localhost ~]# cd /mnt
[root@localhost mnt]# umount /mnt
umount: /dvd：目标忙。
2.挂载允许一个设备具备多个挂载点(访问点)
3.不允许多个设备挂载到一个挂载点(访问点)

二、目录和文件管理
1. cd ~user	表示进入用户user的家目录
2. ls 		列出文档及属性
	-l	以长格式显示,显示目录内容的详细属性
	-A	包括名称以 . 开头的隐藏文档
	-d	显示目录本身(而不是内容)的属性
	-h	提供易读的容量单位(K、M等)
eg：
[root@localhost ~]# cd ~
[root@localhost ~]# pwd
[root@localhost ~]# ls /root/
[root@localhost ~]# mkdir ~/day03
[root@localhost ~]# ls /root/
[root@localhost ~]# cd ~/day03/
[root@localhost day03]# pwd
[root@localhost day03]# cd ~root
[root@localhost ~]# pwd
备注：
~后面接/的表示的是路径
~后面不是接/的表示是用户
[root@localhost ~]# cd 
[root@localhost ~]# ls
[root@localhost ~]# ls /root
[root@localhost ~]# ls -l  /root   //显示目录内容的详细属性
[root@localhost ~]# ls -ld /root   //显示目录本身的详细属性
[root@localhost ~]# ls -lh /root
[root@localhost ~]# ls -l /dev/cdrom   //显示文件详细属性
[root@localhost ~]# ls -l /etc/passwd
[root@localhost ~]# ls -lh /etc/passwd
[root@localhost ~]# ls /root
[root@localhost ~]# ls -A /root
3. 使用通配符		
针对不确定的文档名称,以特殊字符表示
*	匹配0到任意个字符                
?	单个字符
eg：
[root@localhost ~]# ls /boot
[root@localhost ~]# ls /boot/vm*     //以vm开头
[root@localhost ~]# ls /root/a*      //以a开头
[root@localhost ~]# ls /dev/tty*     //以tty开头
[root@localhost ~]# ls /etc/*tab     //以tab结尾
[root@localhost ~]# ls /etc/*.conf   //以.conf结尾
[root@localhost ~]# ls /etc/r*.conf  //以r开头并且.conf结尾
[root@localhost ~]# ls /etc/*passwd*
[root@localhost ~]# ls /dev/tty?
[root@localhost ~]# ls /dev/tty??

[a-z]		多个字符或连续范围中的一个,若无则忽略
{a,min,xy}	多组不同的字符串,全匹配
eg:
[root@localhost ~]# ls /dev/tty[3-8]
[root@localhost ~]# ls /dev/tty[0-9]
[root@localhost ~]# ls /dev/tty{1,3,5,7,9}
[root@localhost ~]# ls /dev/tty{1,3,5,7,9,23}
[root@localhost ~]# ls /dev/tty{1,3,S0,S1}
[root@localhost ~]# ls /dev/tty{1,3,S0,haha}
4.别名的定义:简化复杂命令
alias					查看已设置的别名
alias 别名名称='实际执行的命令行'	定义新的别名
unalias [别名名称]			取消已设置的别名
		16:10 - 16:25
eg:
[root@localhost ~]# hostname
localhost.localdomain
[root@localhost ~]# hn
bash: hn: 未找到命令...
[root@localhost ~]# alias hn='hostname'  //定义别名
[root@localhost ~]# hn                   //运行别名测试
[root@localhost ~]# alias        //查看当前系统有效的别名
[root@localhost ~]# unalias hn   //删除别名
[root@localhost ~]# hn
bash: hn: 未找到命令...
红帽考试题：
[root@localhost ~]# alias qstat='/bin/ps -Ao pid,tt,user,fname,rsz',
[root@localhost ~]# qstat
5. mkdir 创建目录
-p	创建父目录
ls
-R	递归:目录本身以及目录下所有
[root@localhost ~]# ls /opt
[root@localhost ~]# mkdir /opt/nsd01
[root@localhost ~]# ls /opt/
[root@localhost ~]# mkdir  /opt/nsd02   /opt/nsd03
[root@localhost ~]# ls /opt/
[root@localhost ~]# mkdir /vod/movie/cartoon
[root@localhost ~]# ls -R /vod
[root@localhost ~]# mkdir -p /vod/movie/cartoon
[root@localhost ~]# ls -R /vod
6.grep针对文本文件内容进行过滤,输出包含指定字符串的行
-v	取反匹配
-i	忽略大小写
eg:
[root@localhost /]# grep root /etc/passwd
[root@localhost /]# grep -v root /etc/passwd
[root@localhost /]# grep ROOT /etc/passwd
[root@localhost /]# grep -i ROOT /etc/passwd
word 	包含字符串word
^word 	以字符串word开头
word$ 	以字符串word结尾
eg:
[root@localhost /]# grep ^root /etc/passwd
[root@localhost /]# grep root$ /etc/passwd
[root@localhost /]# grep bash$ /etc/passwd

grep -w -o root /etc/passwd       //-w精确匹配 -o匹配行放在一列

去重命令中的uniq和sort的区别
	sort -u '文件'
	sort -n '文件' | uniq -c
查看目录中最近被修改的文件
	ls -t '目录'
如何计算字符串与数组的长度
	字符串: expr length '字符串'/$变量名
		${#字符串/变量名}
	数组: ${#数组名[*]}
 vim中查看匹配的单词,并显示具体个数
	:%s/root//gn
 vim中不忽略大小写查找匹配的单词
	:set noignorecase
 vim中如何将文件最后一行置顶
	z+t按键

7.复制
格式:
cp [选项]... 原文件...      目标路径
-r	递归,复制目录时必须有此选项
eg:
[root@localhost ~]# ls /tmp/bak
[root@localhost ~]# mkdir /tmp/bak
[root@localhost ~]# ls /tmp/bak
[root@localhost ~]# cp /etc/passwd  /tmp/bak
[root@localhost ~]# ls /tmp/bak
[root@localhost ~]# cp /home/  /tmp/bak
[root@localhost ~]# ls /tmp/bak
[root@localhost ~]# cp -r /home/  /tmp/bak
[root@localhost ~]# ls /tmp/bak
//可以支持两个以上的参数,永远将最后一个参数做目标,其他所有参数作为源
[root@localhost ~]# ls /tmp/bak
[root@localhost ~]# cp -r  /etc/hosts  /etc/fstab /boot/   /tmp/bak
[root@localhost ~]# ls /tmp/bak
//cp经常与点  . 连用,将数据复制到当前路径下
.	当前目录
[root@localhost ~]# cd /tmp/bak
[root@localhost bak]# pwd
[root@localhost bak]# ls
[root@localhost bak]# cp /etc/shadow  .  
[root@localhost bak]# ls
//复制到目标路径下,可以重新命名   
[root@localhost /]# ls /tmp/bak
[root@localhost /]# cp /etc/passwd  /tmp/bak
[root@localhost /]# ls /tmp/bak
[root@localhost /]# cp /etc/passwd /tmp/bak/pd
[root@localhost /]# ls /tmp/bak
[root@localhost /]# cp -r /home/ /tmp/bak/abc
[root@localhost /]# ls /tmp/bak
8.rm 删除		
格式:rm [选项]... 文件或目录...            
-r	递归删除(含目录)
-f	强制删除
[root@localhost ~]# rm /tmp/bak/abc
[root@localhost ~]# rm -r /tmp/bak/abc    
//试了几次不耐烦可以ctrl+c
[root@localhost ~]# rm -rf /tmp/bak/abc
[root@localhost ~]# ls /tmp/bak
[root@localhost ~]# rm -rf /tmp/bak
[root@localhost ~]# ls /tmp/
9.mv 移动/改名
格式: mv [选项]... 原文件...    目标路径
[root@localhost ~]# ls /tmp/nsd01
[root@localhost ~]# mkdir /tmp/nsd01
[root@localhost ~]# ls /tmp/nsd01
[root@localhost ~]# touch /tmp/1.txt
[root@localhost ~]# ls /tmp/
[root@localhost ~]# mv /tmp/1.txt /tmp/nsd01/
[root@localhost ~]# ls /tmp/
[root@localhost ~]# ls /tmp/nsd01/
//重命名:路径不变的移动
[root@localhost ~]# mv /tmp/nsd01/  /tmp/haha01
[root@localhost ~]# ls /tmp/
[root@localhost ~]# mv /tmp/haha01/ /tmp/stu01
[root@localhost ~]# ls /tmp/


补充：
Linux下目录结构
/proc	虚拟目录
/tmp	临时目录,默认数据存放10天不做任何操作系统直接删除
/etc	配置文件存放目录
/mnt	系统提供的挂载点
/boot	启动相关的目录，内核文件存放这里


课外作业：
1. 请问输入以下命令的区别
# cd /home
# cd home
2. 请问输入以下命令的区别
$ cd
$ ls
$ ls /root
3. 请分析下列两次复制的不同:
# rm -rf /opt/*
# cp -r /home/  /opt/redhat
将/home目录复制到/opt/并且重命名为redhat
# cp -r /home/  /opt/redhat
将/home目录复制到/opt/redhat目录下
4.linux虚拟机里查看日历
# cal 2019

##################################################
查看及切换目录
• pwd — Print Working Directory
– 用途:查看当前工作目录

• cd — Change Directory
– 用途:切换工作目录
– 格式:cd  [目标文件夹位置]

• ls — List
– 格式:ls [选项]... [目录或文件名]...

蓝色:目录
黑色:文本文件
[root@localhost ~]# pwd      #显示当前所在位置
[root@localhost ~]# cd  /    #切换到根目录下
[root@localhost /]# pwd       
[root@localhost /]# ls       #显示当前目录下内容
 
[root@localhost /]# cd /bin   #切换到/bin目录
[root@localhost bin]# pwd      
[root@localhost bin]# ls

[root@localhost /]# cd /boot   #切换到/boot目录
[root@localhost boot]# pwd
[root@localhost boot]# ls

[root@localhost /]# cd /root   #切换到/root目录
[root@localhost ~]# pwd
[root@localhost ~]# ls


查看文本文件命令:cat
[root@localhost ~]# ls /root/anaconda-ks.cfg
[root@localhost ~]# cat   /root/anaconda-ks.cfg
查看当前系统的版本
[root@localhost ~]# cat  /etc/redhat-release 
CentOS Linux release 7.5.1804 (Core) 

[root@localhost ~]# ls /etc/passwd
[root@localhost ~]# cat  /etc/passwd

[root@localhost ~]# ls /etc/fstab
[root@localhost ~]# cat  /etc/fstab
[root@localhost ~]# ls /etc/hosts
[root@localhost ~]# cat  /etc/hosts


查看CPU和内存
• 列出CPU处理器信息
[student@room9pc01 ~]$ lscpu 
CPU(s):                4

型号名称：        Intel(R) Core(TM) i5-4430S CPU @ 2.70GHz

• 检查内存大小、空闲情况
[student@room9pc01 ~]$ cat  /proc/meminfo
MemTotal:       16330736 kB

####################################################
• 列出当前系统的主机名称
[root@svr7 桌面]# hostname
[root@svr7 桌面]# hostname  A.tedu.cn   #临时设置主机名

[root@svr7 桌面]# hostname
[root@svr7 桌面]# exit    #关闭当前的终端

再开一个新的终端,查看提示符的变化

• 列出已激活的网卡连接信息
[root@A ~]# ifconfig    #查看网卡IP地址信息

[root@A ~]# ifconfig eth0 192.168.1.1  #临时设置IP地址
[root@A ~]# ifconfig eth0

  eth0:第一张网卡

lo:回环接口  专用于测试   本机访问本机

    127.0.0.1  永远代表本机

[root@A ~]# ping  127.0.0.1  
   按Ctrl + c 结束正在运行指令


• 重启系统命令
[root@A ~]# reboot

[root@localhost ~]# hostname        #查看主机名
[root@localhost ~]# ifconfig eth0   #查看IP地址

• 设置永久的主机名\IP地址\子网掩码\DNS服务器地址\网关地址
[root@A ~]# nmtui                        
 设置系统主机名-->输入新的名字-->确定-->确定

[root@A ~]# nmtui
　编辑连接 -->eth0-->编辑ipv4-->显示-->将自动修改手动
　-->按空格　勾选　自动连接    　    #每次开机自动生效
　-->按空格　勾选　对所有用户有效  

激活配置
[root@A ~]# nmtui
　启用连接 -->eth0-->敲回车　禁用-->敲回车　激活
　最终eth0前面有一个＊代表激活状态
[root@A ~]# ifconfig eth0


####################################################

• mkdir — Make Directory
– 格式:mkdir   [/路径/]目录名...
[root@1906 ~]# mkdir /root/nsd01    #在/root创建nsd01目录
[root@1906 ~]# ls /root/
[root@1906 ~]# mkdir /opt/nsd02  #在/opt创建nsd02目录
[root@1906 ~]# ls /opt/

[root@1906 ~]# mkdir nsd03    #当前路径下创建nsd03目录
[root@1906 ~]# ls             #查看当前路径下内容
[root@1906 ~]# pwd
[root@1906 ~]# mkdir /nsd04   #在/目录创建nsd04目录
[root@1906 ~]# ls /

[root@1906 ~]# touch /root/1.txt   #创建文本文件
[root@1906 ~]# ls /root/
[root@1906 ~]# touch /opt/2.txt
[root@1906 ~]# ls /opt/
##################################################
绝对路径:从根开始的路径
相对路径:不从根开始的路径(相对于当前的路径)

[root@1906 ~]# cd /etc/pki/
[root@1906 pki]# pwd
[root@1906 pki]# ls
[root@1906 pki]# cd  /etc/pki/CA   #绝对路径进入
[root@1906 CA]# pwd

[root@1906 CA]# cd /etc/pki/
[root@1906 pki]# pwd
[root@1906 pki]# ls
[root@1906 pki]# cd  CA     #进入当前路径下的CA
[root@1906 CA]# pwd


  .. :上一级目录
[root@1906 /]# cd /etc/pki/
[root@1906 pki]# pwd
/etc/pki
[root@1906 pki]# cd  ..   #返回当前路径的上一层
[root@1906 etc]# pwd
/etc
[root@1906 etc]# cd  ..
[root@1906 /]# pwd
/
[root@1906 /]# cd  ..

##############################################
文本内容操作
• less分屏阅读工具
• 格式:less [选项] 文件名...

– 优势:支持前后翻页
• 基本交互操作
– 按 / 键向后查找(n、N切换)

[root@1906 /]# less /etc/passwd
   按键盘  上 下 键 进行滚动
   输入 /bin 全文查找bin关键字
   按键盘  n 可以跳转匹配的项
   按键盘  q  退出

#####################################################
• head、tail 命令                                 
– 格式:
	head -n 数字 文件名
	tail -n 数字 文件名

[root@1906 /]# head -2 /etc/passwd  #显示文件头2行内容
[root@1906 /]# head -3 /etc/passwd

[root@1906 /]# tail -2 /etc/passwd
[root@1906 /]# tail -1 /etc/passwd  #显示文件最后一行内容

[root@1906 /]# head  /etc/passwd  #默认显示头10行
[root@1906 /]# tail  /etc/passwd  #默认显示尾10行

####################################################
• grep工具
– 用途:输出包含指定字符串的行
– 格式:grep  '字符串'     目标文件

[root@1906 /]# grep  root  /etc/passwd

[root@1906 /]# grep lisi  /etc/passwd

[root@1906 /]# grep sbin  /etc/passwd

###################################################

date 4

文本编辑器vim

  vim具备创建文本文件功能,不能创建目录

三个模式:
     命令模式      插入模式(编辑模式  输入模式)     末行模式

[root@1906 /]# vim /opt/haxi.txt

        	命----------i 键--------->插入模式(Esc返回到命令模式)
		令
		模
		式----------:  键--------->末行模式(Esc返回到命令模式)

     末行模式     :wq  保存并退出
     末行模式     :q!  强制不保存并退出

##################################################
• 关机:poweroff
[root@svr7 ~]# poweroff

################################################# 3
如何编写命令行

– 用来实现某一类功能的指令或程序
    总结:执行Linux大多数命令,都要找到对应执行程序

– 命令的执行依赖于解释器(默认解释器:/bin/bash)

     用户----->解释器------>内核----->硬件

绿色:可以执行的程序

####################################################
• Linux命令的分类
– 内部命令:属于解释器的一部分
– 外部命令:解释器之外的其他程序

####################################################
命令行的一般格式                                         
• 基本用法
– 命令字      [选项]...     [参数1]       [参数2]...	
  
[root@1906 ~]# cat --help         #查看命令的帮助信息
[root@1906 ~]# cat   /etc/passwd
[root@1906 ~]# cat  -n  /etc/passwd    #显示行号
[root@1906 ~]# cat  -n  /etc/redhat-relese
[root@1906 ~]# cat  -n  /etc/shells
[root@1906 ~]# cat  -n  /etc/shadow

##################################################
快速编辑技巧
• Tab键自动补全
– 可补齐命令字、选项、参数、文件路径、软件名、服务名
]# if(tab)(tab)
]# ifco(tab)

]# cat /et(tab)/red(tab)
 
]# ls /etc/sysconfig/network-scripts/ifcfg-eth0 
]# ls /et(tab)/sysco(tab)/netw(tab)-(tab)/ifc(tab)-e(tab)



• 快捷键
– Ctrl + l:清空整个屏幕
– Ctrl + c:废弃当前编辑的命令行(结束正在运行的命令)
– Esc + . 或  Alt + .:粘贴上一个命令的参数

– Ctrl + u:清空至行首
– Ctrl + w:往回删除一个单词(以空格界定)

[root@1906 ~]# ls /etc/shells 
[root@1906 ~]# cat  ALT+.
[root@1906 ~]# cat -n  ALT+.

]# ls /etc/sysconfig/network-scripts/ifcfg-eth0 
]# cat -n ALT+.

#####################################################
mount挂载操作:让目录成为设备的访问点

1.系统光盘获得众多的软件包,安装软件包
2.系统中显示光盘内容

Windows:
   光盘文件------>光驱设备------->CD驱动器(访问点)

Linux:
   光盘文件------>光驱设备------->访问点(目录)
            /dev/cdrom

青色:快捷方式

1.图形将光盘文件放入到虚拟光驱设备
2.查看光驱设备
[root@1906 ~]# ls -l /dev/cdrom  #光驱快捷方式
[root@1906 ~]# ls /dev/sr0    #实际光驱设备

3.进行挂载                                         
• 使用mount命令
– 格式:mount 设备路径 挂载点目录
[root@1906 ~]# mkdir /dvd
[root@1906 ~]# ls /dvd/

[root@1906 ~]# mount  /dev/cdrom  /dvd
mount: /dev/sr0 写保护，将以只读方式挂载
[root@1906 ~]# ls /dvd/
[root@1906 ~]# ls /dvd/P(tab)

4.卸载
[root@1906 /]# umount /dvd/
[root@1906 /]# ls /dvd

[root@1906 /]# mkdir /nsd1906
[root@1906 /]# mount /dev/cdrom  /nsd1906/
mount: /dev/sr0 写保护，将以只读方式挂载
[root@1906 /]# ls /nsd1906/


常见的提示:
[root@1906 dvd]# pwd
[root@1906 dvd]# umount /dvd/
umount: /dvd：目标忙。

注意事项:
1.允许一个设备可以具备,多个不同的挂载点目录
2.不允许一个挂载点目录,有多个设备
3.建议挂点目录是一个自己创建的目录

##################################################
目录和文件管理

使用pwd、cd
• pwd — Print Working Directory
– 用途:查看当前工作目录

• cd — Change Directory
– 用途:切换工作目录
– 格式:cd  [目标文件夹位置]

	. 表示当前目录
	.. 表示父目录
	~:家目录
	~user表示用户user的家目录

  /root:管理员的家目录
  /home:存放所有普通用户的家目录

[root@1906 /]# cd ~root
[root@1906 ~]# pwd
/root
[root@1906 ~]# cd ~lisi
[root@1906 lisi]# pwd
/home/lisi
[root@1906 lisi]# useradd tom   #创建普通用户tom
[root@1906 lisi]# cd ~tom
[root@1906 tom]# pwd
/home/tom
[root@1906 tom]# 

• ls — List
– 格式:ls [选项]... [目录或文件名]

• 常用命令选项
– -l:以长格式显示,显示详细信息
– -A:包括名称以 . 开头的隐藏文档
– -d:显示目录本身(而不是内容)的属性
– -h:提供易读的容量单位(K、M等)

[root@1906 ~]# ls -l /etc/passwd
[root@1906 ~]# ls -l -h /etc/passwd

[root@1906 ~]# ls -lh /etc/passwd  #显示文件的详细属性

[root@1906 ~]# ls -l /boot/     #显示目录内容详细属性
[root@1906 ~]# ls -lh /boot/   

[root@1906 /]# ls -ld /        #显示目录本身的详细属性
[root@1906 /]# ls -ld /opt
[root@1906 /]# ls -ld /boot

[root@1906 /]# ls -A /root  #显示目录的所有内容,包括隐藏数据
[root@1906 /]# ls -A /boot
[root@1906 /]# 

#################################################
使用通配符

• 针对不确定的文档名称,以特殊字符表示
– *:任意多个任意字符
– ?:单个字符

[root@1906 /]# ls /boot/vm*  #在/boot目录显示vm开头的数据
[root@1906 /]# ls /dev/tty*  #显示tty开头的数据

[root@1906 /]# ls /etc/*tab    #以tab作为结尾的数据
[root@1906 /]# ls /etc/*.conf  #以.conf作为结尾的数据

[root@1906 /]# ls /dev/tty?
[root@1906 /]# ls /dev/tty??
[root@1906 /]# ls /dev/tty???

[root@1906 /]# ls /etc/??tab

• 针对不确定的文档名称,以特殊字符表示
– [a-z]:多个字符或连续范围中的一个,若无则忽略,不能超过10

– {a,min,xy}:多组不同的字符串,全匹配
[root@1906 /]# ls /dev/tty[3-8]
[root@1906 /]# ls /dev/tty[4-7]

[root@1906 /]# ls /dev/tty{1,21,60}
[root@1906 /]# ls /dev/tty{1,3,5,7,9}

###################################################
别名的定义:简化复杂的命令

• 查看已设置的别名
– alias [别名名称]

• 定义新的别名
– alias 别名名称= '实际执行的命令行'

• 取消已设置的别名
– unalias [别名名称]

[root@1906 /]# hostname             
1906.tedu.cn
[root@1906 /]# hn
bash: hn: 未找到命令...
[root@1906 /]# alias hn='hostname'   #定义别名

[root@1906 /]# alias   #显示当前系统有效别名
[root@1906 /]# hn      #运行hn执行成功

[root@1906 /]# unalias hn   #删除别名
[root@1906 /]# hn
bash: hn: 未找到命令...

###################################################

• mkdir — Make Directory
– 格式:mkdir [-p] [/路径/]目录名...
[root@1906 /]# mkdir -p /vod/movie/cartoon
#-p表示连父目录一起创建

[root@1906 /]# ls -R /vod

[root@1906 /]# mkdir /opt/nsd01
[root@1906 /]# ls /opt/

[root@1906 /]# mkdir -p /opt/aa/bb/cc/dd
[root@1906 /]# ls /opt/
[root@1906 /]# ls -R /opt/aa    #-R表示递归显示

查找文本内容
• 根据字符串模式提取文本行
– grep [选项] '匹配模式' 文本文件...

• 常用命令选项
– -v,取反匹配
– -i,忽略大小写

[root@1906 /]# grep root /etc/passwd
[root@1906 /]# grep -v root /etc/passwd  #取反查找

[root@1906 /]# grep ROOT /etc/passwd
[root@1906 /]# grep -i ROOT /etc/passwd  #忽略大小写

– ^word 以字符串word开头
– word$ 以字符串word结尾

[root@1906 /]# grep ^root  /etc/passwd  #以root开头
[root@1906 /]# grep bash$  /etc/passwd  #以bash结尾

####################################################
rm 删除
• rm — Remove
– 格式:rm [选项]... 文件或目录...

• 常用命令选项
– -r、-f:递归删除(含目录)、强制删除

[root@1906 /]# mkdir /opt/nsdtest
[root@1906 /]# touch /opt/1.txt
[root@1906 /]# touch /opt/2.txt
[root@1906 /]# ls /opt/
1.txt  2.txt  nsdtest
[root@1906 /]# rm -rf /opt/1.txt    #强制删除所有
[root@1906 /]# rm -rf /opt/2.txt 
[root@1906 /]# ls /opt/

[root@1906 /]# rm -rf /opt/nsdtest
[root@1906 /]# ls /opt/

###################################################
mv 移动/改名
• mv — Move
– 格式:mv [选项]... 原文件...   目标路径

[root@1906 /]# mkdir /opt/nsd        
[root@1906 /]# touch /opt/a.txt
[root@1906 /]# ls /opt/

[root@1906 /]# mv /opt/a.txt  /opt/nsd
[root@1906 /]# ls /opt/nsd
[root@1906 /]# ls /opt/

重命名:路径不变的移动
[root@1906 /]# mv /opt/nsd/  /opt/haha
[root@1906 /]# ls /opt/

[root@1906 /]# mv /opt/haha/ /opt/student
[root@1906 /]# ls /opt/

###################################################
cp 复制
• cp — Copy
– 格式:cp [选项]... 原文件...    目标路径

• 常用命令选项
– -r:递归,复制目录时必须有此选项

 /etc:存放系统配置文件
 /opt:用户可选择目录

[root@1906 /]# cp /etc/passwd  /opt/
[root@1906 /]# ls /opt/

[root@1906 /]# cp -r /home  /opt/
[root@1906 /]# ls /opt/

[root@1906 /]# cp -r /etc/fstab   /opt/
[root@1906 /]# ls /opt/

复制可以支持多个参数:永远把最后一个参数作为目标,其他的所有参数都作为源
]# cp  -r    /boot/    /etc/shadow     /etc/resolv.conf   /etc/hosts   /opt/

]# ls /opt/
复制经常与点连用:   . 表示当前路径
[root@1906 /]# cd /opt/
[root@1906 opt]# pwd
[root@1906 opt]# ls
[root@1906 opt]# cp /etc/shells   .   
[root@1906 opt]# ls

[root@1906 /]# cd /etc/sysconfig/network-scripts/
[root@1906 network-scripts]# pwd
[root@1906 network-scripts]# cp /etc/passwd  . 
[root@1906 network-scripts]# ls

复制出现重名:在本次操作临时取消别名
[root@1906 /]# ls /opt/

[root@1906 /]# cp -r /boot/  /opt/

[root@1906 /]# \cp -r /boot/  /opt/  #本次操作临时取消别名


复制:可以重新命名,目标路径下数据
[root@1906 /]# cp /etc/passwd  /opt/pa.txt
[root@1906 /]# ls /opt/

[root@1906 /]# cp -r /boot/  /opt/abc
[root@1906 /]# ls /opt/

以下两次复制有何不同?
]# rm -rf /opt/*            #删除/opt目录下所有内容
]# cp -r /home/  /opt/test  
    #将/home目录复制到/opt目录下重命名为test
]# cp -r /home/  /opt/test
    #将/home目录复制到/opt/test目录下
[root@1906 /]# ls /opt/
[root@1906 /]# ls /opt/test/
##################################################### 4

重定向输出操作:将前面的命令的输出,写入到文本文件
  >:覆盖重定向
  >>:追加重定向
[root@1906 ~]# ls --help  > /opt/ls.txt
[root@1906 ~]# ls /opt/
[root@1906 ~]# less /opt/ls.txt 

[root@1906 ~]# hostname
[root@1906 ~]# hostname > /opt/ls.txt 
[root@1906 ~]# cat /opt/ls.txt

[root@1906 ~]# hostname >> /opt/ls.txt
[root@1906 ~]# cat /opt/ls.txt

[root@1906 ~]# hostname >> /opt/ls.txt 
[root@1906 ~]# cat /opt/ls.txt

[root@1906 ~]# head  -2 /etc/passwd       
[root@1906 ~]# head  -2 /etc/passwd  >  /opt/ls.txt

[root@1906 ~]# cat /opt/ls.txt 

[root@1906 ~]# echo 123456

[root@1906 ~]# echo 123456 >> /opt/ls.txt  #非交互式
[root@1906 ~]# cat /opt/ls.txt

[root@1906 ~]# echo hello >> /opt/ls.txt  #非交互式
[root@1906 ~]# cat /opt/ls.txt

##################################################
 管道操作  |  : 
      将前面命令的输出,交由后面命令处理,作为后面命令的参数

  显示/etc/passwd的8至12行内容
[root@1906 ~]# head -12 /etc/passwd
[root@1906 ~]# head -12 /etc/passwd | tail -5
 
[root@1906 ~]# cat -n /etc/passwd 
[root@1906 ~]# cat -n /etc/passwd  |  head -12
[root@1906 ~]# cat -n /etc/passwd |  head -12  | tail -5

[root@1906 ~]# ifconfig | less
[root@1906 ~]# ifconfig | head -2

####################################################

管理用户和组   
  
   用户帐号:  1.登录系统    2.确认身份,实现权限控制
   组:方便管理用户

   唯一标识:  UID   GID

   组分类: 基本组(私有组)     附加组(从属组)
   一个用户至少属于一个组

[root@1906 ~]# useradd nsd01
              组:nsd01

              组: cw  js  xs

添加用户
用户基本信息存放在 /etc/passwd文件(系统级配置文件)
[root@1906 ~]# head -1 /etc/passwd
root:x:0:0:root:/root:/bin/bash
用户名:密码占位符:UID:基本组GID:描述信息:家目录:解释器程序

• 使用 useradd 命令
– useradd [选项]... 用户名

• 常用命令选项
– -u 用户id、-d 家目录路径、-s 登录解释器、-G 附加组

[root@1906 ~]# useradd -u 1500 nsd01   #创建用户指定UID
[root@1906 ~]# id nsd01

[root@1906 ~]# useradd nsd02
[root@1906 ~]# id nsd02         #查询nsd02用户基本的信息

[root@1906 ~]# ls /home/

]# useradd -d /opt/abc  nsd05    #创建用户指定家目录
]# ls /opt/

]# useradd -u 2000 -d /opt/aa  nsd08    
]# ls /opt/                                 


用户名:密码占位符:UID:基本组GID:描述信息:家目录:解释器程序

-s:指定解释器程序

 /sbin/nologin:禁止用户登录系统
[root@1906 ~]# useradd  -s /sbin/nologin  nsd13
[root@1906 ~]# id nsd13

[root@1906 ~]# grep nsd13  /etc/passwd

[root@1906 ~]# useradd  -s /sbin/nologin  nsd14
[root@1906 ~]# id nsd14

[root@1906 ~]# grep  nsd14  /etc/passwd

-G:指定附加组(从属组)
[root@1906 ~]# groupadd tedu   #创建组tedu

[root@1906 ~]# useradd nsd15
[root@1906 ~]# id nsd15

[root@1906 ~]# useradd -G tedu nsd16  #创建用户指定附加组
[root@1906 ~]# id nsd16

##################################################
设置登录密码
  复杂密码:   3/4原则  字母  数字  大小写  特殊符号


• 使用 passwd 命令

[root@1906 ~]# useradd nsd17
[root@1906 ~]# passwd nsd17
更改用户 nsd17 的密码 。
新的 密码：                  #输入新的密码
重新输入新的 密码：     #重新输入新的密码
passwd：所有的身份验证令牌已经成功更新
[root@1906 ~]# su - nsd17   #命令行临时切换身份   
[nsd17@1906 ~]$ passwd 
更改用户 nsd17 的密码 。
为 nsd17 更改 STRESS 密码。
（当前）UNIX 密码：              #输入旧的密码
新的 密码：
重新输入新的 密码：
passwd：所有的身份验证令牌已经成功更新。
[nsd17@1906 ~]$ exit   #回到root用户
非交互式设置密码

[root@1906 ~]# echo 123 | passwd --stdin nsd17

[root@1906 ~]# echo redhat | passwd --stdin nsd17

[root@1906 ~]# echo 123456 | passwd --stdin nsd17

###################################################
用户密码信息存放在 /etc/shadow 文件
[root@1906 ~]# grep nsd17 /etc/shadow
nsd17:$6$UJ1UmCDO$uxsebJRVxjfOTUngX3nfI21mYCrEYiiPZs6Q4FD5Op7kzEtF7f8
u49XSm8AVGqm6X4Ny/pULXIKngkDIo7pSS1:18079:0:99999:7:::

用户名:密码加密字符串:上一次修改密码的时间

          上一次修改密码的时间:1970-1-1~2019-7-2  经历的天数

####################################################
修改用户属性
• 使用 usermod 命令
– usermod [选项]... 用户名

• 常用命令选项
– -u 用户id、-d 家目录路径、-s 登录解释器
– -G 附加组

[root@1906 ~]# useradd nsd19
[root@1906 ~]# grep nsd19 /etc/passwd

]# usermod -u 2500  -G tedu   -s /sbin/nologin          -d   /mnt/abc   nsd19

[root@1906 ~]# grep nsd19 /etc/passwd
[root@1906 ~]# id nsd19

###################################################
删除用户
• 使用 userdel 命令
– userdel [-r] 用户名

   -r:连同家目录一并删除



[root@1906 ~]# userdel nsd01
[root@1906 ~]# id nsd01
[root@1906 ~]# ls /home/

[root@1906 ~]# userdel -r nsd02
[root@1906 ~]# id nsd02
[root@1906 ~]# ls /home/

####################################################
管理组账号
添加组
组基本信息存放在 /etc/group文件

• 使用 groupadd 命令
– groupadd [-g 组ID] 组名

[root@1906 ~]# groupadd tarena
[root@1906 ~]# grep tarena /etc/group
tarena:x:2010:
组名:组的密码占位符:组GID:组成员列表

[root@1906 ~]# useradd natasha
[root@1906 ~]# useradd dc
[root@1906 ~]# useradd harry
[root@1906 ~]# useradd jack

管理组成员
• 使用 gpasswd 命令
– gpasswd -a  用户名   组名
– gpasswd -d  用户名   组名

[root@1906 ~]# gpasswd -a natasha tarena     
[root@1906 ~]# grep tarena /etc/group

[root@1906 ~]# gpasswd -a dc tarena
[root@1906 ~]# grep tarena /etc/group

[root@1906 ~]# gpasswd -a jack tarena
[root@1906 ~]# grep tarena /etc/group

[root@1906 ~]# gpasswd -d dc tarena
[root@1906 ~]# grep tarena /etc/group

[root@1906 ~]# gpasswd -d natasha tarena
[root@1906 ~]# grep tarena /etc/group

####################################################
删除组
• 使用 groupdel 命令
– groupdel 组名


####################################################
案例1:配置用户和组账号
• 新建用户 alex,其用户ID为3456,密码是flectrag
[root@1906 ~]# useradd -u 3456 alex
[root@1906 ~]# echo flectrag  |  passwd --stdin alex
• 一个名为 adminuser 的组
[root@1906 ~]# groupadd adminuser
• 为 natasha 的用户其属于adminuser组,这个组是该用户的从属组
[root@1906 ~]# gpasswd -a natasha adminuser
[root@1906 ~]# id natasha
• 为 harry 的用户,其属于adminuser组,这个组是该用户的从属组
[root@1906 ~]# gpasswd -a harry adminuser
[root@1906 ~]# id harry
• 为 sarah的用户,其在系统中没有可交互的Shell
[root@1906 ~]# useradd -s /sbin/nologin sarah
• natasha 、harry、sarah 的密码都要设置为 flectrag
####################################################

tar备份与恢复

       1.整合分散的数据   2.减小空间占用

归档和压缩
• 归档的含义
– 将许多零散的文件整理为一个文件
– 文件总的大小基本不变

• 压缩的含义
– 按某种算法减小文件所占用空间的大小
– 恢复时按对应的逆向算法解压

常见的压缩格式及命令工具:
	.gz ---> gzip
	.bz2 ---> bzip2
	.xz ---> xz

• tar 集成备份工具
– -c:创建归档
– -x:释放归档
– -f:指定归档文件名称
– -z、-j、-J:调用 .gz、.bz2、.xz格式的工具进行处理
– -t:显示归档中的文件清单
– -C(大写):指定释放路径

制作tar包格式:
 tar  选项     /路径/压缩包的名字      /路径/被压缩的源数据 .....
]# tar -zcf  /opt/file.tar.gz    /home/   /etc/passwd 
]# ls /opt/
]# tar -jcf  /opt/abc.tar.bz2     /home/  /etc/passwd
]# ls /opt/
]# tar -Jcf  /opt/nsd.tar.xz      /home/  /etc/passwd
]# ls /opt/

解包格式:                                                                 
 tar  选项     /路径/压缩包的名字       释放的路径

]# tar -xf /opt/file.tar.gz   -C  /mnt/
]# ls /mnt/
]# ls /mnt/etc/
]# ls /mnt/home/

]# mkdir /test
]# tar -xf /opt/abc.tar.bz2   -C  /test
]# ls /test/

###################################################
案例2:创建一个备份包
使用 tar 工具完成以下备份任务:
– 创建一个名为 /root/backup.tar.bz2 的归档文件
– 其中包含 /usr/local 目录中的内容
– tar 归档必须使用 bzip2 进行压缩

]# tar -jcf /root/backup.tar.bz2   /usr/local/
]# ls /root/

]# tar -tf  /root/backup.tar.bz2    #查看tar包内容

##################################################
cron计划任务

cron任务概述
• 用途:按照设置的时间间隔为用户反复执行某一项固定的系统任务
• 软件包:cronie、crontabs
• 系统服务:crond

• 日志文件:/var/log/cron


管理计划任务策略
• 使用 crontab 命令
– 编辑:crontab -e [-u 用户名]
– 查看:crontab -l [-u 用户名]
– 清除:crontab -r [-u 用户名]


如何编写任务记录
• 配置格式可参考 /etc/crontab 文件
   分    时    日    月   周     任务命令行(绝对路径)
   *      *    *    *     *      #每分钟都执行

   30  23   *     *    *      #每天晚上11:30

   30  23   *     *    5      #每周的周五晚上11:30

   30  23   *     *    1,3,5      #每周的周五,周一,周三 晚上11:30
   30  23   *     *    1-5         #每周的周一至周五 晚上11:30
   1    */2   *   *      *          #每两个小时
  分   时    日   月      周
   1    8     1     *       2           #每周的周二或每月的一号

	*:匹配范围内任意时间
	,:分隔多个不连续的时间点
	-:指定连续时间范围
	/n:指定时间频率,每n ...


 利用root用户,每分钟记录当前系统时间,写入到/opt/time.txt
[root@1906 ~]# date    #显示系统时间

[root@1906 ~]# date >> /opt/time.txt
[root@1906 ~]# cat /opt/time.txt

[root@1906 ~]# crontab -e 
*  *  *  *  *    date >> /opt/time.txt

[root@1906 ~]# crontab -l -u root
*  *  *  *  *    date >> /opt/time.txt

################################################### 

date 5

教学环境介绍
• 每个学员机上有三台预先配置好的虚拟机
– server —— 作为练习用服务器
– desktop —— 作为练习用客户机
– classroom —— 提供网关/DNS/软件素材等资源


 优先虚拟机classroom开机

真机上使用rht-vmctl辅助工具
]# rht-vmctl reset classroom  //先重置资源服务器
]# rht-vmctl reset server
]# rht-vmctl reset desktop    //再重置答题虚拟机

###################################################
虚拟机server:  root用户密码为redhat       
    1.查看系统版本:RHEL7
    2.查看主机名:server0.example.com
    3.查看eth0网卡IP地址:172.25.0.11/24

虚拟机desktop:  root用户密码为redhat
    1.查看系统版本:RHEL7
    2.查看主机名:desktop0.example.com
    3.查看eth0网卡IP地址:172.25.0.10/24

###################################################
利用真机进行远程管理虚拟机

1.真机能够与虚拟机通信
[student@room9pc01 ~]$ ping 172.25.0.11

[student@room9pc01 ~]$ ping 172.25.0.10

2.远程管理命令: ssh  用户名@对方的IP地址
[student@room9pc01 ~]$ ssh  root@172.25.0.11

[student@room9pc01 ~]$ ssh  root@172.25.0.10
   ctrl + shift  + t :在一个窗口中,新开一个终端

    -X(大写)：远程管理时，开启对方的图形程序

[root@server0 ~]# exit
[student@room9pc01 ~]$ ssh -X root@172.25.0.11

[root@server0 ~]#　firefox  #火狐浏览器
[root@server0 ~]#　firewall-config  #防火墙工具


常见提示:dconf桌面服务报错,与远程管理无关
(process:30405): dconf-WARNING **: failed to commit changes to dconf: 无法连接：拒绝连接


补充:为真机设置永久别名    配置文件: ~/.bashrc
配置文件: ~/.bashrc  #每开一个新的终端生效      

[student@room9pc01 ~]$ vim  /home/student/.bashrc 
# .bashrc
alias  gos='ssh  -X  root@172.25.0.11'
alias  god='ssh  -X  root@172.25.0.10'

真机:开启一个新的终端验证
[student@room9pc01 ~]$ gos
[student@room9pc01 ~]$ god

####################################################
权限和归属

基本权限

基本权限的类别
• 访问方式(权限)
– 读取:允许查看内容-read   r 
– 写入:允许修改内容-write    w
– 可执行:允许运行和切换-execute  x

  对文本文件:
       r: cat  less  head  tail
       w: vim  >  >>
       x: Shell脚本

• 权限适用对象(归属)
– 所有者:拥有此文件/目录的用户-user  u
– 所属组:拥有此文件/目录的组-group  g
– 其他用户:除所有者、所属组以外的用户-other  o

       lisi   lisi组     a.txt


查看权限
• 使用 ls -l 命令
– ls -ld 文件或目录...

 以 d 开头为目录
 以 - 开头为文本文件
 以 l 开头为快捷方式

[root@server0 ~]# ls -l /etc/passwd

[root@server0 ~]# ls -ld /etc/

[root@server0 ~]# ls -l /etc/shadow

[root@server0 ~]# ls -ld /tmp

[root@server0 ~]# ls -ld /home/student

###################################################
• 使用 chmod 命令
– chmod [-R] 归属关系+-=权限类别 文档...
   [-R]:递归设置权限

[root@server0 ~]# mkdir /nsd01    
[root@server0 ~]# ls -ld /nsd01
[root@server0 ~]# chmod u-w /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod o=--- /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod g+w /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod ugo=rwx /nsd01
[root@server0 ~]# ls -ld /nsd01
[root@server0 ~]# chmod u=rwx,g=rx,o=rx /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# mkdir -p /opt/aa/bb/cc
[root@server0 ~]# ls -ld /opt/aa
[root@server0 ~]# ls -ld /opt/aa/bb
[root@server0 ~]# ls -ld /opt/aa/bb/cc/

[root@server0 ~]# chmod -R o=--- /opt/aa  #递归设置

[root@server0 ~]# ls -ld /opt/aa
[root@server0 ~]# ls -ld /opt/aa/bb
[root@server0 ~]# ls -ld /opt/aa/bb/cc/
################################################
Linux判定一个用户拥有的权限         匹配及停止
1.判断用户的身份                       所有者>所属组>其他人
2.查看相应权限位的权限

 1.严老师可以进入              1.所有人不可以进入 
 2.所有人不可以进入           2. 严老师可以进入


 Permission denied :权限不足

目录的r权限:能够 ls 浏览此目录内容
目录的w权限:能够执行rm/mv/cp/mkdir/touch更改目录内容的操作
目录的x权限:能够 cd 切换到此目录

以root用户新建/nsddir目录，在此目录下新建readme.txt文件
并进一步完成下列操作
 1）使用户lisi能够在此目录下创建子目录     su  -  lisi
     chmod o+w  /nsddir/
 2）使用户lisi不能够在此目录下创建子目录            
     chmod o-w  /nsddir/
 3）使用户lisi能够修改readme.txt文件内容
     chmod o+w  /nsddir/readme.txt
 4）调整此目录的权限，使所有用户都不能cd进入此目录
     chmod u-x,g-x,o-x  /nsddir/
 5）为此目录及其下所有文档设置权限 rwxr-x---
     chmod -R  u=rwx,g=rx,o=---  /nsddir/
　　　-R：递归设置权限，目录下及目录下所有

#################################################
设置文档归属
• 使用 chown 命令
– chown [-R] 属主 文档...
– chown [-R] :属组 文档...
– chown [-R] 属主:属组 文档...
[root@server0 ~]# mkdir /nsd03
[root@server0 ~]# ls -ld /nsd03
[root@server0 ~]# groupadd tedu
[root@server0 ~]# chown lisi:tedu /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# chown root /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# chown :lisi /nsd03
[root@server0 ~]# ls -ld /nsd03
################################################
利用root用户新建/nsd06目录，并进一步完成下列操作
1）将属主设为gelin01，属组设为tarena组              
[root@server0 /]# useradd gelin01
[root@server0 /]# useradd gelin02
[root@server0 /]# groupadd tarena
[root@server0 /]# chown gelin01:tarena  /nsd06
2）使用户gelin01对此目录具有rwx权限
      除属主与属组之外的人，对此目录无任何权限
[root@server0 /]# chmod o=--- /nsd06
3）使用户gelin02能进入、查看此目录内容
[root@server0 /]# gpasswd -a  gelin02  tarena
4）将gelin01加入tarena组, 将nsd06目录的权限设为rw-r-x---
      再测试gelin01用户能否进入此目录
[root@server0 /]# gpasswd -a  gelin01  tarena
[root@server0 /]# chmod u=rw,g=rx /nsd06

#################################################
设置权限,让lisi用户可以读取/etc/shadow文件内容,有几种办法?
   1.利用其他人:
        chmod  o+r  /etc/shadow      
   2.利用所属组:
        chown  :lisi /etc/shadow
        chmod  g+r  /etc/shadow
   3.利用所有者:
        chown  lisi  /etc/shadow
        chmod  u+r  /etc/shadow
   4.利用ACL策略
        setfacl  -m u:lisi:r  /etc/shadow

#################################################
附加权限(特殊权限)

Set GID
• 附加在属组的 x 位上
– 属组的权限标识会变为 s
– 适用于目录,Set GID可以使目录下新增的文档自动设
置与父目录相同的属组
– 自动继承父目录所属组身份

[root@server0 ~]# mkdir /nsd08
[root@server0 ~]# chown :tedu /nsd08
[root@server0 ~]# ls -ld /nsd08

[root@server0 ~]# mkdir /nsd08/abc01
[root@server0 ~]# ls -ld /nsd08/abc01

[root@server0 ~]# chmod g+s /nsd08/   #设置Set GID
[root@server0 ~]# ls -ld /nsd08/

[root@server0 ~]# mkdir /nsd08/abc02
[root@server0 ~]# ls -ld /nsd08/abc02

[root@server0 ~]# ls -ld /nsd08/abc01


 财务: caiwu组  
     /nsd09/20190703.txt
     /nsd09/20190704.txt
     /nsd09/20190705.txt
     /nsd09/20190706.txt
     /nsd09/20190707.txt

[root@server0 ~]# chown  :caiwu  /nsd09
[root@server0 ~]# chmod  g+s  /nsd09

#################################################
Set UID
• 附加在属主的 x 位上
– 属主的权限标识会变为 s
– 适用于可执行文件,Set UID可以让使用者具有文件属主的身份及部分权限

[root@server0 ~]# cp /usr/bin/mkdir /usr/bin/hahadir

[root@server0 ~]# chmod u+s /usr/bin/hahadir 
[root@server0 ~]# ls -l /usr/bin/hahadir
[root@server0 ~]# ls -l /usr/bin/mkdir 

[root@server0 ~]# su - lisi
[lisi@server0 ~]$ /usr/bin/mkdir  test
[lisi@server0 ~]$ ls -l
[lisi@server0 ~]$ /usr/bin/hahadir nsd
[lisi@server0 ~]$ ls -l
[lisi@server0 ~]$ exit

################################################
Sticky Bit
• 附加在其他人的 x 位上                    
– 其他人的权限标识会变为 t
– 适用于开放 w 权限的目录,可以阻止用户滥用 w 写入
权限(禁止操作别人的文档)

[root@server0 ~]# mkdir /public
[root@server0 ~]# chmod ugo=rwx /public
[root@server0 ~]# ls -ld /public

[root@server0 ~]# chmod o+t /public
[root@server0 ~]# ls -ld /public

#################################################
acl访问控制列表

acl策略的作用
• 文档归属的局限性
– 任何人只属于三种角色:属主、属组、其他人
– 无法实现更精细的控制

• acl访问策略
– 能够对个别用户、个别组设置独立的权限
– 大多数挂载的EXT3/4、XFS文件系统默认已支持


[root@server0 ~]# mkdir /nsd11
[root@server0 ~]# chmod o=--- /nsd11
[root@server0 ~]# ls -ld /nsd11

[root@server0 ~]# su - lisi
[lisi@server0 ~]$ cd /nsd11
-bash: cd: /nsd11: Permission denied
[lisi@server0 ~]$ exit

[root@server0 ~]# setfacl -m u:lisi:rx /nsd11
[root@server0 ~]# getfacl /nsd11   #专用于查看ACL策略
[root@server0 ~]# su - lisi
[lisi@server0 ~]$ cd /nsd11
[lisi@server0 nsd11]$ pwd
[lisi@server0 nsd11]$ exit

###############################################
使用 getfacl、setfacl 命令
– getfacl 文档...
– setfacl [-R] -m u:用户名:权限类别 文档...
– setfacl [-R] -m g:组名:权限类别 文档...
– setfacl [-R] -x u:用户名     文档...      #删除指定ACL

– setfacl [-R] -b 文档...       #清除所有ACL


]# mkdir /nsd14
]# setfacl -m u:lisi:rwx /nsd14
]# setfacl -m u:dc:rx /nsd14
]# setfacl -m u:genlin01:rwx  /nsd14
]# setfacl -m u:genlin02:---  /nsd14  #设置无任何权限
]# getfacl /nsd14

]# setfacl -x u:genlin02 /nsd14   #删除指定ACL策略
]# getfacl /nsd14

]# setfacl -x u:genlin01 /nsd14  #删除指定ACL策略
]# getfacl /nsd14

]# setfacl -b  /nsd14         #清除所有的ACL策略
]# getfacl /nsd14

################################################## 

 
##################################################

date 6


软件包管理                                         

1.从虚拟机classroom上获得软件包

虚拟机classroom已经搭建Web服务,共享光盘RHEL7.0所有内容

Web服务:提供一个页面内容的服务

真机访问测试: firefox classroom.example.com

 classroom.example.com/content/rhel7.0/x86_64/dvd/


下载软件包
• 使用wget下载工具
– wget 软件包的URL网址
– wget 软件包的URL网址  -O(大写) /目录路径/新文件名

真机的浏览器:  Ctrl + f 当前页面查找 vsftpd
http://classroom.example.com/content/rhel7.0/x86_64/dvd/Packages/


[root@server0 /]# cd /root
[root@server0 /]# wget  http://classroom.example.com/content/rhel7.0/x86_64/dvd/Packages/vsftpd-3.0.2-9.el7.x86_64.rpm

[root@server0 /]#  ls


• RPM Package Manager,RPM包管理器
– rpm -q 软件名...   #查询软件
– rpm -ivh 软件名-版本信息.rpm...    #安装软件
– rpm -e 软件名...  # 卸载软件
– rpm -ql 软件名    # 查询软件所有文件
– rpm -qc 软件名   # 查询软件配置文件

[root@server0 ~]# rpm -q vsftpd    #查询软件是否安装
未安装软件包 vsftpd 
[root@server0 ~]# rpm -q firefox
firefox-24.5.0-1.el7.x86_64
]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 

[root@server0 ~]# rpm -q vsftpd
[root@server0 ~]# rpm -e vsftpd    #卸载软件
[root@server0 ~]# rpm -q vsftpd

]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 
]# rpm -ql vsftpd  #查询已安装的软件,安装了那些内容






#################################################
了解内容:导入红帽签名信息
[root@server0 ~]# wget http://classroom.example.com/content/rhel7.0/x86_64/dvd/RPM-GPG-KEY-redhat-release

[root@server0 ~]# rpm --import /root/RPM-GPG-KEY-redhat-release 
[root@server0 ~]# rpm -e vsftpd
[root@server0 ~]# rpm -q vsftpd
未安装软件包 vsftpd 
[root@server0 ~]# rpm -i /root/vsftpd-3.0.2-9.el7.x86_64.rpm 

##############################################
常见的提示:
]# rpm -ivh /root/bind-chroot-9.9.4-14.el7.x86_64.rpm 

错误：依赖检测失败：
	bind = 32:9.9.4-14.el7 被 bind-chroot-32:9.9.4-14.el7.x86_64 需要

##############################################
Yum配置及使用,自动解决依赖关系安装软件   

服务:自动解决依赖关系安装软件

服务端:  1.众多的软件包  2.仓库数据文件  3.构建Web服务或FTP服务
                       光盘内容中
             总结:构建Web服务或FTP服务,共享光盘所有内容

    虚拟机classroom构建Web服务,共享光盘所有内容

客户端: 虚拟机server 书写一个配置文件,指定服务端位置
      – /etc/yum.repos.d/*.repo
           错误的文件会影响正确配置文件
[root@server0 ~]# rm -rf /etc/yum.repos.d/*
[root@server0 ~]# vim /etc/yum.repos.d/dc.repo
[haha]                     #仓库标识,随意写不能有特殊字符
name=rhel7.0 xixi hehe     #仓库描述信息
baseurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd/                #指定服务端位置
enabled=1                  #是否启用本文件配置
gpgcheck=0                 #是否检测红帽签名信息
[root@server0 ~]# yum repolist        #显示仓库信息
[root@server0 ~]# yum -y install sssd
[root@server0 ~]# yum -y install httpd
[root@server0 ~]# yum -y install gcc
[root@server0 ~]# yum -y install mariadb-server
[root@server0 ~]# yum -y install xeyes
[root@server0 ~]# xeyes
      yum 软件仓库搭建另外一种方法:
yum-config-manager --add http://classroom.example.com/content/rhel7.0/x86_64/dvd/
vim /etc/yum.conf 
    gpgcheck=0
  :wq
[root@server0 ~]# ls /etc/yum.repos.d/
classroom.example.com_content_rhel7.0_x86_64_dvd_.repo   



#################################################
yum的使用
[root@server0 ~]# yum info 软件名

[root@server0 ~]# yum info vsftpd   #查询软件介绍信息
[root@server0 ~]# yum info httpd
[root@server0 ~]# yum info firefox

[root@server0 ~]# yum remove 软件名
[root@server0 ~]# yum remove httpd   #卸载软件
[root@server0 ~]# yum remove gcc
清空Yum的缓存
[root@server0 ~]# yum clean all
已加载插件：langpacks
正在清理软件源： haha
Cleaning up everything
[root@server0 ~]# yum repolist
]#yum list | grep httpd    //列出软件httpd
]# yum provides  pxelinux.0   //查找产生 pxelinux.0 的软件   

################################################
案例2:升级Linux内核
1.下载新的内核软件包
[root@server0 ~]# wget  http://classroom.example.com/content/rhel7.0/x86_64/errata/Packages/kernel-3.10.0-123.1.2.el7.x86_64.rpm

[root@server0 ~]# ls
[root@server0 ~]# uname -r
3.10.0-123.el7.x86_64

[root@server0 ~]# rpm -ivh /root/kernel-3.10.0-123.1.2.el7.x86_64.rpm 

[root@server0 ~]# reboot 
################################################

分区规划及使用

  扇区默认大小  512字节

  容量单位:  EB
  1EB=1024*1024TB

一块硬盘的“艺术”之旅
• 识别硬盘 => 分区规划 => 格式化 => 挂载使用
   毛坯楼层 => 打隔断 => 装修 =>入驻
                                                                
一 识别硬盘
  sd:SCSI设备  hd:IDE设备    vd:虚拟设备
 
[root@server0 ~]# lsblk      #查看当前系统所有的硬盘信息
NAME    SIZE  TYPE MOUNTPOINT
vda      10G   disk 
└─vda1   10G  part /
vdb      10G   disk 


二   分区规划 
• MBR/msdos 分区模式
– 1~4个主分区,或者  3个主分区+1个扩展分区(n个逻辑分区)
– 最大支持容量为 2.2TB 的磁盘
– 扩展分区不能格式化
 /dev/sda1:第一块SCSI硬盘,第一个主分区        
 /dev/sda5:第一块SCSI硬盘,第1个逻辑分区

• 修改硬盘的分区表,分出两个主分区,大小都为2G
[root@server0 ~]# fdisk /dev/vdb 
  n 创建新的分区--->回车--->回车-->回车--->在last结束时 +2G
  p 查看分区表
  n 创建新的分区--->回车---->回车--->回车--->在last结束时 +2G
  d 删除分区
  w 保存并退出 
[root@server0 ~]# lsblk  
[root@server0 ~]# ls /dev/vdb[1-2]

三 格式化 :赋予空间文件系统的过程

  文件系统:存储数据的规则
 
  Windows: NTFS   FAT

  Linux: ext4(RHEL6)  xfs(RHEL7)

[root@server0 ~]# mkfs.ext4 /dev/vdb1  #格式化为ext4  
[root@server0 ~]# blkid /dev/vdb1   #查看文件系统类型

[root@server0 ~]# mkfs.xfs /dev/vdb2 #格式化为xfs
[root@server0 ~]# blkid /dev/vdb2   #查看文件系统类型

四 挂载使用
[root@server0 ~]# mkdir /mypart1
[root@server0 ~]# mount /dev/vdb1 /mypart1
[root@server0 ~]# df -h  #正在挂载的设备使用情况

[root@server0 ~]# mkdir /mypart2
[root@server0 ~]# mount /dev/vdb2 /mypart2
[root@server0 ~]# df -h

五 开机自动挂载 /etc/fstab
     设备路径      挂载点      类型     参数       备份标记     检测顺序

 vim命令模式    按o键进入插入模式       
[root@server0 ~]# vim /etc/fstab 
 设备路径      挂载点      类型     参数       备份标记     检测顺序
/dev/vdb1  /mypart1  ext4  defaults  0  0
/dev/vdb2  /mypart2  xfs   defaults  0  0

[root@server0 ~]# umount /mypart1
[root@server0 ~]# umount /mypart2
[root@server0 ~]# df -h
[root@server0 ~]# mount -a
   检测/etc/fstab开机自动挂载配置文件,格式是否正确
   检测/etc/fstab中,书写完成,但当前没有挂载的设备,进行挂载
[root@server0 ~]# df -h

#################################################
综合分区:
最终实现3个主分区均为2G 划分扩展分区,划分2个逻辑分区均为1G
[root@server0 ~]# fdisk /dev/vdb
   p 查看分区表
   n 创建主分区---->回车---->回车---->回车---->在last结束时 +2G
   p 查看分区表
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车   将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+1G
   n 创建逻辑分区----->起始回车------>结束+1G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# partprobe   #刷新分区表
[root@server0 ~]# lsblk 

##################################################
综合分区
图形添加一块100G的硬盘
分区要求:最终可以使用 7 个分区,分别都是10G
[root@server0 ~]# fdisk /dev/vdc
   p 查看分区表
   n 创建主分区---->回车---->回车---->回车---->在last结束时 +10G
         连续划分3个主分区
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车   将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+10G
   n 创建逻辑分区----->起始回车------>结束+10G
   n 创建逻辑分区----->起始回车------>结束+10G
   n 创建逻辑分区----->起始回车------>结束+10G
   p 查看分区表
   w 保存并退出

#############################################
总结:
1.识别硬盘   lsblk
2.分区规划   fdisk
3.分区表刷新  partprobe
4.格式化    mkfs.ext4   mkfs.xfs   blkid
5.挂载使用   mount     df  -h
6.开机自动挂载  /etc/fstab  mount   -a

#############################################
使用LDAP认证,实现网络用户认证,达到用户的集中管理
  
     网络用户:用户信息会放在网络中LDAP服务器
     本地用户:用户信息会放在/etc/passwd

正确:只要在/etc/passwd文件内容有的用户信息,本地都能识别
错误:本地都能识别的用户,信息都在/etc/passwd

LDAP服务器:虚拟机classroom

客户端:虚拟机server
1.安装sssd软件,与LDAP服务器沟通
[root@server0 /]# yum -y install sssd
[root@server0 /]# rpm -q sssd

2.安装authconfig-gtk图形的工具,进行配置客户端sssd软件
[root@server0 /]# yum -y install authconfig-gtk
[root@server0 /]# authconfig-gtk

完全合格的主机名  www.baidu.com　　　www.qq.com    
               classroom.example.com

     选择LDAP
      dc=example,dc=com             #指定服务端域名
      classroom.example.com         #指定服务端主机名
     勾选TLS加密
      使用证书加密:
     http://classroom.example.com/pub/example-ca.crt

     选择LDAP密码 

3.重起服务
[root@server0 ~]# systemctl  restart  sssd   #重起服务
[root@server0 ~]# systemctl  enable  sssd    #设置开机自启动
[root@server0 ~]# grep ldapuser0 /etc/passwd
[root@server0 ~]# id ldapuser0     #验证LDAP用户信息
          
###################################################      
家目录漫游

    在LDAP服务器搭建共享,共享所有普通用户的家目录

  LDAP服务器:虚拟机classroom

  虚拟机classroom已经完成共享所有操作

 虚拟机server:访问共享数据
[root@server0 ~]# mkdir /haha
[root@server0 ~]# ls /haha
[root@server0 ~]# showmount -e classroom.example.com
Export list for classroom.example.com:
/home/guests 172.25.0.0/255.255.0.0

[root@server0 ~]# mount classroom.example.com:/home/guests  /haha
[root@server0 ~]# df -h

[root@server0 ~]# mkdir /home/guests
[root@server0 ~]# mount classroom.example.com:/home/guests/   /home/guests
[root@server0 ~]# ls /home/guests

[root@server0 ~]# su - ldapuser0
上一次登录：三 4月 10 19:21:04 CST 2019pts/0 上
[ldapuser0@server0 ~]$ 

################################################


###################################################

date 7


综合分区:利用图形新添加一块80G硬盘
   最终有3个主分区，分别为10G、10G、10G           
   创建扩展分区 --->  两个逻辑分区，分别为10G、10G
[root@server0 ~]# fdisk  /dev/vdc
   p 查看分区表
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +10G
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +10G
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +10G
   p 查看分区表
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车   将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+10G
   n 创建逻辑分区----->起始回车------>结束+10G
   p 查看分区表
   w 保存并退出
#####################################################
LVM逻辑卷管理

LVM工作方式
• 在“分区 --> 格式化”中间增加的一个逻辑层
– 零散空闲存储 ---- 整合的虚拟磁盘 ---- 虚拟的分区

将众多的物理卷(PV),组合成卷组(VG),在从卷组中划分出逻辑卷(LV)
    砖--------->房子------->房间

  物理卷
  Physical Volume
  
  卷组
  Volume Group

  逻辑卷
  Logical Volume

#############################################

LVM管理工具集
功能 		    物理卷管理		卷组管理 		逻辑卷管理
Scan扫描 	    pvscan 		vgscan 		lvscan
Create创建   pvcreate 		vgcreate 	lvcreate
Display显示 pvdisplay 		vgdisplay 	lvdisplay
Remove删除   pvremove 		vgremove 	lvremove
Extend扩展    / 			vgextend 	lvextend

###################################################
一  制作逻辑卷    successfully 成功     

1.创建卷组
   格式:vgcreate   卷组名     设备路径.......
[root@server0 ~]# vgcreate systemvg  /dev/vdb /dev/vdc1
[root@server0 ~]# vgs   #查看卷组基本信息
[root@server0 ~]# pvs   #查看物理卷基本信息

2.创建逻辑卷
格式:lvcreate -n 逻辑卷名   -L 大小G   基于的卷组名
[root@server0 ~]# lvcreate -n vo -L 16G systemvg 
[root@server0 ~]# vgs    #查看卷组基本信息
[root@server0 ~]# lvs   #查看逻辑卷基本信息

3.逻辑卷的使用
[root@server0 ~]# ls /dev/systemvg/vo    #逻辑卷设备文件
[root@server0 ~]# ls -l /dev/systemvg/vo

[root@server0 ~]# mkfs.xfs /dev/systemvg/vo #格式化
[root@server0 ~]# blkid  /dev/systemvg/vo #查看设备文件系统
[root@server0 ~]# vim /etc/fstab 
/dev/systemvg/vo  /mylv   xfs 	defaults  0  0

[root@server0 ~]# mkdir  /mylv
[root@server0 ~]# mount  -a  #检测/etc/fstab是否书写正确
[root@server0 ~]# df  -h     #查看正在挂载的设备

##################################################
二  逻辑卷的扩大
1.卷组有足够的剩余空间
  1)直接扩展逻辑卷的空间
[root@server0 ~]# vgs
[root@server0 ~]# lvs
[root@server0 ~]# lvextend -L 18G /dev/systemvg/vo 
[root@server0 ~]# lvs
  2)文件系统的扩大(刷新文件系统)
     resize2fs:专用于ext4文件系统的刷新
     xfs_growfs:专用于xfs文件系统的刷新

[root@server0 ~]# df -h
[root@server0 ~]# xfs_growfs /dev/systemvg/vo 
[root@server0 ~]# df -h

2.卷组没有足够的剩余空间                       
  1)首先扩展卷组空间
  [root@server0 ~]# vgextend systemvg /dev/vdc2
   Physical volume "/dev/vdc2" successfully created
   Volume group "systemvg" successfully extended
  [root@server0 ~]# vgs
  2)直接扩展逻辑卷的空间
  [root@server0 ~]# lvs
  [root@server0 ~]# lvextend -L 25G /dev/systemvg/vo 
  [root@server0 ~]# lvs
  3)文件系统的扩大(刷新文件系统)
  [root@server0 ~]# df -h
  [root@server0 ~]# xfs_growfs /dev/systemvg/vo 
  [root@server0 ~]# df -h

##################################################
了解:逻辑卷也可以变小
     ext4支持变小   xfs不支持变小


卷组划分空间单位:PE  默认大小为4M

查看卷组详细信息:
[root@server0 ~]# vgdisplay systemvg 
  PE Size               4.00 MiB

请划分一个逻辑卷大小为250M,名字为lvredhat
]# vgchange  -s  1M  systemvg   #修改PE的大小
]# vgdisplay  systemvg   #查看卷组详细信息
]# lvcreate  -n  lvredhat  -L  250M  systemvg 

请划分一个逻辑卷大小为987个PE组成的逻辑卷,名字为lvtest
]# lvcreate -l 987 -n lvtest  systemvg
]# lvs

]# lvcreate -l 50 -n lvtest01  systemvg
]# lvs
#################################################
删除逻辑卷: 首先删除逻辑卷,然后在删除卷组,最后删除物理卷

    删除卷组前提:基于此卷组创建的逻辑卷全部删除

[root@server0 ~]# lvremove /dev/systemvg/vo 
  Logical volume systemvg/vo contains a filesystem in use.
[root@server0 ~]# umount /mylv/
[root@server0 ~]# lvremove /dev/systemvg/vo 
Do you really want to remove active logical volume vo? [y/n]: y
  Logical volume "vo" successfully removed
[root@server0 ~]# lvs

###################################################
find高级使用,递归式查找

– find [目录] [条件1] [-a|-o] [条件2] ...

– 常用条件表示:
	-type 类型(f文本文件、d目录、l快捷方式)
	-name "文档名称"
	-size +|-文件大小(k、M、G)
	-user 用户名
	-mtime 根据文件修改时间
################################################
	-type 类型(f文本文件、d目录、l快捷方式)

[root@server0 ~]# find /boot/ -type d   #查找是目录
[root@server0 ~]# find /boot/ -type l   #查找是快捷方式
/boot/grub/menu.lst
[root@server0 ~]# ls /boot/grub/menu.lst 
/boot/grub/menu.lst
[root@server0 ~]# ls -l /boot/grub/menu.lst

[root@server0 ~]# find /boot/ -type f  #查找是文件

[root@server0 ~]# find /root -type d
[root@server0 ~]# find /root -type f
[root@server0 ~]# find /root -type l

	-name  "文档名称"
[root@server0 ~]# find /etc/ -name "passwd" 

[root@server0 ~]# find /etc/  -name "*tab"
[root@server0 ~]# find /etc/  -name "*tab*"

[root@server0 ~]# find /etc/  -name "*.conf"


]# mkdir /root/nsd1907
]# touch /root/nsd01.txt
]# touch /root/nsd02.txt
]# ls /root/
]# find /root/ -name "nsd*"
]# find /root/ -name "nsd*"  -type f  #nsd开头,并且是文件
]# find /root/ -name "nsd*"  -type d  #nsd开头,并且是目录

###################################################
	-size +或- 文件大小(k、M、G)
[root@server0 ~]# find /boot/ -size +300k
[root@server0 ~]# find /boot/ -size +10M
[root@server0 ~]# find /boot/ -size -10M

	-user 用户名       #按照所有者进行查找
[root@server0 ~]# find /home/  -user student
[root@server0 ~]# find /    -user student  #查找整个系统

    /proc:不占用硬盘空间，占用内存的空间

###################################################
	-mtime 根据文件修改时间,都是过去时间
                     +10 ：10天之前                               
                     -10 ：最近10天之内

[root@server0 ~]# find /root/  -mtime +1000
[root@server0 ~]# find /root/  -mtime -5

[root@server0 ~]# date   #查看当前的系统时间
  
  三个月之前的数据：+90


###################################################
处理find查找的数据                                
 -exec:额外操作的开始
    \;   ：额外操作的结束
   {} :find每一个查询结果

]# find /etc/  -name "*tab" 
]# find /etc/  -name "*tab"   -exec cp -r  {}  /opt \;
]# ls /opt/

]# find /boot/ -size +10M
]# find /boot/ -size +10M   -exec cp -r  {}  /opt/ \;
]# ls /opt/

####################################################
案例4:查找并处理文件
• 使用find命令完成以下任务
– 找出所有用户 student 拥有的文件
– 把它们拷贝到 /root/findfiles/ 文件夹中

]# mkdir /root/findfiles
]# find /  -user student  -type  f  #所有者student且为文件

]# find /  -user student -type  f  -exec cp {}  /root/findfiles/   \;

]# ls -A /root/findfiles/

##################################################
grep 在文本文件内容中，过滤指定字符串

[root@server0 ~]# grep root /etc/passwd
[root@server0 ~]# grep ^root  /etc/passwd  #以root开头
[root@server0 ~]# grep root$  /etc/passwd  #以root结尾
[root@server0 ~]# grep bash$ /etc/passwd   #以bash结尾

    -i：忽略大小写
    -v：取反查找
[root@server0 ~]# grep ROOT /etc/passwd
[root@server0 ~]# grep -i ROOT /etc/passwd
[root@server0 ~]# grep -v root /etc/passwd

       ^$:匹配空行
[root@server0 ~]# cat     /etc/default/useradd 
[root@server0 ~]# grep ^$  /etc/default/useradd 

[root@server0 ~]# grep -v ^$  /etc/default/useradd 

      在Linux中大多数配置文件中以#开头的行为注释行

显示/etc/login.defs配置文件有效信息（去掉以#开头的注释行和空行）
]# grep -v ^#  /etc/login.defs 

]# grep -v ^#  /etc/login.defs  |  grep -v ^$ 

]# grep -v ^#  /etc/login.defs |  grep -v ^$   >  /opt/l.txt

]# cat /opt/l.txt

####################################################

NTP网络时间协议
• Network Time Protocol
– NTP服务器为客户机提供标准时间
– NTP客户机需要与NTP服务器保持沟通


NTP服务器：虚拟机classroom
NTP客户机：虚拟机server
1.安装chrony软件，沟通时间服务器
[root@server0 ~]# rpm -q chrony
chrony-1.29.1-1.el7.x86_64

2.配置文件:/etc/chrony.conf
[root@server0 ~]# vim  /etc/chrony.conf
 #server 0.rhel.pool.ntp.org iburst   #开头加#变成注释
 #server 1.rhel.pool.ntp.org iburst   #开头加#变成注释
 #server 2.rhel.pool.ntp.org iburst   #开头加#变成注释
 server classroom.example.com iburst  #指定服务端位置

3.重起程序（重起服务）
   程序名(服务名)：chronyd
   daemon
     英 [ˈdiːmən] 美 [ˈdiːmən]
     (古希腊神话中的)半神半人精灵(守护神)
]# systemctl restart chronyd     #重起
]# systemctl enable chronyd      #开机自启动

4.测试
]# date  -s  "年-月-日   时：分：秒"
]# date 
]# date -s "2008-10-1  11:11:11"
]# date

]# systemctl restart chronyd     #重起程序
]# date
]# date
]# date
####################################################

 
         ENGINEER

date 1

Shell脚本基础

   脚本:一个可以执行的文件,运行可以实现某种功能

   创建用户dc  =  useradd  dc

绿色:可执行程序
案例1:编写hello.sh脚本
[root@server0 ~]# vim /root/hello.sh
echo Hello World

[root@server0 ~]# chmod +x /root/hello.sh
[root@server0 ~]# /root/hello.sh  #绝对路径运行脚本


##################################################
规范Shell脚本的一般组成
• #! 环境声明,以下代码由谁进行翻译执行
• # 注释文本
• 可执行代码

##################################################
1)输出当前红帽系统的版本信息                        
2)输出当前使用的内核版本
3)输出当前系统的主机名
[root@server0 ~]# vim  /root/hello.sh
  #!/bin/bash
  echo  Hello  World
  cat  /etc/redhat-release
  uname  -r
  hostname
  ifconfig  |  head -2

[root@server0 ~]# /root/hello.sh
 
#################################################
重定向输出
      > :只收集前面命令的正确输出
     2>:只收集前面命令的错误输出
     &>:正确与错误都收集
     >&2:将命令的输出变成错误输出
[root@server0 ~]# echo 123 > /opt/1.txt
[root@server0 ~]# cat /opt/1.txt
[root@server0 ~]# cat /opt/1.txt  /a

[root@server0 ~]# cat /opt/1.txt /a > /opt/2.txt 
[root@server0 ~]# cat /opt/2.txt 

[root@server0 ~]# cat /opt/1.txt /a 2> /opt/2.txt
[root@server0 ~]# cat /opt/2.txt 
[root@server0 ~]# cat /opt/1.txt /a &> /opt/2.txt
[root@server0 ~]# cat /opt/2.txt 
###############################################

    单引号 ' ' : 取消所有特殊字符的意义,原样输出

[root@server0 ~]# echo '* | & ^ % ***'
[root@server0 ~]# echo ', !'
  
    反撇号 ` `或$( ) :将命令的输出,直接参与下一次命令的运行
[root@server0 ~]# date +%F
2019-07-06
[root@server0 ~]# cd /opt/
[root@server0 opt]# mkdir  nsd-`date +%F`
[root@server0 opt]# mkdir  abc-$(date +%F)
[root@server0 opt]# mkdir  $(hostname)-$(date +%F)
##############################################
案例:创建用户并且设置密码的脚本
  黑洞设备:/dev/null
[root@server0 /]# vim /root/user.sh
#!/bin/bash
useradd nsd04 &> /dev/null
echo '用户nsd04创建成功'
echo 123  |  passwd --stdin nsd04 &> /dev/null
echo '用户nsd04密码设置成功'

[root@server0 /]# chmod +x /root/user.sh
[root@server0 /]# /root/user.sh

 为了增强脚本适应环境的变化以及需求的变化所有使用变量

 变量:会变化的量   以不变的名称,存储可以变化的值
      类似与容器
  格式:   变量名=存储的值
[root@server0 /]# vim  /root/user.sh     
 #!/bin/bash
 a=tc
 useradd  $a  &> /dev/null
 echo  用户$a创建成功
 echo  123  |  passwd --stdin  $a  &> /dev/null
 echo  用户$a密码设置成功

 交互式在命令行传递参数给脚本的代码

  read -p  '屏幕提示信息'
           1.直接产生交互
           2.记录用户在键盘上所有输入
           3.将记录的内容交由变量储存
[root@server0 /]# vim /root/user.sh
 #!/bin/bash
 read  -p  '请输入您要创建的用户名:'    a
 useradd $a  &> /dev/null
 echo 用户$a创建成功
 echo 123  |  passwd --stdin $a &> /dev/null
 echo 用户$a密码设置成功
#################################################
vim错误解决:产生交换文件(缓存文件)

]# vim /opt/4.txt 

]# rm -rf /opt/.4.txt.swp  #删除交换文件 

###############################################
定义/赋值变量
• 设置变量时的注意事项
– 等号两边不要有空格
– 变量名只能由字母/数字/下划线组成,区分大小写
– 变量名不能以数字开头,不要使用关键字和特殊字符
– 若指定的变量名已存在,相当于为此变量重新赋值

• 基本格式
– 引用变量值:$变量名
– 查看变量值:echo $变量名、echo ${变量名}
[root@server0 ~]# a=rhel
[root@server0 ~]# echo $a
rhel
[root@server0 ~]# echo ${a}
rhel
[root@server0 ~]# echo $a7

[root@server0 ~]# echo ${a}7
rhel7
[root@server0 ~]# b=7
[root@server0 ~]# echo ${a}${b}
                    # unset a
                    # unset b    删除变量
################################################
环境变量 :变量名大写   由系统定义并且赋值完成

   USER=当前登录的用户身份
[root@server0 ~]# echo $USER
root
[root@server0 ~]# su - student
[student@server0 ~]$ echo $USER
student
[student@server0 ~]$ exit
logout
[root@server0 ~]# su - dc
[dc@server0 ~]$ echo $USER
dc
[dc@server0 ~]$ exit
logout
[root@server0 ~]#
###############################################
位置变量:由系统定义并且赋值完成

 非交互式 在命令行传递参数给脚本的代码

[root@server0 ~]# vim /root/1.sh
#!/bin/bash
echo $1
echo $2
echo $3
[root@server0 ~]# /root/1.sh  haha  tom  dcc

[root@server0 ~]# vim /root/user.sh 
#!/bin/bash
useradd  $1  &> /dev/null
echo 用户$1创建成功
echo 123  |  passwd --stdin $1 &> /dev/null
echo 用户$1密码设置成功
[root@server0 ~]# /root/user.sh  jack

[root@server0 ~]# vim /root/2.sh
 #!/bin/bash
 cat  -n  $1  |  head  -$2

[root@server0 ~]# chmod +x /root/2.sh
[root@server0 ~]# /root/2.sh  /etc/passwd  3

###############################################
预定义变量:由系统定义并且赋值完成
 
    $# 已加载的位置变量的个数,判断用户是否输入命令行参数

[root@server0 ~]# vim /root/1.sh 
#!/bin/bash
echo $1
echo $2
echo $3
echo $#
                      
[root@server0 ~]# /root/1.sh haha  xixi  hehe  lele


    $? 程序退出后的状态值,0表示正常,其他值异常

##################################################
条件测试及选择

–  [   测试表达式   ]  　　　＃每一部分之间都要有空格


常用的测试选项
• 检查文件状态
  -e:存在及为真                                       
  -d:存在并且必须为目录  才为真
  -f:存在并且必须为文件  才为真
[root@server0 ~]# [ -e /aaa ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ -f /etc/passwd ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ -f /etc/ ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ -d /etc/ ]
[root@server0 ~]# echo $?
0

• 比较整数大小
  -gt:大于
  -ge:大于等于
  -eq:等于
  -ne:不等于
  -lt:小于
  -le:小于等于
[root@server0 ~]# [ 1 -eq 1 ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ 1 -ge  1 ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ 1 -gt  1 ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ 10 -le 12 ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# 

• 字符串比对
    ==:一致为真
    !=:不一致为真
[root@server0 ~]# [ student == redhat ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ $USER == root ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ student != redhat ]
[root@server0 ~]# echo $?
0

################################################
if双分支处理

	if  [条件测试];then
	   命令序列xx
	else
	   命令序列yy
	fi

[root@server0 ~]# vim  /root/if01.sh
#!/bin/bash
if  [  $1  -eq  1  ];then
  echo  hello
else
  echo  hi
fi
[root@server0 ~]#  /root/if01.sh  1
[root@server0 ~]#  /root/if01.sh  2

判断用户是否输入参数(位置变量)
[root@server0 ~]# vim  /root/if02.sh 
#!/bin/bash
if   [  $#  -eq  0  ];then
 echo 您没有输入参数
else
 echo 您输入了参数
fi
[root@server0 ~]# /root/if02.sh 
[root@server0 ~]# /root/if02.sh test

案例:利用read获取用户名进行判断   
  如果用户存在,则输出  用户已存在
  如果用户不存在,则输出  用户不存在
[root@server0 ~]# vim  /root/if03.sh
#!/bin/bash
read  -p  '请输入您要测试的用户名:'    a
id  $a  &> /dev/null
if  [  $?  -eq  0  ];then
  echo  用户$a已存在
else
  echo  用户$a不存在
fi
[root@server0 ~]# /root/if03.sh

#################################################
[root@server0 ~]# vim   /root/if04.sh   
#!/bin/bash
read -p  '请输入您要测试的IP地址:'     ip
ping  -c  2  $ip  &> /dev/null       #-c指定ping的次数
if  [  $?  -eq  0  ];then
 echo $ip可以通信
else
 echo $ip不可以通信
fi

[root@server0 ~]# /root/if04.sh 

##############################################
if多分支处理

	if [条件测试1];then
	   命令序列xx
	elif [条件测试2];then
	   命令序列yy
	else
	   命令序列zz
	fi

案例:利用read获取用户的成绩
  如果大于等于90,则输出  优秀
  如果大于等于80,则输出  良好
  如果大于等于70,则输出  一般
  如果大于等于60,则输出  合格
  以上均不满足,则输出  再牛的肖邦也弹不出哥的悲伤
[root@server0 ~]# vim  /root/if05.sh
#!/bin/bash
read  -p  '请输入您的成绩:'      num
if   [  $num  -ge  90  ];then
  echo  优秀
elif [  $num  -ge  80  ];then 
  echo  良好
elif [  $num  -ge  70  ];then
  echo  一般
elif [  $num  -ge  60  ];then
  echo  合格
else
  echo 再牛的肖邦也弹不出哥的悲伤
fi
##############################################
列表式循环,解决重复性的操作


    for  献血车   in  献血的队伍
	do
	    抽血
	done


[root@server0 ~]# vim  /root/for01.sh
#!/bin/bash
for  a  in zhangsan lisi  wangwu haha xixi
do
 echo $a
done

[root@server0 ~]# vim /root/for01.sh
#!/bin/bash
for  a  in zhangsan lisi  wangwu haha xixi
do
 useradd  $a  &> /dev/null
 echo  $a用户创建成功
done


#######################################
 列表值可以不参与,循环代码的执行
[root@server0 ~]# vim /root/for01.sh
#!/bin/bash
for  a  in zhangsan lisi  wangwu haha xixi
do
 echo I Love DC
done
 

造数工具:制造连续范围的数字   {起始值..结束值}
[root@server0 ~]# vim  /root/for01.sh
#!/bin/bash
for  a  in  {1..99}
do
 sleep 0.5           #暂停0.5秒
 echo I Love DC $a
done

[root@server0 ~]# /root/for01.sh

################################################
案例4:编写一个判断脚本
在 server0 上创建 /root/foo.sh 脚本
1)当运行/root/foo.sh redhat,输出为fedora
2)当运行/root/foo.sh fedora,输出为redhat
3)当没有任何参数或者参数不是 redhat 或者fedora时,
其错误输出产生以下信息: /root/foo.sh redhat|fedora

#######################################################

date 2
案例4:编写一个判断脚本
在 server0 上创建 /root/foo.sh 脚本
1)当运行/root/foo.sh redhat,输出为fedora
2)当运行/root/foo.sh fedora,输出为redhat
3)当没有任何参数或者参数不是 redhat 或者fedora时,
其错误输出产生以下信息: /root/foo.sh redhat|fedora

[root@server0 ~]# vim  /root/foo.sh
#!/bin/bash
# 判断$1参数的脚本
if [ $#  -eq  0 ];then       #判断用户是否输入参数
 echo '/root/foo.sh  redhat|fedora' >&2   #变成错误输出
 exit 3                     #脚本退出返回的状态值
elif [ $1 == redhat ];then  #判断是否为redhat
 echo fedora
elif [ $1 == fedora ];then  #判断是否为fedora
 echo redhat
else
 echo '/root/foo.sh  redhat|fedora' >&2  #变成错误输出
 exit 4   #脚本退出返回的状态值
fi

案例5:编写一个批量添加用户脚本
在 server0 上创建 /root/batchusers 脚本
1)此脚本要求提供用户名列表文件作为参数
2)如果没有提供参数,此脚本应该给出提示
 Usage: /root/batchusers,退出并返回相应值
3)如果提供一个不存在的文件,此脚本应该给出提
示 Input file not found,退出并返回相应值
4)新用户的登录Shell为 /bin/false,无需设置密码
5)用户列表测试文件:
 http://classroom/pub/materials/userlist

[root@server0 ~]# vim /root/userlist
duanwu
zhongqiu
zhsan
lisi
dc
[root@server0 ~]# vim  /root/batchusers 
#!/bin/bash
if  [ $# -eq 0 ];then                   #判断是否有参数
 echo  'Usage: /root/batchusers' >&2
 exit 2
elif [ -f  $1  ];then     #判断文件是否存在
 for  a  in $(cat $1)
 do
  useradd -s /bin/false  $a  &> /dev/null
  echo $a创建成功
 done
else
  echo 'Input file not found' >&2
  exit 3
fi
[root@server0 ~]# /root/batchusers  /root/userlist

###################################################
系统安全保护
SELinux安全机制
• Security-Enhanced Linux
– 美国NSA国家安全局主导开发,一套增强Linux系统安
全的强制访问控制体系
– 集成到Linux内核(2.6及以上)中运行
– RHEL7基于SELinux体系针对用户、进程、目录和文件
提供了预设的保护策略,以及管理工具

• SELinux的运行模式
– enforcing(强制)、permissive(宽松)
– disabled(彻底禁用)

 任何模式切换成disabled模式,都要经历重启

• 切换运行模式
– 临时切换:setenforce 1|0
– 固定配置:/etc/selinux/config 文件

虚拟机server0
[root@server0 ~]# getenforce      #查看当前的状态
[root@server0 ~]# setenforce  0   #临时修改为宽松模式 
[root@server0 ~]# getenforce 
[root@server0 ~]# vim /etc/selinux/config
SELinux=permissive

虚拟机desktop0
[root@desktop0 ~]# getenforce 
[root@desktop0 ~]# setenforce  0
[root@desktop0 ~]# getenforce 
[root@desktop0 ~]# vim /etc/selinux/config
SELinux=permissive

###############################################
配置用户环境  

alias别名设置
• 查看已设置的别名
– alias [别名名称]
• 定义新的别名
– alias 别名名称= '实际执行的命令行'
• 取消已设置的别名
– unalias [别名名称]


• 影响指定用户的 bash 解释环境
– ~/.bashrc,每次开启 bash 终端时生效
• 影响所有用户的 bash 解释环境
– /etc/bashrc,每次开启 bash 终端时生效

[root@server0 ~]# vim /root/.bashrc 
alias hello='echo hello'
[root@server0 ~]# vim  /home/student/.bashrc 
alias hi='echo hi'
[root@server0 ~]# vim /etc/bashrc 
alias dc='echo tc'

 新开一个终端验证
###############################################
虚拟机server0:搭建Web服务器

Web服务:提供网页内容

实现Web服务的软件:  httpd   Nginx   Tomcat
实现Web通信的协议: http(超文本传输协议)

1.安装httpd软件                                             
[root@server0 ~]# yum -y install httpd

2.重启程序(重启服务)
[root@server0 ~]# systemctl restart httpd

3.本机测试访问
[root@server0 ~]# firefox 172.25.0.11

4.书写自己的页面文件 
    默认存放路径:/var/www/html
    默认首页文件名称:index.html

[root@server0 ~]# vim /var/www/html/index.html
<marquee><font color=red><h1>NSD1906 haha
滚动            字体颜色            标题字体

[root@server0 ~]# firefox  172.25.0.11

##############################################
虚拟机server0:搭建FTP服务
FTP服务:传输数据
FTP协议:文件传输协议
实现FTP服务软件:vsftpd

 默认共享路径:/var/ftp

1.安装vsftpd软件
[root@server0 ~]# yum -y install vsftpd

2.重启程序(重启服务)
[root@server0 ~]# systemctl restart vsftpd
[root@server0 ~]# firefox ftp://172.25.0.11

#################################################
防火墙策略管理

    作用: 隔离  众多的策略,允许出站,严格控制入站

   硬件防火墙
   软件防火墙

firewalld服务基础
• 系统服务:firewalld
• 管理工具:firewall-cmd、firewall-config

##################################################
预设安全区域
• 根据所在的网络场所区分,预设保护规则集
– public:仅允许访问本机的ssh dhcp ping服务
– trusted:允许任何访问
– block:阻塞任何来访请求(明确拒绝,有回应客户端)
– drop:丢弃任何来访的数据包(没有回应,节省服务端资源)

根据数据包的源IP地址
  数据包: 源IP地址   目标IP地址  数据

防火墙判定原则:
1.查看数据包的源IP地址,然后查看自己所有的区域,那个区域中有该源IP地址的规则,则进入该区域

2.进入默认区域(public)
################################################
防火墙默认区域的修改
虚拟机server:
]# firewall-cmd --get-default-zone  #查看默认区域
虚拟机desktop:
]# ping 172.25.0.11  #可以通信,有回应
虚拟机server:
]# firewall-cmd --set-default-zone=block  #修改默认区域
]# firewall-cmd --get-default-zone 
虚拟机desktop:
]# ping 172.25.0.11  #不可以通信,有回应

虚拟机server:
]# firewall-cmd --set-default-zone=drop 
]# firewall-cmd --get-default-zone 
虚拟机desktop:
]# ping 172.25.0.11  #不可以通信,没有回应

################################################
互联网常见的协议:                                             
          http:超文本传输协议    默认端口:80
          https:安全的超文本传输协议     默认端口:443              
          DNS:域名解析协议  默认端口:53
          FTP:文件传输协议  默认端口:21
          tftp:简单的文件传输协议  默认端口:69
          telnet:远程管理协议(明文传输)  默认端口:23
          ssh:远程管理协议(加密传输)  默认端口:22
          SMTP:邮件协议(用户发邮件)  默认端口:25
          pop3:邮件协议(用户收邮件) 默认端口:110
          snmp:简单的网络管理协议 默认端口:161

防火墙区域添加允许的协议 
虚拟机server
]# firewall-cmd --set-default-zone=public  #修改默认区域 
]# firewall-cmd --zone=public --list-all  #查看区域规则
]# firewall-cmd --zone=public --add-service=ftp #添加协议
]# firewall-cmd --zone=public --add-service=http
]# firewall-cmd --zone=public --list-all

虚拟机desktop
[root@desktop0 ~]# firefox 172.25.0.11   #访问成功
[root@desktop0 ~]# firefox ftp://172.25.0.11  #访问成功
#####################################################
防火墙规则的永久设置
– 永久(permanent)
]# firewall-cmd  --reload    #重新加载防火墙所有配置
]# firewall-cmd --zone=public --list-all

]# firewall-cmd  --permanent  --zone=public --add-service=http
]# firewall-cmd  --permanent  --zone=public --add-service=ftp

]# firewall-cmd --zone=public --list-all
]# firewall-cmd --reload 

]# firewall-cmd --zone=public --list-all 

###################################################
单独拒绝虚拟机desktop访问
虚拟机server:将虚拟机desktop的IP地址写入block
]# firewall-cmd --zone=block  --add-source=172.25.0.10
]# firewall-cmd --zone=block  --list-all

虚拟机desktop:
]# firefox 172.25.0.11        #访问失败
]# firefox ftp://172.25.0.11   #访问失败

真机:
]# firefox 172.25.0.11          #可以进行访问
]# firefox ftp://172.25.0.11   #可以进行访问
                                       
虚拟机server: 删除规则               
]# firewall-cmd --zone=block --remove-source=172.25.0.10

虚拟机desktop:
]# firefox 172.25.0.11        #可以进行访问
]# firefox ftp://172.25.0.11    #可以进行访问
#####################################################

 端口: 协议或程序或服务的编号
         利用root可以改变端口,而且一个程序可以具备多个端口

     监听端口    

实现本机的端口映射
• 本地应用的端口重定向(端口1 --> 端口2)

客户端访问: firefox  172.25.0.11:5423--->172.25.0.11:80

虚拟机server:
]# firewall-cmd --permanent  --zone=public  
--add-forward-port=port=5423:proto=tcp:toport=80

]# firewall-cmd --reload
]# firewall-cmd --zone=public --list-all 

虚拟机desktop:
[root@desktop0 ~]# firefox 172.25.0.11:5423
###################################################


date 3
iSCSI网络磁盘

• Internet SCSI,网际SCSI接口    默认端口:3260
– 一种基于C/S架构的虚拟磁盘技术
– 服务器提供磁盘空间,客户机连接并当成本地磁盘使用

• backstore,后端存储
– 对应到服务端提供实际存储空间的设备,需要起一个管理名称
• target,磁盘组
– 是客户端的访问目标,作为一个框架,由多个lun组成
• lun,逻辑单元
– 每一个lun需要关联到某一个后端存储设备,在客户端
会视为一块虚拟硬盘

                  冰箱---->纸质包装       木质箱子

• ISCSI Qualified Name 名称规范(iqn)
– iqn.yyyy-mm.倒序域名:自定义标识
–  用来识别 target 磁盘组,也用来识别客户机身份
   


一  修改防火墙默认区域
虚拟机server
]# firewall-cmd --set-default-zone=trusted
虚拟机desktop
]# firewall-cmd --set-default-zone=trusted

二 划分一个5G的主分区
[root@server0 ~]# fdisk /dev/vdb
[root@server0 ~]# lsblk

虚拟机server服务端:
1.安装软件包targetcli
[root@server0 ~]# yum -y install targetcli

2.运行targetcli命令进行配置
[root@server0 ~]# targetcli
/> ls     #查看相关配置

    1)建立后端存储backstore,后端存储           
/> backstores/block create name=nsd dev=/dev/vdb1
/> ls

    2)建立target磁盘组
/> iscsi/ create  iqn.2019-07.com.example:server
/> ls

    3)进行lun关联
/> iscsi/iqn.2019-07.com.example:server/tpg1/luns      create /backstores/block/nsd 
/> ls
/> exit  #退出

    4)设置访问控制,客户端声称的名字,符合iqn名称规范
[root@server0 ~]# targetcli 
/> ls
/> iscsi/iqn.2019-07.com.example:server/tpg1/acls create iqn.2019-07.com.example:desktop

/> ls
   
    5)设置监听的IP地址
/> iscsi/iqn.2019-07.com.example:server/tpg1/portals  create ip_address=172.25.0.11 

/> ls
/> exit  #退出

三 重启服务(重启程序)
[root@server0 ~]# systemctl restart target
[root@server0 ~]# systemctl enable target  #设置为开机自启
ln -s '/usr/lib/systemd/system/target.service' '/etc/systemd/system/multi-user.target.wants/target.service'
####################################################

虚拟机desktop
1.安装软件包(客户端软件)
• 所需软件包:iscsi-initiator-utils
Yum仓库可以补全软件名:
    前提1:当前系统没有安装此软件
    前提2:必须具备Yum缓存  (yum repolist 可以直接生成缓存)

[root@desktop0 ~]# yum repolist
[root@desktop0 ~]# rpm -q  iscsi-initiator-utils
iscsi-initiator-utils-6.2.0.873-21.el7.x86_64

[root@desktop0 ~]# yum -y install iscsi(tab)
2.设置客户端生成的名字
[root@desktop0 ~]# vim /etc/iscsi/initiatorname.iscsi
InitiatorName=iqn.2019-07.com.example:desktop 

3.客户端刷新声称名字的服务
[root@desktop0 ~]# systemctl restart iscsid
  Warning: Unit file of iscsid.service changed on  
  disk, 'systemctl daemon-reload' recommended.
[root@desktop0 ~]# systemctl daemon-reload
[root@desktop0 ~]# systemctl restart iscsid

4.发现共享存储
  Linux查看命令帮助的方法 :  man  iscsiadm 
   全文查找/example   按n项下跳转匹配,看到EXAMPLES

   Ctrl    - ：减小字体
   Ctrl   Shift   + ：变大字体   

[root@desktop0 ~]# iscsiadm --mode discoverydb --type sendtargets --portal 172.25.0.11 --discover

方法二:发现iSCSI磁盘
– iscsiadm -m discovery -t st -p 服务器地址[:端口]

5.加载共享存储
[root@desktop0 ~]# systemctl restart iscsi
[root@desktop0 ~]# systemctl enable iscsi
[root@desktop0 ~]# lsblk 

6.永久挂载
 root@desktopX ~]# mkfs.ext4 /dev/sda1//按要求格式化分区
[root@desktopX ~]# mkdir /mnt/data//创建挂载点
[root@desktopX ~]# blkid /dev/sda1//找到分区 UUID
/dev/sda1: UUID="6ff20bb3-7543-4fa0-b4fa-bdc99a1e63ce" ..
[root@desktopX ~]# vim /etc/fstab
.. ..
UUID="6ff20bb3-7543-4fa0-b4fa-bdc99a1e63ce" /mnt/data ext4 _netdev 0 0


###################################################
数据库服务基础

什么是数据库: 存放数据的仓库

  数据库中有众多库,在每一个库中有众多的表格


• 常见的关系型 数据库管理系统
– 微软的 SQL Server
– IBM的 DB2
– 甲骨文的 Oracle、MySQL
– 社区开源版 MariaDB

 database:数据库

####################################################

虚拟机server:部署mariadb数据库服务器
• RHEL7 中的 MariaDB相关包
– mariadb-server :提供服务端有关的系统程序

[root@server0 ~]# systemctl restart mariadb
[root@server0 ~]# systemctl enable mariadb
ln -s '/usr/lib/systemd/system/mariadb.service' '/etc/systemd/system/multi-user.target.wants/mariadb.service'
[root@server0 ~]# 
####################################################
数据库的基本操作:
[root@server0 ~]# mysql    #进入数据库
MariaDB [(none)]> show databases;     #查看所有的库

MariaDB [(none)]> create database nsd;  #创建nsd库
MariaDB [(none)]> show databases;

MariaDB [(none)]> drop database nsd;  #删除nsd库
MariaDB [(none)]> show databases;

MariaDB [(none)]> create database nsd1906;  
MariaDB [(none)]> show databases;

MariaDB [(none)]> use mysql;    #切换到mysql库
MariaDB [mysql]> use nsd1906;
MariaDB [nsd1906]> use mysql;

MariaDB [mysql]> show tables;  #查看当前库中有哪些表格
MariaDB [mysql]> exit  #退出整个数据库
###################################################
在Linux命令行,为数据库管理员设置密码

数据库管理员为root,对数据库有最高权限用户,存放在mysql库user表
Linux系统管理员为root,对系统有最高权限用户,存放/etc/passwd

• 为数据库账号修改密码
– mysqladmin [-u用户名] [-p[旧密码]] password '新密码'

]# mysqladmin -u root   password  '123'  #首次设置密码

]# mysql -u root  -p    #交互式进入
Enter password: 

]# mysql -u root -p123  #非交互式进入
]# mysql -e "命令"    #-e 调用数据库里的命令

已知旧密码修改新密码
]# mysqladmin -u root -p123   password '456'
##################################################
MariaDB主配置文件:
[root@server0 ~]# ls /etc/my.cnf

##################################################
表格 : 增(insert)    删(delete)    改(update)     查(select)   

   表记录     表字段

           编号       姓名       联系方式          居住地址
        1      dc    138.....     东村
        2      tc    138.....     西村

• 导入/恢复到数据库

– mysql [-u用户名] [-p[密码]] 数据库名 < 备份文件.sql

[root@server0 ~]# wget http://classroom.example.com/pub/materials/users.sql
[root@server0 ~]# ls

]# mysql -u root -p123 nsd1906 < /root/users.sql 

]# mysql -u root -p123          #进入到数据库
MariaDB [(none)]> use nsd1906;  #切换到nsd1906库
MariaDB [nsd1906]> show tables; #显示所有表格
+-------------------+
| Tables_in_nsd1906 |
+-------------------+
| base              |
| location          |
+-------------------+
################################################
查(select)   
格式: select  表字段    from  库名.表名  where 条件 ;
]# mysql -u root -p123          #进入到数据库
> use nsd1906;   #切换到nsd1906库
> show tables;   #显示所有表格
> select * from  base;      #查看表所有字段及所有记录内容
> select * from  location;  #查看表所有字段及所有记录内容

> use mysql;
> select * from nsd1906.base;         

> use nsd1906;
> select id,name from base;
> select  *  from base where name='tom';
> select  *  from base where password='456';
> select  *  from base where id='3';

###################################################
查询表结构: desc 表名;
MariaDB [(none)]> use nsd1906;
MariaDB [nsd1906]> desc base;
+----------+--------
| Field    |
+----------+---------
| id       |     
| name     |    
| password |      
+----------+----------
MariaDB [nsd1906]> use mysql;
MariaDB [mysql]> desc user;
MariaDB [mysql]> select user,host,password from user;
####################################################
数据库授权
用户授权设置
• MariaDB [(none)]> 交互指令

– GRANT 权限列表  ON  数据库名.表名 TO 用户名@
客户机地址 IDENTIFIED BY '密码';

– 除了 root 用户,此nsd1906数据库只能被用户 lisi 查询,
此用户的密码为123

> grant select  on  nsd1906.*  to  lisi@localhost identified by '123';

当lisi从localhost本地登录,输入密码123,将会获得nsd1906库中所有表格的查询权限;

> select user,host,password from user;

####################################################

案例4:使用数据库查询
2. 在系统 server0 上使用数据库 nsd1906,并使用相
应的 SQL 查询以回答下列问题:
1)密码是 solicitous 的人的名字?
[root@server0 ~]# mysql -u root -p123
> use nsd1906;
> select * from base;
> select * from base where  password='solicitous';
> select name from base where  password='solicitous';

2)有多少人的姓名是 Barbara 同时居住在 Sunnyvale?   
> select * from  base,location
  where base.name='Barbara'  and  
  location.city='Sunnyvale'  and  base.id=location.id;

> select count(*) from  base,location
  where base.name='Barbara'  and  
  location.city='Sunnyvale'  and  base.id=location.id;

> insert base  values('6','Barbara','xixi');  #插入记录
> select * from  base;
> insert location  values('6','Sunnyvale');  #插入记录
> select * from  location;

##################################################
1. 禁止空密码root用户访问 mariadb 数据库
> use mysql;
> select user,host,password from user;
> select user,host,password from user where password='';

> delete from user  where  password='';   #删除记录
> select user,host,password  from  user;

> flush  privileges;    #刷新user表记录

验证登录失败:
[root@server0 ~]# mysql -u root -h server0.example.com 

###################################################

date 4
环境准备:防火墙设置
虚拟机server
]# firewall-cmd --set-default-zone=trusted 
虚拟机desktop
]# firewall-cmd --set-default-zone=trusted 
###################################################
配置NFS共享

NFS共享概述
• Network File System,网络文件系统
– 用途:为客户机提供共享使用的文件夹
– 协议:NFS(TCP/UDP 2049)、RPC(TCP/UDP 111)

• 所需软件包:nfs-utils
• 系统服务:nfs-server

虚拟机server:构建NFS服务
1.安装nfs-utils软件包
[root@server0 ~]# rpm -q nfs-utils
nfs-utils-1.3.0-0.el7.x86_64

2.配置共享
[root@server0 ~]# mkdir /nsd
[root@server0 ~]# echo 123 > /nsd/1.txt
[root@server0 ~]# ls /nsd/
[root@server0 ~]# vim /etc/exports
– 文件夹路径   客户机地址(权限) 客户机地址(权限) .. ..
   /nsd      *(ro)
   /opt      *(ro)

3.重启服务(重启程序)
[root@server0 ~]# systemctl restart nfs-server

虚拟机desktop:访问共享文件夹
1.挂载共享目录
]# mkdir /mnt/a  /mnt/b
]# showmount -e 172.25.0.11     #查看服务端共享内容
]# mount 172.25.0.11:/nsd /mnt/a/
]# df -h
]# ls  /mnt/a

]# mount 172.25.0.11:/opt/  /mnt/b
]# ls  /mnt/b
]# df -ah            #显示当前全部的挂载

2.开机自动挂载/etc/fstab              
    _netdev:声明网络设备
                     指明挂载本设备需要有网络参数再进行挂载

[root@desktop0 ~]# vim /etc/fstab 
 172.25.0.11:/nsd  /mnt/a  nfs defaults,_netdev 0 0
 172.25.0.11:/opt  /mnt/b  nfs defaults,_netdev 0 0

[root@desktop0 ~]# umount /mnt/a
[root@desktop0 ~]# umount /mnt/b
[root@desktop0 ~]# df -ah
[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -ah

###################################################
HTTP服务基础

Web服务:提供网页内容

• 基于 B/S (Browser/Server)架构的网页服务
– 服务端提供网页
– 浏览器下载并显示网页

• Hyper Text Markup Language(html),超文本标记语言
• Hyper Text Transfer Protocol(http),超文本传输协议

• 软件包:httpd(Apache组织)  #专门实现Web服务的软件

虚拟机server:
1.安装httpd软件
[root@server0 ~]# yum -y install httpd

2.重启服务
[root@server0 ~]# systemctl restart httpd

3.访问测试
[root@server0 ~]# firefox  172.25.0.11

4.书写页面文件
]# echo '<h1>NSD1906 Web' >  /var/www/html/index.html
]# cat  /var/www/html/index.html

]# firefox  172.25.0.11
#####################################################

主配置文件配置字段:
– Listen:监听地址:端口(80)
– ServerName:本站点注册的DNS名称(空缺)
– DocumentRoot:网页根目录(/var/www/html)
– DirectoryIndex:起始页/首页文件名(index.html)

   虚拟机classroom:
   DNS服务器的解析:将域名解析为IP地址
      server0.example.com----->172.25.0.11
      www0.example.com----->172.25.0.11
      webapp0.example.com----->172.25.0.11
 
[root@desktop0 ~]# nslookup webapp0.example.com
[root@desktop0 ~]# nslookup server0.example.com
[root@desktop0 ~]# nslookup www0.example.com
##################################################
– DocumentRoot:网页文件的根目录(/var/www/html)   
虚拟机server
]# mkdir /var/www/myweb
]# echo '<h1>wo shi myweb'  > /var/www/myweb/index.html
]# cat /var/www/myweb/index.html

]# vim /etc/httpd/conf/httpd.conf
 DocumentRoot "/var/www/myweb"  

]# systemctl restart httpd

虚拟机desktop:测试
[root@desktop0 ~]# firefox 172.25.0.11

#####################################################
网络路径与实际服务器路径    网页文件的根目录

客户端:firefox http://172.25.0.11:80---->服务端172.25.0.11
----->httpd 80----->DocumentRoot /var/www/myweb--->index.html

客户端: firefox 172.25.0.11
服务端: /var/www/myweb

客户端: firefox 172.25.0.11/abc
服务端: /var/www/myweb/abc/index.html

DocmentRoot  /var/www/myweb
客户端: firefox 172.25.0.11/var/www/myweb/abc
服务端: /var/www/myweb/var/www/myweb/abc


虚拟机server:
]# mkdir /var/www/myweb/abc
]# echo '<h1>wo shi abc' >    /var/www/myweb/abc/index.html

]# firefox  172.25.0.11/abc

  vsftpd----->/var/ftp
  httpd------>/var/www/html

####################################################
虚拟Web主机

• 虚拟Web主机
– 由同一台服务器提供多个不同的Web站点

• 区分方式
– 基于域名的虚拟主机
– 基于端口的虚拟主机
– 基于IP地址的虚拟主机

• 配置文件路径
– /etc/httpd/conf/httpd.conf   #主配置文件
– /etc/httpd/conf.d/*.conf     #调用配置文件

#####################################################

• 为每个虚拟站点添加配置
	<VirtualHost IP地址:端口>
	 ServerName  此站点的DNS名称
	 DocumentRoot  此站点的网页根目录
	</VirtualHost>


虚拟机server: vim命令模式下 u 可以撤销
]# vim /etc/httpd/conf.d/nsd01.conf   #建立调用配置文件
<VirtualHost *:80>               #启用虚拟Web主机功能
 ServerName server0.example.com  #指定网站DNS名称
 DocumentRoot /var/www/qq        #指定网页文件根目录
</VirtualHost>

<VirtualHost *:80>
 ServerName www0.example.com
 DocumentRoot /var/www/baidu
]# echo '<h1>baidu 百度'  >  /var/www/baidu/index.html
]# systemctl restart httpd

####################################################
虚拟Web主机优先级,由上到下依次匹配,匹配即停止

一旦使用虚拟Web主机功能,所有的网站都必须利用虚拟Web主机实现
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
 ServerName www0.example.com           
 DocumentRoot /var/www/baidu
</VirtualHost>
<VirtualHost *:80>
 ServerName server0.example.com
 DocumentRoot /var/www/qq
</VirtualHost>
<VirtualHost *:80>
 ServerName webapp0.example.com
 DocumentRoot /var/www/myweb
</VirtualHost>
[root@server0 ~]# systemctl restart httpd

##################################################
Web访问控制,针对存放网页文件的目录
   子目录默认继承父目录的Web访问控制   

<Directory />
    Require all denied   #拒绝所有人访问
</Directory>

<Directory "/var/www">
    Require all granted    #允许所有人访问
</Directory>

案例:自定义Web的网页文件根目录            
1.实现server0.example.com访问网页文件根目录修改为/webroot
]# vim /etc/httpd/conf.d/nsd01.conf 
<VirtualHost *:80>
 ServerName server0.example.com
 DocumentRoot /webroot
</VirtualHost>
]# mkdir /webroot
]# echo '<h1>wo shi webroot' > /webroot/index.html
2.修改访问控制
[root@server0 ~]# vim /etc/httpd/conf/httpd.conf 
[root@server0 ~]# vim /etc/httpd/conf.d/nsd02.conf
<Directory   "/webroot">    #针对/webroot路径
    Require all granted   #允许所有人访问
</Directory>
[root@server0 ~]# systemctl restart httpd

3.SELinux策略
[root@server0 ~]# setenforce 0
[root@server0 ~]# getenforce 
Permissive
[root@server0 ~]# vim /etc/selinux/config
SELINUX=permissive

[root@server0 ~]# firefox server0.example.com
###############################################


date 5
环境准备:防火墙设置
虚拟机server
]# firewall-cmd --set-default-zone=trusted 
虚拟机desktop
]# firewall-cmd --set-default-zone=trusted 
###################################################
案例:为虚拟机server配置以下虚拟Web主机
- 实现三个网站的部署
- 实现客户端访问server0.example.com网页内容为 卖女孩的小火柴
- 实现server0.example.com网页根目录为/var/www/abc01

- 实现客户端访问www0.example.com网页内容为  奔跑吧骆驼
- 实现www0.example.com网页根目录为/var/www/abc02

- 实现客户端访问webapp0.example.com网页内容为 20里春风不如你
- 实现webapp0.example.com网页根目录为/var/www/abc03

###################################################
文件夹权限
• 针对 DocumentRoot 网页目录的权限控制
– httpd 运行身份(用户/组):apache

客户机地址限制
• 使用 <Directory> 配置区段
– 每个文件夹自动继承其父目录的ACL访问权限
– 除非针对子目录有明确设置
<Directory 目录的绝对路径>
.. ..
Require all denied|granted
Require ip IP或网段地址 .. ..
</Directory>

案例1:配置网页内容访问
在 Web 网站 http://server0.example.com 的            
DocumentRoot 目录下创建一个名为 private 的子目录,要求如下:
1.创建目录
]# cat /etc/httpd/conf.d/nsd01.conf  #查看DocumentRoot
]# mkdir /var/www/abc01/private

2.从 http://classroom.example.com/pub/materials/private.html下载一个文件副本到这个目录,重命名为 index.html
不要对文件 index.html 的内容作任何修改
]# cd /var/www/abc01/private
]# wget http://classroom.example.com/pub/materials/private.html
]# mv private.html index.html
]# firefox server0.example.com/private

3)从虚拟机server0 上,任何人都可以浏览 private 的内容,
但是从其他系统不能访问这个目录的内容
[root@server0 /]# vim /etc/httpd/conf/httpd.conf
[root@server0 /]# vim /etc/httpd/conf.d/nsd02.conf
<Directory  "/var/www/abc01/private">
    Require ip 172.25.0.11    #仅允许172.25.0.11访问
</Directory>
[root@server0 /]# systemctl restart httpd

虚拟机desktop:
[root@desktop0 ~]# firefox server0.example.com/private
Forbidden

You don't have permission to access /private on this server.
####################################################
案例2:使用自定Web根目录
调整 Web 站点 http://server0.example.com 的网页目录,要求如下:
1)新建目录 /webroot,作为此站点新的网页目录
]# mkdir /webroot
]# echo '<h1> wo shi webroot' > /webroot/index.html
[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf
<VirtUalHost *:80>
  ServerName server0.example.com
  DocumentRoot /webroot
</VirtUalHost>

2)修改访问控制
[root@server0 /]# vim /etc/httpd/conf.d/nsd02.conf
<Directory  "/webroot">
    Require all granted   #允许所有人可以访问
</Directory>
[root@server0 /]# systemctl restart httpd

3)修改SELinux策略:安全上下文值(打标签) 布尔值策略 非默认端口开放
  神州旅游: 红色帽子                               
  达内旅游: 绿色帽子
]# semanage --help
]# semanage fcontext -l  |  less   #查看所有上下文值
]# ls -Zd /var/www/    #专查看目录上下文值
]# ls -Zd /webroot/
• 方式1:参照标准目录,重设新目录的属性
– chcon [-R] --reference=模板目录   新目录

]# chcon -R  --reference=/var/www  /webroot/
]# ls -Zd /webroot/
测试:
[root@desktop0 ~]# firefox server0.example.com
###################################################
部署动态网站

静态网站的运行
• 服务端的原始网页 = 浏览器访问到的网页
– 由Web服务软件处理所有请求
– 文本(txt/html)、图片(jpg/png)等静态资源


动态网站的运行
• 服务端的原始网页 ≠ 浏览器访问到的网页
– 由Web服务软件接受请求,动态程序转后端模块处理
– PHP网页、Python网页、JSP网页......

################################################
为站点 webapp0.example.com 配置提供动态Web内容,要求如下:
1.部署Python页面文件
]# cat /etc/httpd/conf.d/nsd01.conf  #查看DocumentRoot
]# cd /var/www/abc03
]# wget http://classroom.example.com/pub/materials/webinfo.wsgi

]#  ls

2.页面跳转(页面别名  地址重写)方便用户的访问

当用户访问 webapp0.example.com将webinfo.wsgi页面进行呈现

格式:  Alias  网络路径     实际路径 

     Alias   /     /var/www/abc03/webinfo.wsgi
当用户访问的时网页文件根目录时,跳转到/var/www/abc03/webinfo.wsgi

[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf 
<VirtUalHost *:80>
  ServerName webapp0.example.com
  DocumentRoot /var/www/abc03
  Alias  /   /var/www/abc03/webinfo.wsgi
当用户访问的是网页文件根目录时,跳转到/var/www/abc03/webinfo.wsgi
</VirtUalHost>
[root@server0 /]# systemctl restart httpd

[root@desktop0 ~]# firefox webapp0.example.com

3.翻译Python页面代码                          
[root@server0 /]# yum -y install mod_wsgi
[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf
<VirtUalHost *:80>
  ServerName webapp0.example.com
  DocumentRoot /var/www/abc03
  WsgiScriptAlias /  /var/www/abc03/webinfo.wsgi
</VirtUalHost>
[root@server0 /]# systemctl restart httpd

页面内容显示:
  UNIX时间戳:从1970-1-1 0:0:0到达现在时间,所经历的秒数
[root@desktop0 ~]# firefox webapp0.example.com

4.此虚拟Web主机侦听在端口8909
[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf
Listen 8909             #设置httpd程序监听8909端口
<VirtUalHost *:8909>     #设置虚拟Web主机监听8909端口
  ServerName webapp0.example.com
  DocumentRoot /var/www/abc03
  WsgiScriptAlias /  /var/www/abc03/webinfo.wsgi
</VirtUalHost>

]# semanage port -l  | grep http  #查看关于http开放的端口
]# semanage port -a -t http_port_t  -p tcp 8909
此命令会占用较多内存, -a 添加  -t 类型  -p 协议

]# systemctl restart httpd
测试验证: firefox webapp0.example.com:8909
总结:访问时端口优先级最高
####################################################
安全Web服务

PKI公钥基础设施
• Public Key Infrastructure,公钥基础设施
– 公钥:主要用来加密数据
– 私钥:主要用来解密数据(与相应的公钥匹配)
– 数字证书:证明拥有者的合法性/权威性(单位名称、
有效期、公钥、颁发机构及签名、......)
– Certificate Authority,数字证书授权中心:负责证书
的申请/审核/颁发/鉴定/撤销等管理工作


 数据证书授权中心:虚拟机classroom
#################################################
虚拟机server:
为站点 www0.example.com 配置安全加密的Web内容
1.部署网站证书(营业执照)
]# cd /etc/pki/tls/certs/
]# wget http://classroom.example.com/pub/tls/certs/server0.crt
]# ls

2.部署网站的根证书(工商局的信息)
]# cd /etc/pki/tls/certs/
]# wget http://classroom.example.com/pub/example-ca.crt
]# ls

3.部署解密数据的私钥
]# cd /etc/pki/tls/private/
]# wget http://classroom.example.com/pub/tls/private/server0.key
]# ls

4.安装可以进行加密支持的软件mod_ssl
[root@server0 /]# yum -y install mod_ssl
[root@server0 /]# vim /etc/httpd/conf.d/ssl.conf 
 补充:vim末行模式  输入set  nu 可以开启行号

 59 DocumentRoot "/var/www/abc02"
 60 ServerName www0.example.com:443
指定网站证书
100 SSLCertificateFile /etc/pki/tls/certs/server0.crt
指定解密的私钥
107 SSLCertificateKeyFile /etc/pki/tls/private/server0.key
指定网站的根证书
122 SSLCACertificateFile /etc/pki/tls/certs/example-ca.crt
[root@server0 /]# systemctl restart httpd
[root@server0 /]# firefox https://www0.example.com
    我已了解可能的风险--->添加例外---->确认安全例外
###################################################
补充:Samba共享服务(Windows与Linux跨平台的共享)

     smb(用户验证通信协议)  cifs(Samba独有文件系统) 

 程序名(服务名):smb

虚拟机server:
1.安装软件包
[root@server0 /]# yum -y install samba   

2.创建Samba共享帐号 
       1.建立在本地用户的基础上
       2.采用独立的密码,与用户登录系统的密码不同
[root@server0 /]# useradd harry
[root@server0 /]# pdbedit -a harry  #添加为samba帐号
new password:
retype new password:  
[root@server0 /]# pdbedit -L        #查看所有的samba帐号
[root@server0 /]# pdbedit -x harry  #删除samba帐号harry
[root@server0 /]# pdbedit -a harry

3.创建共享目录及配置共享
[root@server0 /]# mkdir /public
[root@server0 /]# echo haha > /public/1.txt
[root@server0 /]# vim /etc/samba/smb.conf 
 命令模式: G(大写) 到全文的末行
[nsd]              #设置共享名
path = /public     #设置实际共享的路径

[root@server0 /]# systemctl restart smb

4.修改SELinux策略: 布尔值策略(服务功能的开关)
[root@server0 /]# getsebool -a | grep samba
[root@server0 /]# setsebool samba_export_all_ro on
[root@server0 /]# getsebool -a | grep samba

客户端:虚拟机desktop0
1.安装软件包,支持cifs文件系统
[root@desktop0 ~]# yum -y install cifs-utils
2.进行挂载访问
]# mkdir /mnt/smb
格式:mount -o user=用户名,pass=密码  //服务器IP地址/共享名  挂载点目录
]# mount -o user=harry,pass=123  //172.25.0.11/nsd  /mnt/smb/
]# df -h
]# ls /mnt/smb/

3.开机自动挂载/etc/fstab

//172.25.0.11/nsd  /mnt/smb  cifs defaults,user=harry,pass=123,_netdev 0 0

[root@desktop0 ~]# umount /mnt/smb/
[root@desktop0 ~]# df -h
[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -h

###################################################

date 6
设置网络参数
一 设置永久的主机名,配置文件为/etc/hostname
[root@server0 ~]# echo 'nsd.tedu.cn' > /etc/hostname
[root@server0 ~]# cat /etc/hostname
nsd.tedu.cn
[root@server0 ~]# hostname
nsd.tedu.cn
[root@server0 ~]# exit
登出
Connection to 172.25.0.11 closed.
[student@room9pc01 ~]$ gos
Last login: Sat Jul 13 08:35:21 2019 from 172.25.0.250
[root@nsd ~]# 

二 永久设置设置IP地址 子网掩码  网关地址
1.查看识别的网卡名
[root@nsd ~]# nmcli connection show
名称                        
System eth0  

2.设置永久的IP地址 子网掩码  网关地址
]# nmcli connection modify 'System eth0' 
 ipv4.method manual 
 ipv4.addresses '172.25.0.110/24   172.25.0.254' 
 connection.autoconnect  yes

]# nmcli connection 修改  '网卡名' 
   ipv4.方法  手工设置
   ipv4.地址  'IP地址/子网掩码   网关地址'
     每次开机自动启用配置
   (ipv4.dns  地址)
   (ipv4.gateway 地址)  
3.激活配置
[root@nsd ~]# nmcli connection up 'System eth0'
[root@nsd ~]# ifconfig | head -2
[root@nsd ~]# route     #查看网关地址
   Gateway      
   172.25.0.254    

]#setip    // 交互式设置ip地址 和网关(Gateway)

Network name(eth0/eth1/eth2/eth3):eth1	
Set IP(IP/24):192.168.2.100/24
Set Gateway(default none):192.168.2.5

~]# route -n      // 查看网关信息



三  DNS服务器的地址                               

     永久配置文件:/etc/resolv.conf

]# echo 'nameserver 172.25.254.254' > /etc/resolv.conf
 
]# cat /etc/resolv.conf
nameserver 172.25.254.254

]# nslookup  server0.example.com

##################################################
IPv6地址的组成
• IPv4 地址表示
– 32个二进制位,点分隔的十进制数
– 例如:172.25.0.11、127.0.0.1

• IPv6 地址表示
– 128个二进制位,冒号分隔的十六进制数
– 每段内连续的前置 0 可省略、连续的多个 : 可简化为 ::
– 例如:
       2003:ac18:0000:0000:0000:0000:0000:0305
       2003:ac18::305

[root@nsd ~]# nmcli connection modify 'System eth0' ipv6.method manual ipv6.addresses  2003:ac18::305/64 connection.autoconnect   yes

[root@nsd ~]# nmcli connection up 'System eth0'
successfully(成功)

[root@nsd ~]# ifconfig | head -4
[root@nsd ~]# ping6 2003:ac18::305

###################################################
聚合连接(链路聚合  网卡绑定)

   作用:实现网卡的高可用

                  eth1     eth2   
                        
                                  虚拟网卡:team0  192.168.1.1

1.生成虚拟的网卡team0     参考:man teamd.conf  
                                             全文搜索/example  按 n跳转匹配

]# nmcli connection add type team 
  con-name team0 ifname team0 autoconnect yes 
  config '{"runner": {"name": "activebackup"}}'

]# nmcli connection 添加  类型   组队
     配置文件名 team0  网卡名  team0 开机自动启用
     配置运行方式为  活跃备份方式

]# ifconfig  team0
]#nmcli device       #查看网卡的状态


2 .添加成员
]# nmcli connection add type team-slave 
con-name team0-1 ifname eth1 master team0

]# nmcli connection add type team-slave 
con-name team0-2 ifname eth2 master team0

]# nmcli connection 添加  类型  team-成员  
 配置文件名 team0-2  网卡名为  eth2  主设备  team0

3.team0配置IP地址
]# nmcli connection modify team0 
  ipv4.method manual ipv4.addresses 192.168.1.1/24  
  connection.autoconnect  yes

]# nmcli connection up team0 

]# teamdctl team0 state   #专用于查看team0信息
]# ifconfig eth2 down
]# teamdctl team0 state

如果有敲错,删除所有重新开始
]# nmcli connection delete team0    #删除配置文件
]# nmcli connection delete team0-1  #删除配置文件
]# nmcli connection delete team0-2  #删除配置文件

  man named.conf----->Team1
  man teamd.conf----->"runner"


##################################################
基础邮件服务
前提:修改IP地址,符合DNS解析结果
[root@nsd ~]# nmcli connection modify 'System eth0'  
  ipv4.method manual 
  ipv4.addresses  '172.25.0.11/24  172.25.0.254'  
  connection.autoconnect  yes

[root@nsd ~]# nmcli connection up 'System eth0'

查看DNS服务器地址:
[root@nsd ~]# cat /etc/resolv.conf 
nameserver 172.25.254.254
[root@nsd ~]# nslookup server0.example.com #测试解析

##################################################
电子邮件通信
• 电子邮件服务器的基本功能
– 为用户提供电子邮箱存储空间(用户名@邮件域名)
– 处理用户发出的邮件 —— 传递给收件服务器
– 处理用户收到的邮件 —— 投递到邮箱

DNS服务器:虚拟机classroom
     yg@qq.com
  
     yg@server0.example.com

###############################################
虚拟机server:构建邮件服务器
1.安装postfix软件,实现邮件服务
[root@nsd ~]# rpm -q postfix
postfix-2.10.1-6.el7.x86_64

2.修改配置文件
[root@nsd ~]# vim /etc/postfix/main.cf
 vim末行模式: set  nu 开启行号

 99 myorigin = server0.example.com  #默认补全的域名后缀
116 inet_interfaces = all  #在本机所有网卡启用邮件功能
164 mydestination = server0.example.com 
                                                     #判断为本域邮件的依据
3.重启邮件服务
[root@nsd ~]# systemctl restart postfix

使用mail命令发信/收信
• mail 发信操作
– mail  -s   '邮件标题'     -r   发件人     收件人
[root@nsd ~]# useradd yg
[root@nsd ~]# useradd xln
[root@nsd ~]# mail -s 'test01' -r  yg   xln
hahaxixihehelele
.
EOT
[root@nsd ~]# mail -u xln  #查看xln的邮件
>N  1 yg@server0.example.c  Sat Jul 13 14:2118/569   
& 1     #输入邮件编号1查看邮件内容

[root@nsd ~]# echo '123'  | mail -s 'abc' -r  yg  xln
[root@nsd ~]# mail -u xln 
##################################################
parted分区工具,进行GPT分区模式

  MBR分区模式: fdisk分区工具
       最多有4个主分区,划分3个主分区,1个扩展分区,n个逻辑分区
       最大的空间支持:2.2TB

  GPT分区模式:parted分区工具
        最多有128个主分区
        最大的空间支持:18EB
        1EB=1024PB
        1PB=1024TB

[root@nsd ~]# lsblk 
[root@nsd ~]# parted  /dev/vdb               
(parted) mktable  gpt      #指定分区模式gpt
(parted) print            #输出分区表信息
(parted) mkpart           #划分新的分区
 分区名称？  []? nsd           #随意起名字
 文件系统类型？  [ext2]? xfs    #随意写不起决定性作用
 起始点？ 0                             
 结束点？ 2G  
忽略/Ignore/放弃/Cancel? Ignore   #输入  i 忽略
(parted) unit GB      #使用GB作为单位显示
(parted) print  
(parted) mkpart 
 分区名称？  []? nsd  
 文件系统类型？  [ext2]? xfs
 起始点？ 2G          
 结束点？ 4G          
(parted) print 
                                                   

###################################################



date 7
准备交换空间(虚拟内存)

缓解真实物理内存的压力
• 相当于虚拟内存,
– 当物理内存不够用时,使用磁盘空间来模拟内存
– 在一定程度上缓解内存不足的问题

一  利用fdisk进行分区,划分两个主分区分别为2G
[root@server0 ~]# fdisk /dev/vdb
[root@server0 ~]# lsblk 

二 格式化为交换文件系统
[root@server0 ~]# mkswap /dev/vdb1  #专业格式化交换文件系统
[root@server0 ~]# blkid /dev/vdb1   #查看文件系统类型

[root@server0 ~]# mkswap /dev/vdb2
[root@server0 ~]# blkid /dev/vdb2

三  启用交换分区
[root@server0 ~]# swapon /dev/vdb1  #启用交换分区
[root@server0 ~]# swapon /dev/vdb2
[root@server0 ~]# swapon  -s        #查看交换空间的成员信息

[root@server0 ~]# swapoff /dev/vdb1  #停用交换分区
[root@server0 ~]# swapon -s

[root@server0 ~]# swapoff /dev/vdb2
[root@server0 ~]# swapon -s

四 开机自动启用交换分区                            
[root@server0 ~]# vim /etc/fstab
/dev/vdb1  swap  swap defaults 0 0
/dev/vdb2  swap  swap defaults 0 0

[root@server0 ~]# swapoff /dev/vdb1
[root@server0 ~]# swapoff /dev/vdb2
[root@server0 ~]# swapon -s

[root@server0 ~]# swapon -a  #专门检测/etc/fstab交换分区
[root@server0 ~]# swapon -s

#################################################
补充内容:触发挂载(autofs)
准备工作:在划分一个2G的主分区
[root@server0 ~]# fdisk /dev/vdb

[root@server0 ~]# partprobe    #刷新分区表
[root@server0 ~]# lsblk
[root@server0 ~]# mkfs.xfs  /dev/vdb3   #格式化文件系统
[root@server0 ~]# blkid  /dev/vdb3

1.安装触发挂载的软件包
[root@server0 ~]# yum -y install autofs
2.重启autofs程序
[root@server0 ~]# systemctl restart autofs
[root@server0 ~]# systemctl enable autofs
ln -s '/usr/lib/systemd/system/autofs.service' '/etc/systemd/system/multi-user.target.wants/autofs.service'

3.完成对/dev/vdb3触发挂载的配置
  最终实现:访问路径/nsd/dc  挂载设备/dev/vdb3 到/nsd/dc
   
  主配置文件:定义监控目录/etc/auto.master
   格式:监控目录路径    挂载配置文件路径

  挂载配置文件:定义挂载点目录与设备  
 cd      -fstype=iso9660,ro,nosuid,nodev :/dev/cdrom
  挂载点目录    -fstype=文件系统    :挂载设备

[root@server0 /]# mkdir /nsd     #必须手动创建监控目录
[root@server0 /]# vim /etc/auto.master
       /nsd              /etc/test
        格式:监控目录路径       挂载配置文件路径

[root@server0 /]# cp /etc/auto.misc /etc/test 
[root@server0 /]# vim /etc/test    #修改挂载配置文件
  dc            -fstype=xfs      :/dev/vdb3
  格式: 挂载点目录    -fstype=文件系统    :挂载设备

[root@server0 /]# systemctl restart autofs
[root@server0 /]# systemctl status autofs #查看服务状态
[root@server0 /]# ls /nsd/dc
[root@server0 /]# df -h
#################################################
         

                Services

date 1
构建新的教学环境
1.构建两台虚拟机,操作系统为CentOS7.5
[student@room9pc01 ~]$ clone-vm7 
Enter VM number: 8
Creating Virtual Machine disk image......	[OK]
Defining new virtual machine......	[OK]
[student@room9pc01 ~]$ clone-vm7 
Enter VM number: 9
Creating Virtual Machine disk image......	[OK]
Defining new virtual machine......	[OK]

#修改两台虚拟机名为A与B

2.利用root进入两台虚拟机,密码为:123456

3.配置永久主机名                                         
    虚拟机A:svr7.tedu.cn
    虚拟机B:pc207.tedu.cn

4.配置IP地址
    虚拟机A:为eth0配置 192.168.4.7/24
    虚拟机B:为eth0配置 192.168.4.207/24

5.利用真机进行远程管理两台虚拟机
[student@room9pc01 ~]$ ping 192.168.4.7
[student@room9pc01 ~]$ ping 192.168.4.207

[student@room9pc01 ~]$ ssh -X root@192.168.4.7
[student@room9pc01 ~]$ ssh -X root@192.168.4.207

6.为真机上设置永久别名
[student@room9pc01 ~]$ vim /home/student/.bashrc 
 alias goa='ssh  -X  root@192.168.4.7'
 alias gob='ssh  -X  root@192.168.4.207'

 新开一个终端验证

7.构建Yum仓库

服务端:真机构建FTP服务器,共享光盘所有内容
 1)真机检测软件包vsftpd的安装
 [student@room9pc01 ~]$ rpm -q vsftpd
 vsftpd-3.0.2-22.el7.x86_64
 [student@room9pc01 ~]$ systemctl status vsftpd
 2)共享光盘所有内容
    默认共享的路径:/var/ftp
 ]$ mkdir /var/ftp/centos-1804/
 ]$ mount /iso/CentOS7-1804.iso   /var/ftp/centos-1804/
 ]$ ls /var/ftp/centos-1804/
 ]$ vim /etc/fstab 
/var/lib/libvirt/images/iso/CentOS7-1804.iso  /var/ftp/centos-1804 iso9660 defaults 0 0
 ]$ firefox ftp://192.168.4.254/centos-1804

客户端:两台虚拟机
[root@svr7 ~]# vim /etc/yum.repos.d/local.repo
[local_repo]
name=CentOS-$releasever - Base
baseurl="ftp://192.168.4.254/centos-1804"
enabled=1
gpgcheck=0
[root@svr7 ~]# yum -y install httpd

#####################################################
虚拟机C
 1.配置主机名为:svr10.tedu.cn
 2.配置eth0的IP地址:192.168.4.10/24
 3.配置Yum仓库,指向服务端为真机的FTP服务

虚拟机D
 1.配置主机名为:pc20.tedu.cn
 2.配置eth0的IP地址:192.168.4.20/24
 3.配置Yum仓库,指向服务端为真机的FTP服务

##################################################
扩展的几个应用
目录结构
• 认识Linux的目录层次:               
– man hier

• 常见一级目录的用途
	/boot 存放系统引导必需的文件,包括内核、启动配置
	/bin、/sbin 存放各种命令程序
	/dev 存放硬盘、键盘、鼠标、光驱等各种设备文件
	/etc 存放Linux系统及各种程序的配置文件
	/root、/home/用户名 分别是管理员root、普通用户的默认家目录
	/var 存放日志文件、邮箱目录等经常变化的文件
	/proc 存放内存中的映射数据,不占用磁盘
	/tmp 存放系统运行过程中使用的一些临时文件
[root@svr7 ~]# ls -ld /tmp
drwxrwxrwt. 8 root root 172 7月  15 10:34 /tmp

权限的数值表示
• 权限的数值化
– 基本权限:r = 4,w = 2,x = 1
– 附加权限:SUID = 4,SGID = 2,Sticky Bit = 1 

[root@svr7 ~]# mkdir /nsd01
[root@svr7 ~]# ls -ld /nsd01
[root@svr7 ~]# chmod 750 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 700 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 007 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 755 /nsd01
[root@svr7 ~]# ls -ld /nsd01


历史命令
• 管理/调用曾经执行过的命令
– history:查看历史命令列表
– history -c:清空历史命令
– !n:执行命令历史中的第n条命令
– !str:执行最近一次以str开头的历史命令

• 调整历史命令的数量
[root@svr7 ~]# vim /etc/profile
HISTSIZE=1000  //默认记录1000条

[root@svr7 ~]# history        #显示历史命令列表
[root@svr7 ~]# history -c     #清空所有的历史命令
[root@svr7 ~]# history 
    1  history 
[root@svr7 ~]# cat -n /etc/redhat-release  
[root@svr7 ~]# ls /root/
[root@svr7 ~]# cat /etc/hosts

[root@svr7 ~]# history 
[root@svr7 ~]# !cat    #执行临时命令中最近以cat开头的命令
[root@svr7 ~]# !ls


实用小命令工具
• du,统计文件的占用空间
– du [选项]... [目录或文件]...
– -s:只统计每个参数所占用的总空间大小
– -h:提供易读容量单位(K、M等)

[root@svr7 ~]# du   -sh  /root
[root@svr7 ~]# du   -sh  /root/  /etc/  /boot/
[root@svr7 ~]# du   -sh  /

[root@svr7 ~]# du   -sh  /var

[root@svr7 ~]# du   -sh  /home
[root@svr7 ~]# du   -sh  /tmp


• date,查看/调整系统日期时间
– date +%F、date +%R
– date +"%Y-%m-%d %H:%M:%S"
– date -s "yyyy-mm-dd HH:MM:SS"

[root@svr7 ~]# date +%F   #显示  年-月-日
2019-07-15
[root@svr7 ~]# date +%Y   #显示 年
2019
[root@svr7 ~]# date +%m   #显示 月
07
[root@svr7 ~]# date +%d   #显示 日期
15
[root@svr7 ~]# date +%H   #显示 时
11
[root@svr7 ~]# date +%M   #显示 分
42
[root@svr7 ~]# date +%S   #显示 秒
####################################################

制作快捷方式    制作连接(链接)文件

制作软连接
格式: ln  -s  /路径/源文件   /路径/快捷方式名     #必须时绝对路径

]# cat /etc/sysconfig/network-scripts/ifcfg-eth0
]# ln -s /etc/sysconfig/network-scripts/ifcfg-eth0   /etc/net0

]# ls /etc/net0 
]# cat /etc/net0
]# ls -l /etc/net0

]# ln -s /etc/passwd  /opt/
]# ls /opt/
]# ls -l /opt/passwd 

软连接特点:
若原始文件或目录被删除,连接文件将失效
软连接可存放在不同分区/文件系统

硬连接特点:
若原始文件被删除,连接文件仍可用
硬连接与原始文件必须在同一分区/文件系统

[root@svr7 ~]# rm -rf /opt/*
[root@svr7 ~]# echo 123456 > /opt/A
[root@svr7 ~]# cat /opt/A

[root@svr7 ~]# ln -s  /opt/A  /opt/B   #制作软连接
[root@svr7 ~]# ls /opt/
[root@svr7 ~]# cat /opt/B

[root@svr7 ~]# ln  /opt/A   /opt/C  #制作硬连接
[root@svr7 ~]# ls  /opt/

[root@svr7 ~]# rm -rf /opt/A
[root@svr7 ~]# ls /opt/
[root@svr7 ~]# cat /opt/B   #软连接不可用
[root@svr7 ~]# cat /opt/C   #硬连接可以使用

##################################################
获取命令帮助

[root@svr7 ~]# man 5 passwd  #5代表配置文件类型帮助信息

#################################################
zip归档工具,跨平台的压缩格式
• 归档+压缩操作
– zip [-r] 备份文件.zip 被归档的文档...
[root@svr7 ~]# yum -y install zip
[root@svr7 ~]# zip -r /opt/file.zip  /root/ /etc/passwd
[root@svr7 ~]# ls /opt

[root@svr7 ~]# zip -r /opt/nsd.zip  /boot/
[root@svr7 ~]# ls /opt
• 释放归档+解压操作
– unzip 备份文件.zip [-d 目标文件夹]
[root@svr7 ~]# yum -y install unzip 
[root@svr7 ~]# unzip /opt/nsd.zip -d /mnt/
[root@svr7 ~]# ls /mnt/
[root@svr7 ~]# ls /mnt/boot/

###################################################
自定义Yum源

1.具备从互联网下载一些软件包
[student@room9pc01 ~]$ ls /linux-soft/01/

2.将tools.tar.gz传递到虚拟机A 
[student@room9pc01 ~]$ scp /linux-soft/01/tools.tar.gz  root@192.168.4.7:/root/

3.在虚拟机A查看                                             
]# ls  /root
]# tar -xf /root/tools.tar.gz  -C  /
]# ls /
]# ls /tools/
]# ls /tools/other/

4.在虚拟机A生成仓库数据文件
[root@svr7 ~]# yum -y install createrepo
[root@svr7 ~]# createrepo /tools/other/

[root@svr7 ~]# ls /tools/other/
[root@svr7 ~]# ls /tools/other/repodata

5.书写客户端配置文件
[root@svr7 ~]# vim /etc/yum.repos.d/local.repo 
[local_repo]
name=CentOS-$releasever - Base
baseurl="ftp://192.168.4.254/centos-1804"
enabled=1
gpgcheck=0
[myrpm]
name=other rpm
baseurl=file:///tools/other  #指定为本机为Yum服务端
enabled=1
gpgcheck=0
[root@svr7 ~]# yum repolist 

[root@svr7 ~]# yum -y install cmatrix
[root@svr7 ~]# cmatrix
[root@svr7 ~]# cmatrix -C red

[root@svr7 ~]# yum -y install sl
[root@svr7 ~]# sl

[root@svr7 ~]# yum -y install oneko
[root@svr7 ~]# oneko
[root@svr7 ~]# oneko &   #将程序放入后台

################################################
vim编辑技巧
命令模式操作
[root@svr7 ~]# cp /etc/passwd  /opt/a.txt  
[root@svr7 ~]# vim /opt/a.txt 
               vim +n /opt/a.txt  //光标定位在第n行
                   在末行模式下输入:n 光标定义在第n行 
光标跳转
	Home 键 或 ^、数字 0 	跳转到行首
	End 键 或“$”键 			跳转到行尾
	PgUp 键、PgDn 键 		向上翻页、向下翻页
	1G 或 gg 				跳转到文件的首行
	G 					跳转到文件的末尾行
复制/粘贴/删除
	复制 yy、3yy 			复制光标处的一行、3行
	粘贴 p、P 			粘贴到光标处之后、之前
	x 或 Delete键                  删除光标处后的单个字符
      X                         删除光标处前的单个字符
	dd、#dd 				删除光标处的一行、#行
	d^ 					从光标处之前删除至行首
	d$或D(大写) 			从光标处删除到行尾
	C(大写) 				从光标处删除到行尾,进入插入模式

查找/撤销/保存
	/word 		向后查找字符串“word”
	n、N 		跳至后/前一个结果
	u 			撤销最近的一次操作
	U(大写) 		撤销对当前行的所有修改
	Ctrl + r 	取消前一次撤销操作
	ZZ(大写) 		保存修改并退出
##################################################
末行模式操作

    :r /etc/filesystems 读入其他文件内容

[root@svr7 ~]# echo 123456 > /opt/2.txt
[root@svr7 ~]# echo hahaxixi > /opt/3.txt
[root@svr7 ~]# vim /opt/3.txt
         :r  /opt/2.txt    #读入/opt/2.txt到当前文件
         :r  /etc/passwd   #读入/etc/passwd到当前文件


字符串替换
	:s/root/admin	替换当前行第一个“root”
	:s/root/admin/g 	替换当前行所有的“root”
	:1,10 s/root/admin/g 	替换第1-10行所有的“root”
	:% s/root/admin/g 	替换文件内所有的“root
[root@svr7 ~]# cat /etc/passwd > /opt/a.txt 
[root@svr7 ~]# vim /opt/a.txt


开关参数的控制

	:set nu或nonu  显示/不显示行号
	:set ai或noai  启用/关闭自动缩进
#################################################
源码编译安装

RPM包: rpm -ivh  yum -y install

源码包----gcc make---->可以执行的程序-------->运行安装

• 主要优点
– 获得软件的最新版,及时修复bug
– 软件功能可按需选择/定制,有更多软件可供选择     
– 源码包适用各种平台

                                                          
步骤一:安装gcc与make开发工具
[root@svr7 ~]# yum -y install gcc
[root@svr7 ~]# yum -y install make
步骤二:进行tar解包
]# tar -xf /tools/inotify-tools-3.13.tar.gz -C /
]# ls /
]# cd /inotify-tools-3.13/
]# ls
步骤三:运行configure脚本
           作用1:检测是否安装gcc
           作用2:可以选择软件的功能,也可以指定软件安装的路径
      --prefix=指定安装的位置
]# cd /inotify-tools-3.13/
]# ./configure   --prefix=/opt/myrpm


常见提示:没有安装gcc
checking for gcc... no
checking for cc... no
checking for cl.exe... no
configure: error: no acceptable C compiler found in $PATH
See `config.log' for more details.

步骤四:make编译生成可以执行的程序
]# cd /inotify-tools-3.13/
]# make

步骤五:make install将可以执行的程序运行安装
]# cd /inotify-tools-3.13/
]# make  install
]# ls /opt/
]# ls /opt/myrpm/
]# ls /opt/myrpm/bin/

##################################################

date 2

一 手动图形安装虚拟机名为nsd01
    利用光盘镜像安装
    内存2048M 
    虚拟机名为:nsd01
    网络类型选择为:private1
    
    软件包:带GUI的服务器
    分区:自动分区
    设置root的密码为1,建立lisi用户设置密码1


虚拟化概述
• virtualization 资源管理
– x个物理资源 --> y个逻辑资源
– 实现程度:完全、部分、硬件辅助(CPU)

CPU支持虚拟化所有的指令集(vmx)
[student@room9pc01 ~]$ lscpu  | grep vmx


• 虚拟化主要厂商及产品
  VMware  VMware Workstation、vSphere
  Microsoft VirtualPC、Hyper-V
  RedHat  KVM、RHEV
  Citrix  Xen
  Oracle  Oracle VM VirtualBox

###################################################
二 虚拟机nsd01进行配置                                
1.配置永久主机名:kvm.tedu.cn
[root@localhost ~]# echo kvm.tedu.cn > /etc/hostname
[root@localhost ~]# hostname kvm.tedu.cn

2.配置永久IP地址:192.168.4.30/24
[root@localhost ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.30/24 connection.autoconnect yes

[root@localhost ~]# nmcli connection up eth0 
[root@localhost ~]# ifconfig

3.修改防火墙默认区域与SELinux
[root@kvm ~]# firewall-cmd --set-default-zone=trusted 

[root@kvm ~]# setenforce 0
[root@kvm ~]# getenforce 
Permissive
[root@kvm ~]# vim /etc/selinux/config
SELINUX=permissive

4.构建Yum仓库
]# cd /etc/yum.repos.d/
]# mkdir repo
]# ls
]# mv *.repo  repo
]# ls
]# vim dvd.repo
 [dvd]
 name=centos7
 baseurl=ftp://192.168.4.254/centos-1804
 enabled=1
 gpgcheck=0
]#  yum  repolist
]#  yum -y install xeyes

##################################################
安装虚拟化服务器平台
• 主要软件包
– qemu-kvm :为 kvm 提供底层仿真支持
– libvirt-daemon :libvirtd 守护进程,管理虚拟机
– libvirt-client :用户端软件,提供客户端管理命令
– libvirt-daemon-driver-qemu :libvirtd 连接 qemu 的驱动
– virt-manager :图形管理工具

]#  yum -y install qemu-kvm
]#  yum -y install libvirt-daemon
]#  yum -y install libvirt-client
]#  yum -y install libvirt-daemon-driver-qemu
]#  yum -y install virt-manager

虚拟化服务: libvirtd
[root@kvm /]# systemctl status libvirtd  #查看服务的状态
####################################################
三 通过命令管理虚拟机
virsh命令工具介绍
• 提供管理各虚拟机的命令接口
– 支持交互模式,查看/创建/停止/关闭 .. ..
– 格式:virsh 控制指令 [虚拟机名称] [参数]

• 查看KVM节点(服务器)信息
]$ virsh nodeinfo
• 列出虚拟机
]$ virsh list [--all]    #重点
• 列出虚拟网络
]$ virsh net-list [--all]
• 查看指定虚拟机的信息
]$ virsh dominfo 虚拟机名称     #重点
]$ virsh autostart nsd01    #设置虚拟机开机自启动
]$ virsh dominfo  nsd01
]$ virsh autostart --disable nsd01  #禁止虚拟机开机自启动
]$ virsh dominfo  nsd01
• 开关机操作
]$ virsh start或reboot或shutdown 虚拟机名称    #重点
• 强制关闭指定的虚拟机
]$ virsh destroy 虚拟机名称    #重点
]$ virt-manager  列出虚拟机图形管理器
#################################################
• 一台KVM虚拟机的组成               

– xml配置文件(虚拟机描述文件):定义虚拟机的名称、UUID、CPU、内
存、虚拟磁盘、网卡等各种参数设置
[student@room9pc01 ~]$ ls /etc/libvirt/qemu/

– 磁盘镜像文件:保存虚拟机的操作系统及文档数据,
镜像路径取决于xml配置文件中的定义
[student@room9pc01 ~]$ ls /var/lib/libvirt/images/


##################################################
查看虚拟机xml文件内容
[student@room9pc01 /]$ virsh dumpxml nsd01   
  虚拟机名称 
  虚拟机的UUID唯一标识
  虚拟机磁盘文件路径
      <source file='/var/lib/libvirt/images/nsd01.qcow2'/>
  虚拟机网卡信息
<interface type='network'>
      <mac address='52:54:00:d4:fe:59'/>

[student@room9pc01 /]$ virsh dumpxml nsd01 | less
##################################################
在命令行手动制作一台虚拟机
1.磁盘镜像文件
]$ cd /var/lib/libvirt/images/
]$ du -sh .node_base.qcow2

]$ cp  .node_base.qcow2      nsd02.qcow2
]$ du -sh nsd02.qcow2 

2.建立新的xml配置文件, uuidgen可以生成随机的UUID值
]$ cd /etc/libvirt/qemu/
]$ virsh dumpxml nsd01 > /etc/libvirt/qemu/nsd02.xml

]$ vim  /etc/libvirt/qemu/nsd02.xml
  1)虚拟机名称   <name>nsd02</name>
  2)虚拟机的UUID唯一标识   删除整行内容  UUID
  3)虚拟机磁盘文件路径   <source file='/var/lib/libvirt/images/nsd02.qcow2'/>
  4)虚拟机网卡信息
      <mac address='52:54:00:d4:fe:59'/> 删除整行内容
3.导入虚拟机配置信息
]$ virsh  define /etc/libvirt/qemu/nsd02.xml 
]$ virsh  list --all
]$ virsh  start  nsd02
#################################################
命令行删除虚拟机
]$ virsh list --all
]$ virsh destroy nsd02    #强制关闭虚拟机
域 nsd02 被删除

]$ virsh list --all
]$ virsh undefine nsd02   #删除虚拟机xml配置文件
域 nsd02 已经被取消定义

]$ virsh list --all
]$ rm -rf /var/lib/libvirt/images/nsd02.qcow2  #手动删除

##################################################
在命令行手动创建虚拟机
1.建立新的磁盘文件
]$ cp  /var/lib/libvirt/images/.node_base.qcow2  /tmp/nsd03.qcow2

]$ du -sh /tmp/nsd03.qcow2

2.建立xml配置文件
]$ virsh dumpxml nsd01 > /home/student/nsd03.xml
]$ ls /home/student/nsd03.xml 

]$ vim  /home/student/nsd03.xml
  1)虚拟机名称   <name>nsd03</name>
  2)虚拟机的UUID唯一标识   删除整行内容  UUID
  3)虚拟机磁盘文件路径  <source file='/tmp/nsd03.qcow2'/>
  4)虚拟机网卡信息
      <mac address='52:54:00:d4:fe:59'/> 删除整行内容
3.导入虚拟机配置信息
]$ ls /etc/libvirt/qemu
]$ virsh  define /home/student/nsd03.xml  #导入虚拟机信息
]$ ls /etc/libvirt/qemu
]$ virsh  start  nsd03
]$ virsh  list
#####################################################
三合一:导出 修改 导入
• 对虚拟机的配置进行调整
– 编辑:virsh edit 虚拟机名
1.建立磁盘文件
]$ cp /var/lib/libvirt/images/.node_base.qcow2  /var/lib/libvirt/images/nsd04.qcow2
                                                                                                                                                                                                                       
]$ du -sh /var/lib/libvirt/images/nsd04.qcow2
      
2.建立xml配置文件
[student@room9pc01 /]$ virsh edit nsd01
  1)虚拟机名称   <name>nsd04</name>
  2)虚拟机的UUID唯一标识   删除整行内容  UUID
  3)虚拟机磁盘文件路径  <source file='/var/libvirt/images/nsd04.qcow2'/>
  4)虚拟机网卡信息
      <mac address='52:54:00:d4:fe:59'/> 删除整行内容

[student@room9pc01 /]$ virsh list --all
#################################################
常用镜像盘类型                                              
• 虚拟机的磁盘镜像文件格式                             
	特点\类型		 RAW 	QCOW2
	KVM默认 		 否 		是
	I/O效率 		 高 		较高
	占用空间 		 大 		小
	压缩		 	 不支持 	支持
	后端盘复用 	         不支持 	支持
	快照 			 不支持 	支持

查看磁盘镜像文件信息
]$ qemu-img info /var/lib/libvirt/images/nsd04.qcow2 
 virtual size: 2.0G (2147483648 bytes)  #虚拟大小
 disk size: 633M   #实际占用空间

#################################################
COW技术原理
• Copy On Write,写时复制
– 直接映射原始盘的数据内容
– 当原始盘的旧数据有修改时,在修改之前自动将旧数据存入前端盘
– 对前端盘的修改不回写到原始盘
– 原始盘的数据不能做修改

快速创建qcow前端盘
• qemu-img 通过 -b  选项复用指定原始盘
– qemu-img create -f  qcow2  -b 原始盘   前端盘   大小

1.命令手动创建虚拟机磁盘文件                   
]$ cd /var/lib/libvirt/images/
]$ qemu-img create  -f  qcow2  -b .node_base.qcow2  nsd05.qcow2 5G    #通过原始盘产生前端盘

]$ qemu-img info nsd05.qcow2      #查看虚拟磁盘文件信息
virtual size: 5.0G (5368709120 bytes) #虚拟大小
disk size: 196K                       #实际占用空间大小
backing file: .node_base.qcow2   #原始盘

2.建立xml文件
]$ virsh dumpxml nsd01 > /tmp/nsd05.xml #导出虚拟机信息
]$ vim /tmp/nsd05.xml #修改 虚拟机名  UUID  磁盘路径   网卡MAC
]$ virsh define  /tmp/nsd05.xml

##################################################
离线访问虚拟机
• 使用 guestmount 工具
– 支持离线挂载 raw、qcow2 格式虚拟机磁盘
– 可以在虚拟机关机的情况下,直接修改磁盘中的文档
– 方便对虚拟机定制、修复、脚本维护
  
]$ virsh destroy nsd01
]$ guestmount -a /var/lib/libvirt/images/nsd01.qcow2 -i   /mnt/

##################################################
   date 03

• DNS服务器的功能
– 正向解析:根据注册的域名查找其对应的IP地址
– 反向解析:根据IP地址查找对应的注册域名,不常用


域名结构:  树型结构
   所有的域名都必须以点结尾
    www.qq.com.   www.baidu.com.

根域名:                    .


一级域名:    .cn    .us    .kr   .tw   .hk  .jp  .......


二级域名:  .com.cn    .tedu.cn   .net.cn  .org.cn ......


三级域名:  nb.com.cn   dc.com.cn   tc.com.cn ........


完全合格的域名(FQDN)=主机头部+注册的域名
Full Qualified Domain Name,完全合格主机名
###################################################
– 系统服务:named
– 默认端口:TCP/UDP 53
– 运行时的虚拟根环境:/var/named/chroot/

• 主配置文件:/etc/named.conf      #本机负责解析的域名 
• 地址库文件存放路径:/var/named/   #域名的解析结果
 
构建基本DNS服务
虚拟机A:
1.安装软件包
[root@svr7 ~]# yum -y install  bind-chroot   bind
 bind-9.9.4-29.el7.x86_64  //域名服务包
 bind-chroot-9.9.4-29.el7.x86_64  //提供虚拟根支持,牢笼
 
2.修改主配置文件      
[root@svr7 ~]# cp  /etc/named.conf  /etc/named.bak
[root@svr7 ~]# vim  /etc/named.conf
 options {
        directory       "/var/named";  #指定地址库文件位置
 };
 zone "tedu.cn" IN {      #设置本机负责的域名
	type master;          #设置本机为权威主DNS服务器
	file "tedu.cn.zone";  #设置地址库文件名称
 };
3.建立地址库文件tedu.cn.zone
]# cd /var/named/
]# cp -p named.localhost tedu.cn.zone  #-p保持权限不变
]# ls -l tedu.cn.zone
]# vim tedu.cn.zone                    
 所有的域名在地址库文件必须以点结尾
 当没有以点结尾时,自动补全地址库负责的域名

 tedu.cn.        NS      svr7        #声明区域DNS服务器
 svr7            A       192.168.4.7 #声明DNS服务器IP地址
 www             A       1.1.1.1    #常规DNS正向解析
 ftp             A       2.2.2.2
[root@svr7 /]# systemctl restart named
虚拟机B:客户端验证
]# echo nameserver 192.168.4.7  >  /etc/resolv.conf 
]# cat /etc/resolv.conf

]# nslookup  www.tedu.cn
]# nslookup  ftp.tedu.cn
0###################################################
多域名的DNS服务器,负责解析qq.com域名
虚拟机A:
1.修改主配置文件
[root@svr7 /]# vim  /etc/named.conf 
options {
        directory       "/var/named";
};
zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
};
zone "qq.com" IN {
        type master;
        file "qq.com.zone";
};
[root@svr7 /]# cd /var/named/
[root@svr7 named]# cp -p tedu.cn.zone qq.com.zone
[root@svr7 named]# vim qq.com.zone
 qq.com. 	NS	 svr7
 svr7     	A    192.168.4.7
 www         A    3.3.3.3
[root@svr7 named]# systemctl  restart  named

###############################################
特殊解析记录
1.基于DNS解析记录负载均衡
[root@svr7 /]# vim /var/named/tedu.cn.zone  
tedu.cn.        NS      svr7
svr7            A       192.168.4.7
www             A       192.168.4.10
www             A       192.168.4.20
www             A       192.168.4.30
ftp             A       2.2.2.2
[root@svr7 /]# systemctl restart named

2.泛域名解析
虚拟机A
[root@svr7 /]# vim /var/named/tedu.cn.zone 
tedu.cn.        NS      svr7
svr7            A       192.168.4.7
www             A       192.168.4.10
ftp             A       2.2.2.2
*               A       1.2.3.4
[root@svr7 /]# systemctl  restart  named

虚拟机B:测试  nslookup  haha.tedu.cn

3.解析记录的别名
虚拟机A:
[root@svr7 /]# vim /var/named/tedu.cn.zone
tedu.cn.        NS      svr7
svr7            A       192.168.4.7
www             A       192.168.4.10
ftp             A       2.2.2.2
*               A       1.2.3.4
mail            CNAME   ftp

[root@svr7 /]# systemctl restart named

虚拟机B测试:
[root@pc207 ~]# nslookup mail.tedu.cn

4.有规律的泛域名解析

      pc1.tedu.cn -----> 192.168.10.1
      pc2.tedu.cn -----> 192.168.10.2
      pc3.tedu.cn -----> 192.168.10.3
      pc4.tedu.cn -----> 192.168.10.4
          .......
      pc50.tedu.cn -----> 192.168.10.50

 内置函数:$GENERATE  制造连续范围的数字
虚拟机A
[root@svr7 ~]# vim /var/named/tedu.cn.zone  

 $GENERATE 1-50   pc$   A   192.168.10.$
[root@svr7 ~]# !sys
systemctl restart named
[root@svr7 ~]# 

虚拟机B测试:
[root@pc207 ~]# nslookup pc1.tedu.cn
[root@pc207 ~]# nslookup pc2.tedu.cn
[root@pc207 ~]# nslookup pc3.tedu.cn

##################################################
DNS资源解析记录有哪些?
  正向解析记录(A记录)
 DNS声明记录(NS记录)
  解析记录的别名(CNAME记录)
###################################################
DNS子域授权
 
     父域:qq.com 由虚拟机A进行解析
     子域:bj.qq.com 由虚拟机B进行解析

虚拟机B,构建DNS服务器,负责解析bj.qq.com
[root@pc207 ~]# yum -y install bind bind-chroot
[root@pc207 ~]# cp /etc/named.conf /etc/named.bak
[root@pc207 ~]# vim /etc/named.conf 
options {
        directory       "/var/named";
};
zone "bj.qq.com" IN {
        type master;
        file "bj.qq.com.zone";
};
[root@pc207 ~]# cd /var/named/
[root@pc207 named]# cp -p named.localhost bj.qq.com.zone
[root@pc207 named]# vim bj.qq.com.zone
bj.qq.com. NS   pc207
pc207      A    192.168.4.207
www        A    50.60.70.80
[root@pc207 /]# systemctl restart named
[root@pc207 /]# nslookup www.bj.qq.com 192.168.4.207
[root@pc207 /]# nslookup www.qq.com 192.168.4.7

################################################
子域授权: 让父域的DNS服务器知晓子域DNS服务器
              让父域的DNS服务器可以解析子域的域名

虚拟机A:                                   
[root@svr7 ~]# vim /var/named/qq.com.zone 
qq.com.         NS      svr7
bj.qq.com.      NS      pc207
svr7            A       192.168.4.7
pc207           A       192.168.4.207
www             A       3.3.3.3
[root@svr7 ~]# systemctl restart named

[root@pc207 /]# nslookup www.bj.qq.com 192.168.4.7
Server:		192.168.4.7
Address:	     192.168.4.7#53

Non-authoritative answer:   #非权威解答
Name:	www.bj.qq.com
Address: 50.60.70.80

##################################################
递归解析: 
   由客户端发出请求,首选DNS服务器接受请求,将解析结果带回过程
[root@svr7 ~]# vim /etc/named.conf 
options {
        directory       "/var/named";
        recursion no;    #禁止递归解析:
};

迭代解析:首选DNS服务器与其他DNS服务器交互过程
专业测试DNS工具
[root@pc207 /]# dig www.bj.qq.com 192.168.4.7

#################################################
 主机名映射文件:/etc/hosts                            
      没有DNS服务器前提下,解析域名,只能为本机做域名解析
        
[root@svr7 ~]# vim  /etc/hosts
192.168.4.110   www.nb.com

[root@svr7 ~]# ping www.nb.com

域名解析过程中最高优先级为/etc/hosts   匹配即停止
然后在读取/etc/resolv.conf
#################################################
缓存DNS,缓存解析结果,加快解析过程         

三个角色:客户端    缓存DNS服务    真DNS服务器

虚拟机A:真DNS服务器
虚拟机B:缓存DNS服务
虚拟机C:客户端 
1.建立虚拟机C
   配置IP地址192.168.4.10/24,主机名为svr10.tedu.cn
虚拟机B:缓存DNS服务
[root@pc207 /]# vim /etc/named.conf 
options {
      directory       "/var/named";
      forwarders { 192.168.4.7; }; #转发给虚拟机A的IP地址
};
[root@pc207 /]# systemctl restart named
虚拟机C上验证:
[root@svr10 ~]# nslookup www.tedu.cn 192.168.4.207
  
DNS主/从结构: 备份 解决单点故障
                首选DNS服务器
                备用DNS服务器
虚拟机A :构建主DNS服务器
1 修改主配置文件,允许虚拟机B进行同步数据
DNS主/从结构:备份  解决单点故障

以qq.com域名为例
  虚拟机A为主DNS服务器（首选DNS服务器）
  虚拟机B为从DNS服务器（备用DNS服务器）

虚拟机A：构建主DNS服务器
1.修改主配置文件，允许虚拟机B进行同步数据
[root@svr7 /]# man named.conf      #查看man帮助信息
[root@svr7 /]# vim /etc/named.conf 
options {
   directory       "/var/named";
   allow-transfer { 192.168.4.207; }; #允许从服务器同步数据
};
zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
};
zone "qq.com" IN {
        type master;
        file "qq.com.zone";
};

2.在地址库文件中，声明从服务器的IP地址
[root@svr7 /]# vim /var/named/qq.com.zone 

 qq.com.      NS  svr7         #声明DNS服务器
 qq.com.      NS  pc207        #声明DNS服务器
 svr7         A   192.168.4.7
 pc207        A   192.168.4.207
 www          A   3.3.3.10
 ftp          A   4.4.4.4

3.重起named服务
[root@svr7 /]# systemctl restart named


虚拟机B构建为从DNS服务器（备用DNS服务器）
  地址库文件不需要自己创建，地址库文件是从主DNS服务器进行同步
1.安装软件包bind bind-chroot
[root@pc207 /]# yum -y install bind bind-chroot

2.修改主配置文件
[root@pc207 /]# vim /etc/named.conf 
 options {
        directory       "/var/named";
  };
  zone "qq.com" IN {
        type slave;                  #类型为从服务器
        file "slaves/qq.com.slave";
        masters  {  192.168.4.7;  };  #指定主服务器位置
  };
  #将备份数据起名为qq.com.slave，存放在/var/named/slaves
 #slaves目录默认named用户对其拥有rwx权限

[root@pc207 /]# ls /var/named/slaves/
[root@pc207 /]# systemctl restart named
[root@pc207 /]# ls /var/named/slaves/  #验证同步数据
qq.com.slave
[root@pc207 /]# 

虚拟机C：客户端验证
]# echo nameserver 192.168.4.7 > /etc/resolv.conf 
]# echo nameserver 192.168.4.207 >> /etc/resolv.conf 
]# cat /etc/resolv.conf
nameserver 192.168.4.7      #首选DNS服务器
nameserver 192.168.4.207    #备用DNS服务器

]#  nslookup www.qq.com

###################################################
数据更新,一定要在主DNS服务器完成
虚拟机A：
[root@svr7 /]# vim /var/named/qq.com.zone
                                         
  2019082001 ; serial  #数据的版本号格式：年月日次数  10位组成
     1D      ; refresh #主与从同步数据时间
     1H      ; retry   #失连后同步数据的时间
     1W      ; expire  #完全失效时间
     3H )    ; minimum #无效记录  记忆时间


 每次数据更新，数据的版本号必须要变大
 数据的版本号：主与从数据同步时，唯一标准

##############################################

##################################################


        date 04


虚拟机A:构建DNS服务器,实现www.sina.com的解析结果为10.20.30.40
1.修改主配置文件
[root@svr7 named]# vim /etc/named.conf 
options {
        directory       "/var/named";
        recursion no;
};
zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
};
zone "qq.com" IN {
        type master;
        file "qq.com.zone";
};
zone "sina.com" IN {
        type master;
        file "sina.com.zone";
};
2.建立地址库文件
[root@svr7 named]# cd /var/named/
[root@svr7 named]# cp -p qq.com.zone sina.com.zone
[root@svr7 named]# vim /var/named/sina.com.zone 
sina.com.       NS      svr7
svr7            A       192.168.4.7
www             A       10.20.30.40

[root@svr7 named]# systemclt  restart named

####################################################
Split分离解析(视图解析)
什么是分离解析
• 当收到客户机的DNS查询请求的时候
– 能够区分客户机的来源地址
– 为不同类别的客户机提供不同的解析结果
– 不同客户端解析同一个域名,解析结果不同
– 作用:为客户端就近提供服务器

BIND的view视图
• 根据源地址集合将客户机分类
    由上到下匹配及停止,所有的客户端都要找到自己的分类   
    所有的zone都必须在view中

  view  "nsd"  {
  match-clients  { 192.168.1.1; };  #匹配客户机来源地址	  
  zone "12306.cn" IN {
    ...... 地址库文件12306.zone;
    }; };                                                         
  view  "abc"  {
  match-clients { 192.168.2.1; };
  zone "12306.cn" IN {
    ...... 地址库文件12306.abc;
    }; };
  view  "other"  {
  match-clients { any; };
  zone "12306.cn" IN {
    ...... 地址库文件12306.other;
    }; };
###################################################
案例需求及要点
• 环境及需求
– 权威DNS:svr7.tedu.cn 192.168.4.7
– 负责区域:tedu.cn
– A记录分离解析 —— 以 www.tedu.cn 为例
客户机来自 解析结果
	192.168.4.207-----> 192.168.4.100
	其他地址 -----> 1.2.3.4

[root@svr7 /]# vim /etc/named.conf 
options {
        directory       "/var/named";
};
view "nsd" {                            #分类名称
  match-clients  {  192.168.4.207;  };  #匹配客户机来源地址
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";---->解析结果写192.168.4.100
  };
};
view "other" {
  match-clients  {  any;  };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other";---->解析结果写1.2.3.4
  };
};
 建立地址库文件tedu.cn.zone与tedu.cn.other写入不同的解析结果

#############################################################
多个域名的分离解析,每一个view中zone个数保持一致
– A记录分离解析 —— 以 www.tedu.cn 为例
– A记录分离解析 —— 以 www.sina.com 为例
客户机来自 解析结果
	192.168.4.207-----> 192.168.4.100
	其他地址 -----> 1.2.3.4

view "nsd" {
  match-clients  { 192.168.4.207;  };                  
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone"; -------> 解析结果为192.168.4.100
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.zone"; -------> 解析结果为192.168.4.100
  };
};
view "other" {
  match-clients  { any;  };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other"; -------> 解析结果为1.2.3.4
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.other"; -------> 解析结果为1.2.3.4
  };
};
#####################################################
扩展:
– A记录分离解析 —— 以 www.tedu.cn 为例
– A记录分离解析 —— 以 www.sina.com 为例
客户机来自 解析结果
	192.168.4.207---www.tedu.cn--> 192.168.4.100
	192.168.4.7---www.sina.com--> 192.168.4.200

	其他地址 --www.tedu.cn---> 1.2.3.4
	其他地址 --www.sina.com---> 1.2.3.4

view "nsd" {
  match-clients  { 192.168.4.207;  };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.other";
  };
};
view "abc" {
  match-clients  { 192.168.4.7;  };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other";
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.zone";
  };
};
view "other" {
  match-clients  {  any;  };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other";
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.other";
  };
};
#####################################################
acl地址列表,类似于变量作用

acl "test" {  192.168.4.207; 192.168.1.1; 192.168.2.1; 192.168.3.1; 192.168.7.0/24; };

view "nsd" {
  match-clients  {  test; };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.other";
  };
};

view "abc" {
  match-clients  {  test; };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.other";
  };
};

####################################################
RAID磁盘阵列

• 廉价冗余磁盘阵列
– 通过硬件/软件技术,将多个较小/低速的磁盘整合成一个大磁盘
– 阵列的价值:提升I/O效率、硬件级别的数据冗余
– 不同RAID级别的功能、特性各不相同
 

  主板—>阵列卡—>磁盘—>操作系统—>数据



• RAID 0,条带模式
– 同一个文档分散存放在不同磁盘
– 并行写入以提高效率
– 至少需要两块磁盘组成

• RAID 1,镜像模式
– 一个文档复制成多份,分别写入不同磁盘
– 多份拷贝提高可靠性,效率无提升
– 至少需要两块磁盘组成

• RAID5,高性价比模式
– 相当于RAID0和RAID1的折中方案
– 需要至少一块磁盘的容量来存放校验数据
– 至少需要三块磁盘组成

• RAID6,高性价比/可靠模式
– 相当于扩展的RAID5阵列,提供2份独立校验方案
– 需要至少两块磁盘的容量来存放校验数据
– 至少需要四块磁盘组成

• RAID 0+1/RAID 1+0
– 整合RAID 0、RAID 1的优势
– 并行存取提高效率、镜像写入提高可靠性
– 至少需要四块磁盘组成
######################################################
进程管理

    程序: 静态的代码   占用磁盘空间
 
    进程: 动态执行的代码   占用CPU 内存
   
     父进程/子进程   树型结构    僵尸进程   孤儿进程
     进程唯一标识: PID 进程的编号

   systemd:上帝进程,所有进程的父进程

查看进程树
• pstree — Processes Tree             15:15上课
– 格式:pstree [选项] [PID或用户名]
• 常用命令选项
– -a:显示完整的命令行
– -p:列出对应PID编号

[root@svr7 /]# pstree
[root@svr7 /]# useradd lisi
[root@svr7 /]# pstree  lisi
bash───vim
[root@svr7 /]# pstree -a lisi
bash
  └─vim a.txt
[root@svr7 /]# pstree -ap lisi


• ps aux 操作,信息全面
– 列出正在运行的所有进程
用户 进程ID %CPU %内存 虚拟内存 固定内存 终端 状态 起始时间 CPU时间 程序指令

• ps -elf 操作,有进程的父进程的PID值
– 列出正在运行的所有进程
   PPID:父进程的PID号

统计正在运行的进程有多少?
[root@svr7 /]# ps aux

[root@svr7 /]# ps aux | wc -l
[root@svr7 /]# ps -elf | wc -l


进程动态排名
• top 交互式工具
– 格式:top [-d 刷新秒数] [-U 用户名]
[root@svr7 /]# top -d 1
  按P(大写)可以进行CPU的排序
  按M(大写)可以进行内存的排序
 load average: 0.00, 0.01, 0.05  #CPU负载量   1分  5分钟  15 分钟

检索进程
• pgrep — Process Grep
– 用途:pgrep [选项]... 查询条件
• 常用命令选项
– -l:输出进程名,而不仅仅是 PID
– -U:检索指定用户的进程
– -x:精确匹配完整的进程名
[root@svr7 /]# pgrep -l a       #检索所有进程名带a的
[root@svr7 /]# pgrep -lU lisi   #检索lisi的所有进程
[root@svr7 /]# pstree -ap lisi  #检索lisi的所有进程

进程的前后台调度

• 后台启动,正在运行放入后台
– 在命令行末尾添加“&”符号,不占用当前终端
• Ctrl + z 组合键
– 挂起当前进程(暂停并转入后台)
• jobs 命令
– 查看后台任务列表
• fg 命令
– 将后台任务恢复到前台运行
• bg 命令
– 激活后台被挂起的任务
[root@svr7 /]# sleep 9000 &   #正在运行放入后台    
[root@svr7 /]# jobs          #查看后台运行的进程
[root@svr7 /]# sleep 8000
^Z            #输入Ctrl+z 暂停放入后台
[2]+  已停止               sleep 8000
[root@svr7 /]# jobs
[root@svr7 /]# bg 2    #将后台编号为2的进程继续运行

[root@svr7 /]# jobs 
[root@svr7 /]# fg 1  #将后台编号为1的进程恢复到前台
sleep 9000 
^C                      #输入Ctrl+C 结束
[root@svr7 /]# jobs
[root@svr7 /]# fg 2   #将后台编号为2的进程恢复到前台
sleep 8000 
^C                       #输入Ctrl+C 结束
[root@svr7 /]# jobs

###################################################
杀死进程
• 干掉进程的不同方法
– Ctrl+c 组合键,中断当前命令程序
– kill [-9] PID... 、kill [-9] %后台任务编号
– killall [-9] 进程名...
– pkill 查找条件
kill 不仅仅是杀死进程的 是给进程发送信号的
kill -l   //查看选项
kill -15(或TERM)  PID号
kill -9(或KILL)  PID号
kill PID   nginx(PID)   //KILL 发信号给nginx你可以去死了
kill -9 PID   nginx(PID)   //KILL 再次发信号给nginx你必须去死了
kill -10(或USR1) PID     //我把你的日志拿走了,你再建个新的日志
kill -19  PID   //暂停进程
kill -18 PID    //恢复进程


[root@svr7 /]# sleep 1000 &
[root@svr7 /]# jobs -l
[root@svr7 /]# kill 4013    #按照PID进行杀死

[root@svr7 /]# sleep 1000 &
[root@svr7 /]# jobs -l
[root@svr7 /]# kill -9 4015  #按照PID强制杀死
[root@svr7 /]# jobs -l

[root@svr7 /]# sleep 1000 &
[root@svr7 /]# sleep 1000 &
[root@svr7 /]# sleep 1000 &
[root@svr7 /]# jobs 

[root@svr7 /]# killall sleep   #杀死所有sleep进程  

杀死一个用户开启的所有进程(强制踢出一个用户)
[root@svr7 /]# killall  -9  -u  用户名

#################################################
日志管理
日志的功能
• 系统和程序的“日记本”
– 记录系统、程序运行中发生的各种事件
– 通过查看日志,了解及排除故障
– 信息安全控制的  依据

• 由系统服务rsyslog统一记录/管理
– 日志消息采用文本格式
– 主要记录事件发生的时间、主机、进程、内容

• 常见的日志文件
 	/var/log/messages 记录内核消息、各种服务的公共消息
	/var/log/dmesg 记录系统启动过程的各种消息
	/var/log/cron 记录与cron计划任务相关的消息
	/var/log/maillog 记录邮件收发相关的消息
	/var/log/secure 记录与访问限制相关的安全消息

日志分析
• 通用分析工具
– tail、tailf、less、grep等文本浏览/检索命令
– awk、sed等格式化过滤工具

tailf:实时跟踪日志消息
[root@svr7 /]# echo 123 > /opt/1.txt
[root@svr7 /]# cat /opt/1.txt
123
[root@svr7 /]# tailf /opt/1.txt
123
################################################
用户登录分析                                               
• users、who、w 命令
– 查看已登录的用户信息,详细度不同

 pts:图形命令行终端

• last、lastb 命令
– 查看最近登录成功/失败的用户信息
[root@svr7 /]# last  -2  #最近登录的2条成功信息
[root@svr7 /]# lastb -2  #最近登录的2条失败信息

[root@svr7 /]# users  #查看已登录的用户信息
[root@svr7 /]# who   #查看已登录的用户信息
[root@svr7 /]# w   #查看已登录的用户信息
###################################################
日志消息的优先级
• Linux内核定义的事件紧急程度
– 分为 0~7 共8种优先级别
– 其数值越小,表示对应事件越紧急/重要

  0  EMERG（紧急）          会导致主机系统不可用的情况
  1  ALERT（警告）          必须马上采取措施解决的问题
  2  CRIT（严重）	        比较严重的情况
  3  ERR（错误）	       运行出现错误
  4  WARNING（提醒）      可能会影响系统功能的事件
  5  NOTICE（注意）        不会影响系统但值得注意
  6  INFO（信息）	       一般信息
  7  DEBUG（调试）          程序或系统调试信息等

使用journalctl工具
• 提取由 systemd-journal 服务搜集的日志
– 主要包括内核/系统日志、服务日志

• 常见用法
– journalctl | grep 关键词
– journalctl -u 服务名   [-p 优先级]
– journalctl -n 消息条数
– journalctl --since="yyyy-mm-dd HH:MM:SS" --
until="yyyy-mm-dd HH:MM:SS"

##################################################
systemctl控制

• Linux系统和服务管理器
– systemd是内核引导之后加载的第一个初始化进程(PID=1)
– 负责掌控整个Linux的运行/服务资源组合

systemd
• 一个更高效的系统&服务管理器
– 开机服务并行启动,各系统服务间的精确依赖
– 配置目录:/etc/systemd/system/
– 服务目录:/lib/systemd/system/
– 主要管理工具:systemctl

对于服务的管理
 systemctl restart  服务名    #重起服务
 systemctl start    服务名    #开启服务
 systemctl stop     服务名    #停止服务
 systemctl status   服务名    #查看服务当前的状态
 
 systemctl enable   服务名      #设置服务开机自启动
 systemctl disable  服务名      #设置服务不开机自启动
 systemctl is-enabled  服务名   #查看是否为开机自启



RHEL6 运行级别    不同级别,开启的服务不同
  
         0：关机    
         1：单用户模式（基本功能的实现，破解Linux密码）
	 2：多用户字符界面（不支持网络）    
	 3：多用户字符界面（支持网络）服务器默认的运行级别   
	 4：未定义
	 5：图形界面   
	 6：重起 
   
    切换运行级别：init  5  



RHEL7 运行模式 

   字符模式：multi-user.target
   图形模式：graphical.target

[student@room9pc01 ~]$ rht-vmctl reset classroom
classroom [OK]
域 classroom 已开始

[student@room9pc01 ~]$ rht-vmctl reset server
server [OK]
域 server 已开始

[root@svr7 /]# ls -l /lib/systemd/system/

当前直接切换到字符模式
]# systemctl isolate multi-user.target   = init 3
当前直接切换到图形模式
]# systemctl isolate graphical.target   = init 5

查看每次开机默认进入模式
[root@svr7 /]# systemctl get-default
multi-user.target

设置永久策略，每次开机自动进入graphical.target
# systemctl set-default graphical.target
# reboot 

#################################################



###################################################
     date5 


DNS分离解析与Web结合
虚拟机C:构建Web服务
[root@svr10 ~]# yum -y install httpd
[root@svr10 ~]# cat /etc/httpd/conf.d/nsd01.conf 
<VirtualHost *:80>
  ServerName www.qq.com
  DocumentRoot /var/www/qq
</VirtualHost>
<VirtualHost *:80>
  ServerName www.163.com
  DocumentRoot /var/www/163
</VirtualHost>
[root@svr10 ~]#
[root@svr10 ~]# mkdir /var/www/qq /var/www/163
[root@svr10 ~]# echo '<h1>Web1 QQ' > /var/www/qq/index.html
[root@svr10 ~]# echo '<h1>Web1 163' > /var/www/163/index.html

[root@svr10 ~]# systemctl restart httpd
##################################################
虚拟机D构建Web服务
[root@pc20 ~]# yum -y install httpd
[root@pc20 ~]# cat /etc/httpd/conf.d/nsd01.conf 
<VirtualHost *:80>
  ServerName www.qq.com
  DocumentRoot /var/www/qq
</VirtualHost>
<VirtualHost *:80>
  ServerName www.163.com
  DocumentRoot /var/www/163
</VirtualHost>
[root@pc20 ~]# mkdir /var/www/qq /var/www/163
[root@pc20 ~]# echo '<h1>Web2 QQ' > /var/www/qq/index.html
[root@pc20 ~]# echo '<h1>Web2 163' > /var/www/163/index.html
[root@pc20 ~]# systemctl restart httpd
[root@pc20 ~]# 
#############################################
虚拟机A实现DNS分离解析
[root@svr7 /]# yum -y install bind bind-chroot
 [root@svr7 /]# cat /etc/named.conf 
options {
	directory 	"/var/named";
};
view "nsd" {
  match-clients  { 192.168.4.7;  };
  zone "qq.com" IN {
	type master;
	file "qq.com.zone";
  };
  zone "163.com" IN {
	type master;
	file "163.com.zone";
  };
};
view "other" {
  match-clients  { any;  };
  zone "qq.com" IN {
	type master;
	file "qq.com.other";
  };
  zone "163.com" IN {
	type master;
	file "163.com.other";
  };
};
[root@svr7 /]# cat /var/named/qq.com.zone 
	qq.com. 		NS		svr7
	svr7     	A       192.168.4.7
	www 		A       192.168.4.10
[root@svr7 /]# cat /var/named/163.com.zone 
	163.com. 	NS		svr7
	svr7     	A       192.168.4.7
	www			A       192.168.4.10
[root@svr7 /]# cat /var/named/qq.com.other
	qq.com. 		NS		svr7
	svr7     	A       192.168.4.7
	www			A       192.168.4.20
[root@svr7 /]# cat /var/named/163.com.other
	163.com. 	NS		svr7
	svr7     	A       192.168.4.7
	www			A       192.168.4.20
[root@svr7 /]# systemctl restart named

为四台虚拟机指定DNS服务器地址
[root@svr7 /]# echo nameserver 192.168.4.7 > /etc/resolv.conf 

[root@pc207 ~]#  echo nameserver 192.168.4.7 > /etc/resolv.conf

[root@svr10 ~]#  echo nameserver 192.168.4.7 > /etc/resolv.conf

[root@pc20 ~]#  echo nameserver 192.168.4.7 > /etc/resolv.conf

####################################################
部署DHCP服务器
• Dynamic Host Configuration Protocol
– 动态主机配置协议,由 IETF(Internet 网络工程师任
务小组)组织制定,用来简化主机地址分配管理

• 主要分配以下入网参数
– IP地址/子网掩码/广播地址
– 默认网关地址、DNS服务器地址

• DHCP地址分配的四次会话,以广播进行,先到先得
– DISCOVERY --> OFFER --> REQUEST -->ACK

  一个网络中,只能有一台DHCP服务器

• 服务端基本概念
– 租期:允许客户机租用IP地址的时间期限,单位为秒
– 作用域:分配给客户机的IP地址所在的网段
– 地址池:用来动态分配的IP地址的范围

虚拟机A:
1.安装软件包dhcp
[root@svr7 /]# yum -y install dhcp
2.修改配置文件
[root@svr7 /]# vim /etc/dhcp/dhcpd.conf 
   :r  /usr/share/doc/dhcp*/dhcpd.conf.example

 subnet 192.168.4.0 netmask 255.255.255.0 { #分配网段
  range 192.168.4.100 192.168.4.200;     #分配IP地址范围
  option domain-name-servers 192.168.4.7;  #分配DNS地址
  option routers 192.168.4.254;    #网关地址
  default-lease-time 600;
  max-lease-time 7200;
 }
3.重启服务
[root@svr7 /]# systemctl restart dhcpd

#################################################
网络装机概述

网络装机的优势
• 规模化:同时装配多台主机
• 自动化:装系统、配置各种服务
• 远程实现:不需要光盘、U盘等物理安装介质

什么是PXE网络
• PXE,Pre-boot eXecution Environment
– 预启动执行环境,在操作系统之前运行
– 可用于远程安装

• 工作模式
– PXE client 集成在网卡的启动芯片中
– 当计算机引导时,从网卡芯片中把PXE client调入内存
执行,获取PXE server配置、显示菜单,根据用户选
择将远程引导程序下载到本机运行


PXE组件及过程分析
• 需要哪些服务组件?
– DHCP服务,分配IP地址、定位引导程序
– TFTP服务,提供引导程序下载
– HTTP服务(或FTP/NFS),提供yum安装源

• 客户机应具备的条件
– 网卡芯片必须支持PXE协议
– 主板支持从网卡启动
##################################################
一 构建DHCP服务,指定tftp服务器地址以及网卡引导文件名称
[root@svr7 /]# vim /etc/dhcp/dhcpd.conf 
subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.100 192.168.4.200;
  option domain-name-servers 192.168.4.7;
  option routers 192.168.4.254;
  default-lease-time 600;
  max-lease-time 7200;
  next-server  192.168.4.7;  #指定下一个服务器tftp服务器地址
  filename  "pxelinux.0";    #指定网卡引导文件名称
}
[root@svr7 /]# systemctl restart dhcpd

 pxelinux.0:网卡引导文件(网络装机说明书) 二进制文件
                     安装一个软件即可获得该文件
#####################################################
二  构建tftp服务,提供众多的引导文件                 
    
     tftp:简单的文件传输协议   默认端口 69
         默认共享路径:/var/lib/tftpboot/

1.安装软件tftp-server
[root@svr7 /]# yum -y install tftp-server
[root@svr7 /]# systemctl restart tftp

2.部署pxelinux.0文件
]# yum provides */pxelinux.0  #查询那个软件包产生该文件
]# yum -y install syslinux
]# rpm -ql syslinux | grep pxelinux.0  #查询软件安装清单

]# cp /usr/share/syslinux/pxelinux.0  /var/lib/tftpboot/  #默认共享路径:/var/lib/tftpboot/
]# ls /var/lib/tftpboot/
 

 pxelinux.0-->读取菜单文件 
              /var/lib/tftpboot/pxelinux.cfg/default

3.部署菜单文件
]# poweroff   #关闭机器,图形添加光驱设备,放入光盘文件
]# mount /dev/cdrom  /mnt/
]# ls /mnt/

]# mkdir /var/lib/tftpboot/pxelinux.cfg
]# cp /mnt/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default

]# ls /var/lib/tftpboot/

]# ls /var/lib/tftpboot/pxelinux.cfg/

4.部署图形模块与背景图片
  vesamenu.c32(图形模块)
  splash.png(背景图片)

[root@svr7 ~]# cp /mnt/isolinux/vesamenu.c32 /mnt/isolinux/splash.png /var/lib/tftpboot/

[root@svr7 ~]# ls /var/lib/tftpboot/
pxelinux.0  pxelinux.cfg  splash.png  vesamenu.c32

5.部署启动内核与驱动程序
  vmlinuz(启动内核)
  initrd.img(驱动程序)

[root@svr7 ~]# cp /mnt/isolinux/vmlinuz /mnt/isolinux/initrd.img /var/lib/tftpboot/

[root@svr7 ~]# ls /var/lib/tftpboot/
initrd.img  pxelinux.cfg  vesamenu.c32
pxelinux.0  splash.png    vmlinuz

6.修改菜单文件
]# vim  /var/lib/tftpboot/pxelinux.cfg/default
     末行模式 开启行号  :set nu

  1 default vesamenu.c32   #默认加载图形的模块
  2 timeout 600            #读秒时间   1/10秒

  10 menu background splash.png  #背景图片
  11 menu title NSD1906 PXE Server   #标题

 61 label linux
 62   menu label ^Install CentOS 7   #菜单的显示内容
 63   menu default         #读秒结束后默认选择
 64   kernel vmlinuz       #加载启动内核
 65   append initrd=initrd.img   #加载驱动程序
##################################################
总结:
   1.DHCP---> IP地址  next-server filename   
   2.tftp---> pxelinux.0
   3.pxelinux.0---> 访问菜单文件
                 /var/lib/tftpboot/pxelinux.cfg/default
   4.default--->图形的模块  背景图片  启动内核  驱动程序

测试验证:
[root@svr7 ~]# systemctl restart dhcpd
[root@svr7 ~]# systemctl restart tftp

创建一台新的虚拟机进行测试验证
  1.安装方式: 网络引导安装(PXE)
  2.内存需要: 2048M
  3.网络类型:  private1
####################################################
构建Web服务器,共享众多的软件包

1.安装软件包
[root@svr7 ~]# yum -y install httpd
2.重启httpd服务
[root@svr7 ~]# systemctl  restart httpd
3.挂载光驱设备
[root@svr7 ~]# mkdir /var/www/html/centos
[root@svr7 ~]# mount /dev/cdrom  /var/www/html/centos
mount: /dev/sr0 写保护，将以只读方式挂载
[root@svr7 ~]# ls /var/www/html/centos
[root@svr7 ~]# systemctl restart httpd

[root@svr7 ~]# firefox 192.168.4.7/centos
###################################################
实现无人值守安装,生成应答文件

1.安装可以生成应答文件的软件包
[root@svr7 ~]# yum -y install system-config-kickstart 

2.运行system-config-kickstart          
]# LANG=en  system-config-kickstart  #英文进行运行
点击 "软件包选择(Package Selection)" 查看是否可以进行选择
需要Yum仓库的支持:指向光盘的内容仓库,标识必须为[development]

[root@svr7 ~]# vim /etc/yum.repos.d/local.repo 
[development]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804
enabled=1
gpgcheck=0

[root@svr7 ~]# LANG=en  system-config-kickstart
 点击 "软件包选择(Package Selection)" 查看是否可以进行选择

[root@svr7 ~]# ls /root/ks.cfg 
/root/ks.cfg
[root@svr7 ~]# vim /root/ks.cfg 

3.利用Web服务器将ks.cfg进行共享
[root@svr7 ~]# cp /root/ks.cfg  /var/www/html/
[root@svr7 ~]# ls /var/www/html/

4.修改菜单文件,指定应答文件位置
]# vim /var/lib/tftpboot/pxelinux.cfg/default 
label linux
  menu label ^Install CentOS 7
  menu default
  kernel vmlinuz
  append 
initrd=initrd.img ks=http://192.168.4.7/ks.cfg

###################################################

             date 6


客户端:开机启动,引导项
  1.本机磁盘  2.光驱设备  3.U盘   4.网卡进行网络安装
##################################################
rsync同步操作

rsync同步操作
• 命令用法
– rsync [选项...] 源目录 目标目录
• 同步与复制的差异
– 复制:完全拷贝源到目标
– 同步:增量拷贝,只传输变化过的数据


同步控制
• rsync操作选项
– -n:测试同步过程,不做实际修改
– --delete:删除目标文件夹内多余的文档
– -a:归档模式,相当于-rlptgoD
– -v:显示详细操作信息
– -z:传输过程中启用压缩/解压

[root@svr7 ~]# rsync -a /boot /todir  //同步整个文件夹
[root@svr7 ~]# rsync -a /boot/ /todir/ //只同步目录下的数据


[root@svr7 ~]# mkdir /nsd19
[root@svr7 ~]# mkdir /todir
[root@svr7 ~]# cp /etc/passwd /nsd19
[root@svr7 ~]# touch /nsd19/1.txt
[root@svr7 ~]# ls /nsd19/
[root@svr7 ~]# rsync -av  /nsd19   /todir/  #同步目录本身
[root@svr7 ~]# ls /todir/
[root@svr7 ~]# rsync -av  /nsd19/   /todir/ #同步目录内容
[root@svr7 ~]# ls /todir/

[root@svr7 ~]# echo haha >> /nsd19/1.txt 
[root@svr7 ~]# cat /nsd19/1.txt
[root@svr7 ~]# rsync -av /nsd19/   /todir/
[root@svr7 ~]# cat /todir/1.txt 


                                                             

[root@svr7 ~]# rsync -av --delete  /nsd19/  /todir/   #清空目标目录/todir/其它内容并同步目录/nsd19/内容
[root@svr7 ~]# ls /todir/

[root@svr7 ~]# touch	 /todir/{1..5}.txt
[root@svr7 ~]# ls /todir/
[root@svr7 ~]# rsync -av --delete  /nsd19/  /todir/
[root@svr7 ~]# ls /todir/

[root@svr7 ~]# touch	 /todir/nsd{1..5}.txt
[root@svr7 ~]# ls /todir/
[root@svr7 ~]# touch	 /nsd19/abc{1..5}.txt
[root@svr7 ~]# ls /nsd19/
[root@svr7 ~]# rsync -av --delete  /nsd19/  /todir/   
[root@svr7 ~]# ls /todir/
####################################################
远程同步(rsync+SSH同步)

• 与远程的 SSH目录保持同步
– 下行:rsync [...] user@host:远程目录      本地目录
– 上行:rsync [...] 本地目录      user@host:远程目录

虚拟机A的/nsd19/目录与虚拟机B的/opt/进行同步

虚拟机A:
]# rsync -av --delete /nsd19/  root@192.168.4.207:/opt/

虚拟机B:
]# ls  /opt
###################################################
实时远程同步

一 虚拟机A通过公钥(id_rsa.pub) 私钥(id_rsa) ,实现ssh无密码验证
[root@svr7 ~]# ssh-keygen  #一路回车       //交互式不适于脚本
或
]# ssh-keygen -f /root/.ssh/id_rsa -N ''  //非交互式传秘钥,-f 秘钥文件路径,-N 密码

[root@svr7 ~]# ls /root/.ssh/

[root@svr7 ~]# ssh-copy-id root@192.168.4.207

]# rsync -av --delete /nsd19/  root@192.168.4.207:/opt/

 拥有私钥的机器,可以无密码登录拥有公钥的机器


二  监控/nsd19目录变化

• Linux内核的 inotify 机制
– 提供事件响应式的文件系统通知机制
– 安装 inotify-tools 控制工具可调用此机制实现监控

真机上:
[student@room9pc01 ~]$ scp /linux-soft/01/tools.tar.gz  root@192.168.4.7:/root/

1.虚拟机A找到该软件
[root@svr7 ~]# tar -xf  /root/tools.ta
步骤四:maker.gz -C  /
[root@svr7 ~]# ls /tools/
inotify-tools-3.13.tar.gz  other

2.安装gcc与make
[root@svr7 ~]# yum -y install gcc  make 

3.解包
[root@svr7 ~]# tar -xf /tools/inotify-tools-3.13.tar.gz    -C  /opt

4.运行configure脚本进行配置检测
]# cd /opt/inotify-tools-3.13/
]# ./configure 
5.运行make进行编译
]# make
6,进行make  install 进行安装
]# make install
]# ls /usr/local/bin/inotifywait   #验证是否有运行程序
/usr/local/bin/inotifywait



• 基本用法
– inotifywait [选项] 目标文件夹
• 常用命令选项
– -m,持续监控(捕获一个事件后不退出)
– -r,递归监控、包括子目录及文件
– -q,减少屏幕输出信息
– -e,指定监视的modify、move、create、delete、attrib等事件类别




书写同步的脚本rsync.sh
     循环:for循环适合写有次数的循环 
     死循环:while循环适合无限次数的循环 

 格式:     
       while [条件]
	   do
               重复的代码
	   done


虚拟机A:
[root@svr7 /]# vim /root/rsync.sh
 #!/bin/bash
 while  inotifywait -rqq /nsd19/
 do
  rsync -a --delete /nsd19/  root@192.168.4.207:/opt/
 done
[root@svr7 /]# chmod  +x  /root/rsync.sh
[root@svr7 /]# /root/rsync.sh &
[1] 8297
[root@svr7 /]# jobs -l
[root@svr7 /]# 

################################################

Cobbler装机平台,不同版本的多系统的安装

手动安装有图形环境的虚拟机cobbler
  		1.操作系统为:CentOS 7.5
  		2.内存大小:2G  
  		3.磁盘空间:20G
  		4.虚拟机网络类型为:private1
		5.软件包选择 "带GUI的服务器"
		6.分区选择 "自动分区"
		7.管理员root密码为 1
		8.创建普通用户lisi



####################################################
一  具备一个CentOS虚拟机  
[root@svr7 ~]# cat /etc/redhat-release 
CentOS Linux release 7.5.1804 (Core) 
                                     
二、虚拟机设置                                       
   1.设置防火墙为trusted                           
  ]# firewall-cmd  --set-default-zone=trusted 
   2.当前及永久设置SELinux状态为permissive
  ]# setenforce 0     #当前为宽松模式
  ]# getenforce       #查看当前SELinux的状态
  ]# vim  /etc/selinux/config 
  SELINUX=permissive
  3.配置IP地址为:192.168.4.123/24
  4.配置主机名:cobbler.tedu.cn
  5.构建Yum仓库:以真机FTP服务器作为Yum源
 ]# cd /etc/yum.repos.d/
 ]# mkdir repo
 ]# mv *.repo  repo
 ]# ls
 ]# vim dvd.repo
 [dvd]
 name=dvd
 baseurl=ftp://192.168.4.254/centos-1804
 enabled=1
 gpgcheck=0

##################################################

三、利用scp真机传递cobbler.zip包到虚拟机192.168.4.123中
 # scp /home/student/桌面/cobbler.zip   root@192.168.4.123:/root/
 
##################################################

四、搭建Cobbler装机平台

  Cobbler概述软件，管理dhcp、tftp、Web服务
    自由的导入镜像与ks应答文件

1.解压cobbler.zip包
]# yum -y install unzip 

]# unzip /root/cobbler.zip -d /
]# ls /cobbler/
cobbler_boot.tar.gz  cobbler_web.png
cobbler_rpm.zip

]# unzip /cobbler/cobbler_rpm.zip -d /opt/
]# ls /opt/cobbler/


#####################################################
五、安装cobbler主程序、工具包等
]# yum -y install  dhcp  httpd  mod_ssl 
]# yum -y install  /opt/cobbler/*.rpm  
]# rpm -q cobbler
cobbler-2.8.2-1.el7.x86_64


################################################################
cobbler网络装机部署
1.安装软件 cobbler cobbler-web dhcp tftp-server pykickstart httpd  

 cobbler         #cobbler程序包
 cobbler-web     #cobbler的web服务包
 pykickstart     #cobbler检查kickstart语法错误
 httpd           #Apache web服务
 dhcp            #dhcp服务
 tftp-server     #tftp服务

2.配置cobbler
[root@svr7 /]# vim  /etc/cobbler/settings

 next_server:   192.168.4.123   #设置下一个服务器还为本机
 server:   192.168.4.123        #设置本机为cobbler服务器
 manage_dhcp:   1               #设置cobbler管理dhcp服务
 pxe_just_once:   1             #防止客户端重复安装操作系统

 开机启动项： 匹配及停止  
     1.硬盘启动     2.光驱设备     3.U盘     4.网络引导  

3.配置cobbler的dhcp
[root@svr7 /]# vim  /etc/cobbler/dhcp.template 

  :%s  /旧/新/g      #全文替换
  :%s  /192.168.1/192.168.4/g    #全文替换

    5 次替换，共 4 行   


4.绝对路径解压cobbler_boot.tar.gz    #众多的引导文件
# tar -tf  /cobbler/cobbler_boot.tar.gz   #查看包里面内容
# tar -xPf  /cobbler/cobbler_boot.tar.gz  #绝对路径释放

# ls  /var/lib/cobbler/loaders/
COPYING.elilo     grub-x86_64.efi  README
COPYING.syslinux  grub-x86.efi     yaboot
COPYING.yaboot    menu.c32
elilo-ia64.efi    pxelinux.0


5.启动相关服务
  ]# systemctl restart cobblerd     
  ]# systemctl enable cobblerd

  ]# systemctl restart httpd
  ]# systemctl enable httpd

  ]# systemctl restart tftp
  ]# systemctl enable tftp

  ]# systemctl restart rsyncd   #同步服务
  ]# systemctl enable rsyncd


6.同步刷新cobbler配置
[root@svr7 /]# cobbler sync    #检测所有配置是否正确
......
*** TASK COMPLETE ***


]# firefox https://192.168.4.123/cobbler_web   #了解

   用户名：cobbler
   密码：cobbler                                         



##########################################################################################################
cobbler应用                 

cobbler import  --path=挂载点   --name=导入系统命名（随意起）

导入安装镜像数据
# mkdir /dvd
# mount /dev/cdrom  /dvd
# ls /dvd/

# cobbler import --path=/dvd  --name=CentOS7

cobbler导入的镜像放在：/var/www/cobbler/ks_mirror

##################################################



[root@cobbler /]# cobbler list    #查看有哪些系统
distros:
   CentOS7-x86_64        #安装客户端至少2G内存

profiles:
   CentOS7-x86_64

##############################################
删除
# cobbler list 
# cobbler profile remove --name=CentOS7-x86_64  #删除菜单信息
# cobbler distro remove --name=CentOS7-x86_64  #删除镜像信息


###########################################

# umount /dvd/
# mount /dev/cdrom  /dvd   #将光盘换成RHEL7
# ls /dvd/

  安装完成机器 默认root  密码  cobbler

############################################################################################################
自定义应答文件：开头注释行删除

[root@cobbler ~]# system-config-kickstart  #生成ks文件

必须默认kickstart文件存放位置：/var/lib/cobbler/kickstarts/

[root@cobbler ~]# cobbler list

修改kickstart文件：
[root@cobbler ~]# cobbler profile edit --name=CentOS7  --kickstart=/var/lib/cobbler/kickstarts/自定义.cfg

[root@cobbler ~]# cobbler profile report
[root@cobbler ~]# cobbler sync  #同步配置

############################################################################################################
环境变量PATH

   PATH:存放执行命令程序的搜寻路径
[root@cobbler /]# echo $PATH
[root@cobbler /]# vim /opt/hello.sh
#!/bin/bash
echo hello
[root@cobbler /]# chmod +x /opt/hello.sh
[root@cobbler /]# /opt/hello.sh
[root@cobbler /]# hello.sh #允许失败

[root@cobbler /]# cp /opt/hello.sh /usr/bin
[root@cobbler /]# hello.sh 

[root@cobbler /]# cd /root/
[root@cobbler ~]# hello.sh 

[root@cobbler ~]# cd /tmp/
[root@cobbler tmp]# hello.sh 
#################################################
权限的掩码 umask值 与目录默认权限有关

[root@cobbler /]# umask 
0022
[root@cobbler /]# umask 077
[root@cobbler /]# umask 
0077
[root@cobbler /]# mkdir /opt/nsd02
[root@cobbler /]# ls -ld /opt/nsd02

[root@cobbler /]# umask 022
[root@cobbler /]# mkdir /opt/nsd05
[root@cobbler /]# ls -ld /opt/nsd05

#############################################
#############################################
       network

date 1
  
DOD：国防部

ARPA：高级研究项目署  -> ARPAnet



Modem：猫 调制解调器   56kbps   => 7kB/s  ＝》 拨号上网

描述速率的时候，用的都是bit，电脑上描述文件大小都是字节byte

1byte = 8 bit

ISDN：超级一线通，综合业务数字网

## 网络分类

### 按地域范围分类

- 局域网：LAN
- 广域网：WAN
- 城域网：MAN

### 按技术划分

- 对等网：网络中主机具有相同角色
- C/S：客户机/服务器
- B/S：浏览器/服务器

### 按安全划分

- intranet：内部网络
- extranet：外部网络
- Internet：国际互联网



巨大中华：巨龙集团、大唐电讯、中兴、华为

中华酷联：中兴、华为、酷派、联想

## 网络拓扑结构

- 星型：重要、常用的结构
- 点到点：互联网上有应用，LAN几乎没有
- 总线型：几乎没有
- 网状：几乎没有

## OSI参考模型 

- OSI：开放系统互联 参考模型。ISO制定
  - 自下向上是第一至第七层
  - 物理层：一层
  - 数据链路层：MAC地址、交换机
  - 网络层：IP地址、路由器
  - 传输层：TCP、UDP协议、端口号
  - 会话层
  - 表示层
  - 应用层：七层

印表会传往树屋

## TCP/IP参考模型 

- 共五层（四层）：前四层与OSI参考模型一样，OSI高三层合并为一个应用层

点到点：IP到IP

端到端：应用到应用

## 数据通信过程

1. 应用层程序准备好数据
2. 表示层负责将数据转换格式
3. 会话层负责建立会话连接，不是所有应用都有此步骤
4. 传输层负责把数据切分成一个个的片段，称作数据段segment。每个数据段加上编号，称作序列号。还需要指定使用的是TCP或UDP协议，以及端口号。
5. 网络层负责给数据加上IP地址，打成数据包package。
6. 数据链路层负责给数据加上MAC地址，打成数据帧frame。
7. 物理层将数据转换成二制的0和1，称作比特（流），在物理介质上传输。
8. 发送方，数据自上向下总是增加头部内容，称作封装过程。
9. 接收方，数据自下向上将发送方加入的头部移除，称作解封装过程。

## 华为设备

- 接口
  - console：控制台接口，连接控制线缆到PC机。相当于是为设备提供键盘、鼠标、显示器。
  - FastEthernet：快速以太网接口，速率100Mbps
  - GigabitEthernet：吉比特接口，速度1000Mbps

- 交换机配置
  - 命令需要在不同的模式下执行，不同模式有不同的指令
    - 用户视图：只能执行一些基本的查询指令：<主机名>
    - 系统视图：可以执行管理命令：[主机名]
    - 接口视图：只对某一接口生效的指令在这里执行：[主机名-接口]
    - 协议视图：配置相关协议时使用的视图：[主机名-协议]

```shell
<Huawei>?    # 显示该模式下所有的命令
<Huawei>l?   # 显示所有的以l开头的命令
<Huawei>la<tab>    # 因为以la开头的命令只有一条，所以此时按tab可补全
<Huawei>language-mode Chinese   # 改变为中文提示
<Huawei>system-view  # 进入系统视图
[Huawei]sysname sw1   # 修改主机名为sw1
# 在华为设备上，任何与显示相关的命令，都以display开头
[sw1]display interface brief  # 显示所有端口的简要信息
[sw1]int g0/0/1   # 进入接口
[sw1-GigabitEthernet0/0/1]quit   # 返回一步
[sw1-GigabitEthernet0/0/1]return  # 直接返回到用户视图
[sw1-GigabitEthernet0/0/1]ctrl+z  # 按组合键也会返回到用户视图
```

翻译软件：搜狗搜译。

## 交换机常用命令

```shell
# 华为操作系统名为VRP，即多样化路由平台
<sw1>display version   # 查看设备的软件版本号和运行时间
<sw1>display current-configuration  # 查看设备当前的生效配置

# 配置密码
# AAA模式，认证模式
# Athentication：认证，你是谁
# Athorization：授权，你能干什么
# Audit：审计，你干了什么
<sw1>system-view
[sw1]aaa
[sw1-aaa]local-user 用户名 password cipher 密码   # 设置加密密码
[sw1-aaa]quit
[sw1]user-interface console 0     # 进入控制台接口模式
[sw1-ui-console0]authentication-mode aaa   # 配置使用AAA认证
# 退出到最外面，再次回车，进入用户视图就需要用户名和密码了

<sw1>save   # 系统提示将会把系统原有配置覆盖，是否要继续，选择y，系统再次提示文件名，直接回车，采用默认的名字即可
<sw>reboot  # 重启


<sw1>reset saved-configuration   # 擦除保存的配置，系统提示，是否真的擦除，回答y。注意，擦除的是已保存的配置，不是当前内存中生效的配置。重启后，才会恢复到最初状态。
<sw1>reboot  # 系统首先比较内存中配置与保存的配置是否一致，发现不一致，提示是否要把当前配置保存，此时回答：n。系统再次提示，是否要继续重启，回答y
```

## 其他命令行小技巧

```shell
# 配置设备没有控制台超时时间，相当于配置主机、手机锁屏前的等待时间
[sw1]user-interface console 0
[sw1-ui-console0]idle-timeout 分钟数

```

## 交换机工作原理

- MAC地址：MAC是介质访问控制。
  - MAC地址也叫物理地址，因为设备在生产的时候，MAC地址已经烧到印制电路版中了
  - 网卡有MAC地址，交换机、路由器每个端口也有MAC地址
  - MAC地址共48位（48个2进制数）、6字节。
  - 表示的时候，往往是把2进制转换成16进制进行表示，每两个16进制数之间用冒号或减号分隔。一共是5个冒号或分号隔开6段。
  - MAC地址前24位是厂商的组织唯一标识符，即OUI；后24位厂商自行决定

```shell
# 2进制与16进制的转换：4位2进制转换成一个16进制数
0000 -> 0
0001 -> 1
0010 -> 2
0011 -> 3
0100 -> 4
0101 -> 5
0110 -> 6
0111 -> 7
1000 -> 8
1001 -> 9
1010 -> A
1011 -> B
1100 -> C
1101 -> D
1110 -> E
1111 -> F
```

- 交换机的工作原理
  - 交换机内部有一张MAC地址表，记录了每个端口连接设备的MAC地址
  - MAC地址表在开机的时候是空的，它要动态学习每个端口所连设备的MAC地址
  - 当某一终端发送数据帧到交换机时，交换机根据数据帧的源MAC地址构建MAC地址表
  - 交换机根据数据帧的目标MAC地址发送数据到指定端口
  - 如果交换机在MAC地址表中找不到目标MAC地址连在自己的哪个端口上，将会把数据帧向除接收端口以外的所有端口发出







应用层
表示层
会话层
传输层          数据段
网络层	    数据包
数据链路层   数据帧
物理层 	    比特流

  应表会传往树屋

视图
用户视图 保存
系统视图 
接口视图
协议视图

ctrl+z 等于 return


[Huawei]sysname SW1     //修改主机名
[Huawei]display version     //查看软硬件版本
[Huawei]display current-configuration    //查看正在运行的配置,按空格翻页

aaa模式,负责授权认证审计,可以在此模式创建账户和密码
  [HuaWei-aaa]local-user admin01 password cipher 123 //创建账户和密码 cipher/simple(加密/不加密)
  [HuaWei-aaa]quit
  [HuaWei]user-interface console 0           //进入控制台视图
   [huawei-ui-console0]authentication-mode aaa   //激活配置
    
ctrl + ]   彻底退出系统

<Huawei>save      //保存设置
<Huawei>reboot        //重启设备

<Huawei>reset saved-configuration  //重置配置文件(恢复出厂)
<Huawei>reboot        //重启设备

ip 
mac 硬件地址  物理地址 ,全球唯一不重复  48bit


0123456789ABCDEF

关闭各种信息提示(控制台超时后失效)
undo terminal debugging
undo terminal monitor 
undo terminal logging 
undo terminal trapping 

设置控制台永不超时
sys
user-interface console 0
idle-timeout 0
#####################################################################
date 2

网络的功能
信息传递  资源共享  提高可靠 增加系统处理性能

60年代  分组交换
70~80  tcp/ip
90年代   web技术

拓扑结构
点对点  wan
星形  lan   
网状  lan  

osi七层参考模型
tcp/ip五层参考模型

应用层    
传输层  防火墙
网络层  路由器
数据链路层  交换机
物理层  网卡

用户视图
系统视图
接口视图
协议视图

交换机工作原理
学习,广播,转发,更新

广播泛滥

广播域
vlan  虚拟局域网 
virtual 
控制广播
增加安全
提高带宽的利用率
降低数据传递的延迟
50~60ms   100ms
20ms
1s=1000ms

vlan 最大数量4096个

vlan1  默认vlan,无需创建,不能删除

1, 创建vlan
进入系统视图  
vlan 2		//创建vlan2
undo vlan 2   //删除vlan 2
2, 将接口加入相关vlan  
in e0/0/3    //进入接口3
port link-type access    //接口类型更改为接入,表示即将为某一个vlan传输数据
port default vlan 2   //修改接口服务的vlan

display vlan   查看vlan列表验证之前的操作

vlan batch 10 20 30    
undo vlan batch 10 20 30

[Huawei]vlan batch 2 3			//创建VLAN2、3
[Huawei]port-group 1    //建组,组号是1
[Huawei-port-group-1]group-member Ethernet0/0/3 Ethernet0/0/4    //组中加入3口和4口
[Huawei-port-group-1]port link-type access   //在组1中所敲的命令,等于对该组中所有接口敲
[Huawei-port-group-1]port default vlan 2		

网段
vlan1
192.168.1.1
192.168.1.2
vlan2
192.168.2.1
192.168.2.2
vlan3
192.168.3.1
192.168.3.2


access 接入链路  承载1个vlan
trunk  中继链路  承载多个vlan  打vlan标记

in e0/0/7
port default vlan 1    //恢复默认vlan
port link-type trunk    //修改为中继链路
port trunk allow-pass vlan all    //允许通过所有vlan

链路聚合,增加可靠,增加带宽

进入系统视图
clear configuration interface ethernet0/0/7    //清空所有配置,恢复默认,此时接口会自动关闭
[Huawei]interface ethernet0/0/7
undo shutdown     //打开接口

[Huawei]interface Eth-trunk 1   //进入(创建)链路聚合接口1
[Huawei- Eth-trunk1]trunkport e 0/0/7  0/0/8  //捆绑7口和8口,此步骤如果接口不是默认状态,会提示报错,要求恢复默认.
port link-type trunk    //将链路聚合接口修改为中继链路
port trunk allow-pass vlan all    //放行所有vlan


网络层	   路由器   ip
数据链路层  交换机   mac

不同部门=不同vlan=不同网段=不同广播域

2的n次方-2

A  1~127       1677万+
255.0.0.0
B  128~191     65534
255.255.0.0
C  192~223     254
255.255.255.0

192.168.0.1~192.168.0.254
每个网段第一个地址是网络id,最后一个地址是广播地址

192.168.0.1

172.16.0.0     172.16.255.255
172.16.0.1~172.16.255.254

icmp 英特网控制报文协议  可以查询网络状态并反馈相应数据

undo ip add   进入接口,删除ip
在接口中使用 display this 查看配置的ip地址

路由表
直连路由  路由器接口配置ip,并开启之后自动产生
静态路由  由管理员手工配置,小规模网络适用

R1
ip route-static 192.168.3.0 24 192.168.2.2
ip route-static 192.168.4.0 24 192.168.2.2

R2
undo ip route-static 192.168.1.0 24 192.168.2.3
ip route-static 192.168.1.0 24 192.168.2.1

display ip routing-table | include /24    查看路由表包含/24的行

????????????????????????????????????????????????????????????????????????????????????????????????
 day02(2)

## 网络的通信类型

- 单播unicast：一对一
- 多播，也叫组播multicast：一对部分
- 广播broadcast：一对所有
- 在ipv6中，没有广播了，增加的是任播anycast。任播地址与单播地址一样，只不过这个地址配置在了多个节点上。

## 广播域

- 设备发出广播后，能够接收到广播的所有设备的集合是一个广播域。

- 没有任何配置的情况下，多台交换机连接起来，也是处于一个广播域。
- 交换机会将以下数据帧向所有端口发送
  - 广播
  - 组播
  - 未知地址的单播

## VLAN：虚拟局域网

- 最主要的作用是划分广播域，实现广播控制

### VLAN配置

- 创建VLAN：每个VLAN都有一个ID号，还可以添加可选的名字
- 将端口划分到VLAN

```shell
# 查看VLAN信息，默认所有端口都在vlan1中
<Huawei>system-view
[Huawei]display vlan  # 查看VLAN

# 创建一个VLAN
[Huawei]vlan 10    # VLAN id号范围是1-4094
[Huawei-vlan10]description ops   # VLAN10是运维部VLAN
[Huawei-vlan10]display this  # 查看当前模式下有哪些配置

# 批量创建VLAN
[Huawei]vlan batch 15 20   # 创建两个VLAN
[Huawei]vlan batch 21 to 25  # 创建5个VLAN
[Huawei]display vlan

# 删除VLAN：在创建VLAN的命令前加undo
[Huawei]undo vlan 20
[Huawei]undo vlan batch 15 21
[Huawei]undo vlan batch 22 to 25
```

端口类型

- 接入端口：接入端口仅属于一个VLAN
- 中继端口：不属于任何VLAN，但是可以承载所有VLAN的数据

```shell
[Huawei]int g0/0/1
[Huawei-GigabitEthernet0/0/1]port link-type access  # 设置端口类型
[Huawei-GigabitEthernet0/0/1]port default vlan 10   # 加入vlan10
[Huawei-GigabitEthernet0/0/1]display this

# 批量将端口加入VLAN
[Huawei]port-group 1   # 创建端口组，组号为1
[Huawei-port-group-1]group-member g0/0/5 g0/0/8  # 将不连续端口加入组
[Huawei-port-group-1]group-member g0/0/11 to g0/0/15 # 将连续端口加入组
[Huawei-port-group-1]port link-type access
[Huawei-port-group-1]port default vlan 10
[Huawei]display vlan
```

综合练习：

- 两台交换机sw1和sw2
- sw1:
  - vlan1: g0/0/1 - g0/0/2     pc1: 192.168.1.10  pc2: 192.168.1.20
  - vlan2: g0/0/3 - g0/0/4     pc3: 192.168.2.10  pc4: 192.168.2.20
  - vlan3: g0/0/5 - g0/0/6     pc5: 192.168.3.10  pc6: 192.168.3.20
  - g0/0/24 连接 sw2 g0/0/24
- sw2:
  - vlan1: g0/0/1 - g0/0/2     pc7: 192.168.1.70  pc8: 192.168.1.80
  - vlan2: g0/0/3 - g0/0/4     pc9: 192.168.2.90  pc10: 192.168.2.100
  - vlan3: g0/0/5 - g0/0/6     pc11: 192.168.3.110  pc12: 192.168.3.120
  - g0/0/24 连接 sw1 g0/0/24

### 设备网络参数

- IP地址：设备的地址
- 子网掩码：判断地址属于哪个网络
- 网关：数据包发出自己网络必须经过的地址

网络通信：A设备与B设备通，A先判断B与自己是不是在同一网络，如果是则直接发送；如果不是，则发往网关。

## Trunk中继

- 中继链路主要用在交换机之间
- 中继链路不属于任何VLAN，但是允许所有VLAN的数据通过

```shell
# 配置中继，两个步骤。注意，链路两端的交换机端口都需要配置
# 1. 将端口设置为中继模式
[sw1]int g0/0/24
[sw1-GigabitEthernet0/0/24]port link-type trunk

# 2. 设置中继端口允许哪些VLAN的数据通过
[sw1-GigabitEthernet0/0/24]port trunk all-pass vlan all
```

## 链路聚合

- 交换机之间可以连接多条链路
- 将多条链路捆绑成一个逻辑端口，以提供更大的带宽，同时可以实现容错
- 注意
  - 参与捆绑的所有端口需要有一致的物理状态，如都是1000Mb/s
  - 参与捆绑的所有端口要么同属于同一VLAN，要么都是中继

```shell
# 1. 清除参与捆绑端口的配置
[sw1]clear configuration interface GigabitEthernet 0/0/23
[sw1]clear configuration interface GigabitEthernet 0/0/24
# 2. 创建名为Eth-Trunk 0的逻辑端口
[sw1]interface Eth-Trunk 0
# 3. 把物理端口加入到逻辑端口中
[sw1-Eth-Trunk0]trukport GigabitEthernet 0/0/23 0/0/24
# 4. 配置逻辑端口为中继状态
[sw1-Eth-Trunk0]port link-type trunk
[sw1-Eth-Trunk0]port trunk allow-pass vlan all
# 5. 将物理端口启用
[sw1]interface GigabitEthernet 0/0/23
[sw1－GigabitEthernet0/0/23]undo shutdown
[sw1]interface GigabitEthernet 0/0/24
[sw1－GigabitEthernet0/0/24]undo shutdown
# 6. 查看
[sw1]display vlan
[sw1]display interface Eth-Trunk 0
[sw1]display current-configuration
```

## 网络层

- IP地址：32位2进制数。
  - 私有地址
    - 10.0.0.0/8
    - 172.16.0.0 - 172.31.0.0/16
    - 192.168.0.0 - 192.168.255.0/24
- 路由器：
  - 路由：路径
  - 路由器：负责路径选择的设备

- ARP：地址解析协议
  - 三层需要IP地址
  - 二层需要MAC地址
  - ARP协议用于将IP地址解析为MAC地址

### 路由器工作原理

- 路由器负责将不同的网络连接起来；交换机连接的是相同网络
- 路由器是三层设备，它的每个端口都有IP地址
- 路由器收到数据包后，根据自己的路由表做出转发决定
- 如果目的地不在路由表中，则将数据包丢弃
- 路由器不允许广播通过
- 路由表的形成可以是管理员手工配置静态路由；也可以通过路由协议自动学习
- 路由表中保存的是最优路径，而不是全部路径

```shell
[R1]display interface brief  # 查看端口简要信息
[R1]display ip routing-table  # 查看路由表
[R1]int g0/0/0
[R1-GigabitEthernet 0/0/0]ip address 192.168.1.1 24  # 配置IP地址
[R1]display ip routing-table  # 配置IP地址后，路由表中将出现直连路由
[R1]ip route-static 目标网络 目标掩码 下一跳地址
[R1]ip route-static 192.168.3.0 24 192.168.2.2

# 缺省路由，也叫默认路由。不管目标是哪，下一跳一样，采用默认路由
[R1]ip route-static 0.0.0.0 0 下一跳
[R1]ip route-static 0.0.0.0 0 192.168.2.2
```










####################################################################

      day 3


 交换机   二层
vlan
控制广播,增加安全,带宽利用率提高,降低数据传递的延迟

路由器 实现不同网段的链接 ,在物理接口配置ip

三层交换机=二层交换+三层路由 ,在虚拟接口配置ip
使用三层交换机搭建网络:

1,三层交换机创建vlan 2 3
   vlan batch 2 3
2,将接口加入对应vlan
in g0/0/2
port link-type access
port default vlan 2
dis vlan
3,进入vlan接口(虚拟接口)配置ip地址,此ip将作为
终端设备的网关
in vlan 1
ip add 192.168.1.254 24

dis cur

添加S3700交换机, 达到更合理利用三层交换机的目的

1,在S3700创建vlan2 3
2,在S3700将pc所链接的接口加入相应vlan
3,将2台交换机之间的链路配置为中继链路
port link-type trunk
port trunk allow-pass vlan all

排错
1,查ip,网关
2,所属vlan
3,测试与网关的链接

网段 , vlan

为三层交换机接口配置ip的思路:

1,S5700创建vlan4
2,进入vlan4虚拟接口配置ip
in vlan 4
ip add 192.168.4.1 24
3,将g0/0/2口加入vlan4

动态路由 是由某种动态路由协议实现全网互通的目的,适用于大型网络

rip,isis,eigrp,bgp,ospf

宣告 


三层交换机配置:
ospf		//开启动态路由ospf
area 0      //进入第一个区域,一般超大型网络才需要多个区域,中小规模只使用第一个也就是0区域即可
network 192.168.1.0 0.0.0.255   //宣告设备自身所链接的网段
network 192.168.2.0 0.0.0.255
network 192.168.3.0 0.0.0.255
network 192.168.4.0 0.0.0.255
路由器:
ospf
area 0 
network 192.168.4.0 0.0.0.255
network 192.168.5.0 0.0.0.255
display ip routing-table | include /24    查看最终结果


直连路由 配置ip,并开启接口自动生成
静态路由 手工配置   192.168.1.0 24 192.168.1.X
动态路由
默认路由 是特殊的静态路由,能够匹配任意网段,当路由表中无法查询到目标网段时使用,通常用在内部设备访问公网时使用.

三层交换机
ip route-static 0.0.0.0 0 192.168.4.2    //可以匹配任意网络
路由器
ip route-static 0.0.0.0 0 192.168.5.1



传输层     端口号  端到端
网络层         路由器  ip  点到点
数据链路层  交换机 vlan trunk  mac

http  80    tcp
https 443

mysql  3306 tcp

tcp   传输控制协议
可靠性高,效率低,面向链接

syn 打算与对方建立链接
ack 确认
fin 打算与对方断开链接

三次握手  syn-->ack,syn-->ack
四次断开  fin-->ack-->   fin-->ack

udp   用户数据报协议
可靠性低,效率高,无链接

acl  访问控制列表,对匹配的数据进行限制.

基本acl  2000~2999   可以对源ip限制
高级acl  3000~3999   可以对源ip,目标ip,协议,端口限制

acl练习1:
[Huawei]interface GigabitEthernet 0/0/0
[Huawei-GigabitEthernet0/0/0] ip address  192.168.1.254 24
[Huawei]acl 2000   //创建acl,列表号是2000,表示即将使用基本acl
[Huawei-acl-basic-2000]rule deny source 192.168.2.1 0   //创建规则,拒绝源ip是192.168.2.1的数据通过
[Huawei]interface GigabitEthernet 0/0/1
[Huawei-GigabitEthernet0/0/1]ip address  192.168.2.254 24
[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 2000
   //进入g0/0/1接口后,放置acl 2000,用来过滤即将进入路由器的数据.

acl练习2:
acl 2000    //重新进入列表2000
display this   //查看
undo rule 5   //删除之前的条目,根据序号删除
rule permit source 192.168.2.1 0   //创建新条目,允许2.1通过
rule deny   //拒绝所有人通过

在同接口的同方向,只能放一条acl


date4

回顾
直连路由,静态路由,缺省(默认)路由, 0.0.0.0 0,动态路由
传输层  
tcp 三次握手  syn-->ack syn-->ack
	四次断开  fin-->ack-->fin-->ack
ssh 22,http 80,ftp 21,dns 53,smtp 25,https 443

udp 
tftp 69,dns 53,ntp 123

acl
基本 2000~2999   源ip
高级 3000~3999   源ip  目标ip  协议  端口
##############################################
使用高级acl配置网络:
[Huawei]acl 3000    
[Huawei-acl-adv-3000]rule deny tcp source 192.168.2.1 0 destination 192.168.1.1 0 destination-port eq 21   //拒绝2.1访问1.1的ftp服务

in g0/0/1
undo traffic-filter inbound    //如果有acl 2000,需要删除
traffic-filter inbound acl 3000   //在接口应用acl

[Huawei]acl 3000   
[Huawei-acl-adv-3000]rule deny tcp source 192.168.2.2 0 destination 192.168.1.1 0 destination-port eq 80   //拒绝2.2访问1.1的www服务

#############################################
NAT 网络地址转换 , 可以将内部私有地址与外部公有地址相互转换,实现内外互通的目的
优点: 节约公网ip,增加安全,处理地址重叠

ipv4   42亿
A 1~127   255.0.0.0     /8
B 128~191 255.255.0.0   /16
C 192~223 255.255.255.0 /24

私有地址范围 
A 10.0.0.0~10.255.255.255
B 172.16.0.0~172.31.255.255
C 192.168.0.0~192.168.255.255
=================================
nat常用的2种类型:
静态转换     1对1    适合服务器对外发布服务的环境   内外双方均可发起链接
easy ip  1对多   适合仅仅访问外网的需求,比如办公室环境员工上网, 只能由内向外发起数据请求
=================================
静态nat配置
[Huawei]interface GigabitEthernet 0/0/1   //进入外网接口
[Huawei-GigabitEthernet0/0/1]nat static global 100.0.0.2 inside 192.168.2.1   //配置nat实现2.1在访问外网时使用的地址是100.0.0.2
[Huawei-GigabitEthernet0/0/1]nat static global 100.0.0.3 inside 192.168.2.2   //配置nat实现2.2在访问外网时使用的地址是100.0.0.3
=================================
easy ip 配置
首先删除之前的静态nat
undo nat static global 100.0.0.2 inside 192.168.2.1
undo nat static global 100.0.0.3 inside 192.168.2.2
acl 2000    //定义acl
rule permit source any   //设置允许访问外网的主机,放行所有人
in g0/0/1    //进入外网接口
nat outbound 2000   //开启nat功能,需要配合acl列表号
#########################################
实现网关的高可用
vrrp 虚拟路由冗余协议,可以理解为网关的备份

==========================
按拓扑需求配置ip
三层交换机接口配置ip需要先创建vlan
然后进入vlan配置ip,再将对应的接口加入vlan
in g0/0/2
port link-type access
port default vlan 2

三层交换机和路由器都开启动态路由
ospf
area 0
network 192.168.1.0 0.0.0.255
network 192.168.2.0 0.0.0.255

pc2临时使用252或者253作为网关
==================================
vrrp三个角色
主路由器(master),负责转发数据 
备份路由器(backup),监视主路由器,准备随时替代
虚拟路由器,客户机的网关
===================================
配置:
in vlan 1
vrrp vrid 1 virtual-ip 192.168.1.254
dis vrrp brief  //查看vrrp信息
pc的网关修改为254
===================================
使用vrrp实现数据的负载均衡
sw1   vlan1   主    vlan2  备
sw2   vlan2   主    vlan1  备

所有交换机创建vlan2
所有链路配置为trunk,为了节约时间可以使用接口组
port-group 1    //创建1号接口组
group-member g0/0/1 to g0/0/3  //组中添加1口到3口
port link-type trunk    //为所有加入的接口配置trunk
port trunk allow-pass vlan all
注意s3700使用的是E口

########################################################

date 5

准备环境: 所有交换机创建vlan2 ,sw1与sw2分别配置不通vlan的ip地址
所有交换机之间的链路配置为中继(trunk)链路
sw1   vlan1  主    vlan2  备
sw2   vlan1  备    vlan2  主
分别进入2台s5700配置vrrp
in vlan 1
vrrp vrid 1 virtual-ip 192.168.1.254
in vlan 2
vrrp vrid 2 virtual-ip 192.168.2.254
dis vrrp brief   //查看vrrp状态
--------------------------------------------
sw1 
in vlan 1
vrrp vrid 1 priority 105   //修改sw1的vlan1中vrrp优先级
sw2
in vlan 2
vrrp vrid 2 priority 105   //修改sw2的vlan2中vrrp优先级
dis vrrp brief   //再次查看vrrp状态
=====================================
升级企业级网络:
1, 所有设备添加vlan3 vlan4,新添加的设备要创建vlan2~vlan4
相当于目前所有交换机拥有vlan 1~4
2,在网关设备添加新ip地址
3,完善全网trunk
4,完善vrrp
sw1   vlan1  主    vlan2  备     vlan3  主    vlan4  备
sw2   vlan1  备    vlan2  主     vlan3  备    vlan4  主

sw1
in vlan 3
vrrp vrid 3 virtual-ip 192.168.3.254
vrrp vrid 3 priority 105 
in vlan 4
vrrp vrid 4 virtual-ip 192.168.4.254
sw2
in vlan 3
vrrp vrid 3 virtual-ip 192.168.3.254
in vlan 4
vrrp vrid 4 virtual-ip 192.168.4.254
vrrp vrid 4 priority 105 

5,添加pc,配置ip与网关
pc1  192.168.1.1   192.168.1.254
pc2  192.168.2.1   192.168.2.254
pc3  192.168.3.1   192.168.3.254
pc4  192.168.4.1   192.168.4.254

6,为不同pc链接的交换机接口加入对应的vlan
pc1 vlan1
pc2 vlan2
pc3 vlan3
pc4 vlan4
最后效果是全网互通

7,添加连接外部网络的路由器ar2220两台
再给s5700与路由器链接的线路配置ip
	路由器接口直接配ip即可
	s5700配置ip先创建vlan

8,配置动态路由,在路由器与s5700开启ospf
并宣告自身所直连的网段

9,添加外部网络设备并配置ip

10,配置nat
	创建acl列表放行所有设备
	acl 2000
	rule permit source any
	in g0/0/2
	nat outbound 2000
11,在路由器配置默认路由,并进入ospf宣告此路由
	ip route-static 0.0.0.0 0 100.0.0.10
	[Huawei]ospf
	[Huawei-ospf-1]default-route-advertise 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                            其它内容
 1, 破解密码:
选择模式画面按“e”进入编辑模式

光标移动到linux16开头的行

在行尾输入：空格 rd.break console=tty0

按“Ctrl+x”进入救援模式

mount -o remount,rw /sysroot		#以可读写的方式重新挂载根系统

chroot /sysroot				#切换到根系统

echo "xxxxxx"  |  passwd --stdin root	#设置root密码

touch /.autorelabel			#标记下一次启动时重做SELinux标签

exit

reboot


loop:modulr loaded 


[root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward    //开启路由转发 
(linux可以做软路由充当路由器)



???????????????????????????????????????????????????????????????????????????????

                      shell 

  date 1

shell脚本
/bin/bash   默认解释器
cat /etc/shells   查看所有解释器
yum -y install ksh   安装新解释器

bash优点 
tab建,快捷键,历史记录,管道符,重定向
--------------------------------------------------------------------------
规范的shell脚本
1,声明解释器
2,注释脚本功能,变量含义等等
3,执行代码
--------------------------------------------------------------------------
脚本的运行方式
1, 添加x执行权限  
chmod +x test1.sh
2, 使用解释器执行, 开启子进程
bash test1.sh
3, 使用当前解释器执行,不开启子进程
source test1.sh
. test1.sh
4, 当运行可执行脚本时(绿色)
  ./脚本名
----------------------------------------------------------------------
编写一键部署ftp服务的脚本:
#!/bin/bash
yum -y install vsftpd &> /dev/null
systemctl restart vsftpd
systemctl enable vsftpd
cp /etc/passwd /var/ftp/pub

测试时把防火墙临时关闭
使用真机访问虚拟机的ftp

常量 固定不变
变量 灵活多变
1,自定义变量,名称需要使用大小写字母,数字或下划线,禁止使用特殊符号,不能以数字开头
   变量名称=值
2,环境变量 USER UID HOME HOSTNAME SHELL PATH PS1 PS2
3,位置变量和预定义变量
    $1  $2  $3  $0  $$  $#  $*  $? $!
#!/bin/bash
echo $1   脚本后的第1个参数
echo $2   脚本后的第2个参数
echo $3   脚本后的第3个参数
echo $0   脚本名
echo $$   显示脚本执行时的进程ID号
echo $#   参数的个数
echo $*   所有参数
echo $?   判断上一条指令是否执行成功 0成功   非0失败
echo $!   最后放入后台的进程
编写创建账户与配置密码的脚本:
#!/bin/bash
useradd xyz
echo 123 | passwd --stdin xyz

升级版:
#!/bin/bash
useradd $1
echo $2 | passwd --stdin $1

env 查看所有环境变量
set 查看所有变量
=======================================
变量扩展知识:
""  双引号,界定范围
''   单引号,界定范围,屏蔽特殊符号
``  反撇号 或$() ,获取命令执行的结果
tar -zcf log-`date +%Y-%m-%d`.tar.gz /var/log
-------------------------------------------
使用read功能编写交互式脚本:
#!/bin/bash
read -p "请输入用户名"  User
useradd $User
read -p "请输入密码"  Pass
echo $Pass | passwd --stdin $User
-------------------------------------------
stty -echo  屏蔽回显
stty echo   恢复回显
------------------------------------------
#!/bin/bash
read -p "请输入用户名" User
useradd $User
stty -echo
read -p "请输入密码" Pass
stty echo
echo $Pass | passwd --stdin $User
-------------------------------------------
export 发布全局变量
export a=10  发布新的全局变量
export b  将局部变量扩展为全局变量
export -n a   取消全局变量,恢复为局部变量
unset a  取消变量定义(删除变量)
====================================
shell中的运算
1, expr
expr 1 + 1  加
expr 1 - 1  减
expr 2 \* 2 乘        \ 转义符号,屏蔽之后一个字符的特殊含义
expr 10 / 5 除
expr 10 % 3 求模,相当于取余数
2, $[] 或 $(())
echo $[1+1]
echo $[10-5]
echo $[10*5]
echo $[10/5]
echo $[10%5]
3, let 通常用于变量计算,结果不显示
let a=1+1
let c=c+c
对变量自增减:
				     主流写法(主要掌握)
let a=a+1  相当于    let a++
let a=a-1 		  let a--
let a=a+2  		  let a+=2
let a=a-2  		  let a-=2
let a=a*2  		  let a*=2
let a=a/2  		  let a/=2
let a=a%2  		  let a%=2

4 ,计算器  bc 可以计算小数
echo "1.1+1" | bc
echo "scale=3;10/3" | bc

########################################################


    date 2
回顾
1,声明解释器 
#!/bin/bash
2,注释
#
3,执行代码

bash优点
tab键,快捷键,历史记录,管道符,重定向

变量
1,自定义变量

2,环境变量
USER UID HOME HOSTNAME SHELL PWD PATH PS1 PS2
3,位置变量和预定义变量
$1 $2 $3 ....
$0  $$  $#  $*  $?  $!

变量扩展
""   ''   ``  $()
read -p
stty -echo
stty echo

exprot  发布全局变量
exprot -n 

shell中的运算
1  
expr 1 + 1
expr 1 \* 1
expr 1 % 1
2
$[]  $(())
echo $[1+1]
3
let a=1+1
let a++   let a--
let a+=2  let a%=5
4
echo "scale=3;10/3" | bc

--------------------------------------------------------------
shell中的条件测试:
使用方式
1,test 测试语句
2,[  测试语句 ]
=========================================
测试内容包含:
1,字符串
==是否相等   !=是否不等     -z是否为空
test a == a  或者  [  a == a ]    使用  echo $?查看结果
2,数字
-eq等于  -ne不等于  -gt大于  -ge大于等于  -lt小于  -le小于等于
3,文件
-e 判断文件是否存在,不关心文件类型  -d 判断目录是否存在  -f 判断普通文件是否存在  -r   -w   -x
4,  逻辑测试 
&&并且        之前的任务成功,之后的任务才会执行
||或者           之前的任务失败,之后的任务才会执行

[ $USER == root ] && echo "我 是 管理员"      
-----------------------------------------------------------------------
两个逻辑符号连续使用:
ls a || ls b && ls test1.sh
a
test1.sh
ls a || ls b || ls test1.sh
a
ls a && ls b || ls test1.sh
a
b
-----------------------------------------------------------------------
[ $USER == root ] && echo "我 是 管理员"  ||  echo "我不是管理员"

编写脚本, 每2分钟检测当前登录系统的用户数量,如果超过3人,发邮件通知管理员
#!/bin/bash
n=`who | wc -l`
[ $n -gt 3 ] && echo "有人入侵服务器!隔壁老王来了" | mail -s test root
保存退出之后赋予脚本x权限 
chmod +x test1.sh
然后在计划任务中添加时间频率和执行的脚本路径
crontab -e
*/2 * * * * /opt/test1.sh
-----------------------------------------------------------------------
mail -s test root < 123    使用输入重定向发送邮件
-----------------------------------------------------------------------
shell中的if
单分支
if 条件测试 ;then
	命令序列
fi
双分支
if 条件测试 ;then
	命令序列1
else
	命令序列2
fi
多分支
if 条件测试 ;then
	命令序列1
elif 条件测试 ;then
	命令序列2
else
	命令序列3
fi
------------------------------------------------------------------------
ping -c定义ping次数  -i定义间隔时间,秒  -W等待反馈信息的时间,秒
ping -c 3 -i 0.2 -W 1 172.25.0.10
------------------------------------------------------------------------
使用if双分支编写ping脚本:
#!/bin/bash
ping -c 3 -i 0.2 -W 1 172.25.0.10 &> /dev/null
if [ $? -eq 0 ] ;then
	echo "通了"
else
	echo "不通"
fi
-------------------------------
#!/bin/bash
ping -c 3 -i 0.2 -W 1 $1 &> /dev/null
if [ $? -eq 0 ] ;then
	echo "通了"
else
	echo "不通"
fi
-----------------------------------------------------------------------
使用if多分支编写猜数脚本:
#!/bin/bash
x=$[RANDOM%10]
read -p "请输入一个数字(0-9)"  n
if [ $x -eq $n ] ;then
        echo "猜对了!!"
elif [ $n -lt $x ] ;then
        echo "猜小了"
else
        echo "猜大了"
fi
=================================
for循环:
for 变量名称 in 值1 值2 值3......
do
	执行指令
done

for ((i=1;i<5;i++))     //for(())为类 C 语言的语法格式  
do
echo $i
done
1
2
3
4


-------------------------
1, 循环次数,和值有关   2, 循环时的变量,也和值有关
-------------------------
#!/bin/bash
for i in {1..10}     多个值的简单写法
do
        echo $i
done
--------------------------------- 
#!/bin/bash
a=10
for i in {1..$a}     大括号不支持套用变量
do
        echo $i
done
---------------------------------
#!/bin/bash
a=10
for i in `seq $a`    可以使用seq支持变量
do
        echo $i
done
------------------------------------------------
#!/bin/bash
x=0
y=0
for i in {1..15}
do
    ping -c 3 -i 0.2 -W 1 172.25.0.$i &> /dev/null
    if [ $? -eq 0 ];then
        echo "172.25.0.$i通了"
        let x++
    else
        echo "172.25.0.$i不通"
        let y++
    fi
done
echo "$x台通了,$y台不通"
=======================================
while循环
while 条件测试
do
	执行指令
done
---------------------------------------------
使用while循环编写猜数脚本,猜对为止
#!/bin/bash
x=$[RANDOM%100]
y=0
while :
do
        let y++
        read -p "请输入数字(0-99)" n
        if [ $x -eq $n ];then
                echo "猜对了!!猜了$y次"
                exit
        elif [ $n -lt $x ];then
                echo "猜小了"
        else
                echo "猜大了"
        fi
done

   echo -e "\e[32;1m[OK]\e[0m"     //显示绿色OK 字体粗 1m可以改变字体
    [OK]
   echo -e "\033[32m[OK]\033[0m"    //-e 扩展的用法 显示绿色OK 字体细
    [OK]
   echo -e "\033[行;列H*"            //几行几列显示*

##########################################################################

date 3

回顾
条件测试
1,字符串    ==    !=   -z   ! -z
2,数字  -eq   -ne   -gt   -ge   -lt   -le
3,文件  -e  -d  -f  -r  -w  -x
4,逻辑   &&       ||

if
单分支
if 条件测试 ;then
	命令序列
fi
双分支
if 条件测试 ;then
	命令序列1
else
	命令序列2
fi
多分支
if 条件测试1 ;then
	命令序列1
elif 条件测试2 ;then
	命令序列2
elif 条件测试3;then
	命令序列3
elif 条件测试4 ;then
	命令序列4
.......
else
	命令序列n
fi

ping -c  -i  -W 1

for    有次数限制
for i in 值1 值2 .....
do
	循环任务
done

while :   无限循环
do
	循环任务
	exit
done
=======================================
case分支,相当于简化版本的if,功能不如if强大,但是代码比if精简

case  变量  in
模式1)
    命令序列1 ;;
模式2)
    命令序列2 ;;
    .. ..
*)
    默认命令序列
esac
---------------------------------------------------------
#!/bin/bash
case $1 in
t)
        touch $2 ;;
m)
        mkdir $2 ;;
r)
        rm -rf $2 ;;
*)
        echo "t|m|r"
esac

==============================
使用case分支编写工具脚本:
1,准备工作
scp lnmp_soft.tar.gz root@server0:/opt   将真机的tar包传入虚拟机
tar -xf lnmp_soft.tar.gz  在虚拟机中释放tar包
cp lnmp_soft/nginx-1.12.2.tar.gz /opt  拷贝nginx包到opt
---------------------------------------------------------
编写一键源代码安装nginx的脚本
#!/bin/bash
yum -y install gcc openssl-devel pcre-devel  &> /dev/null
tar -xf nginx-1.12.2.tar.gz
cd nginx-1.12.2
./configure
make
make install
------------------------------------------------------
运行脚本后,nginx自动安装完毕
cd /usr/local/nginx/sbin/    前往nginx主程序所在目录
./nginx    执行程序(开启nginx网站服务)
关闭防火墙后,在真机打开浏览器输入虚拟机的地址可以看到网站
----------------------------------------------------------------------------
#!/bin/bash
case $1 in
st)
        /usr/local/nginx/sbin/nginx ;;
stop)
        /usr/local/nginx/sbin/nginx -s stop ;;
re)
        /usr/local/nginx/sbin/nginx -s stop
        /usr/local/nginx/sbin/nginx ;;
*)
        echo "st开启|stop关闭|re重启"
esac
----------------------------------------------------------------------------
完善脚本:
#!/bin/bash
case $1 in
st)
        /usr/local/nginx/sbin/nginx ;;
stop)
        /usr/local/nginx/sbin/nginx -s stop ;;
re)
        /usr/local/nginx/sbin/nginx -s stop
        /usr/local/nginx/sbin/nginx ;;
sa)
        netstat -ntulp |grep -q nginx
        [ $? -eq 0 ] && echo "服务正在运行" || echo "服务没有开启"  ;;
*)
        echo "st开启|stop关闭|re重启|sa查询状态"
esac
---------------------------------------------------------------------------
修改输出字体颜色
echo -e "\033[32mABCD\033[0m"     输出不通颜色的ABCD
echo -e "\033[33mABCD\033[0m"
echo -e "\033[34mABCD\033[0m"
---------------------------------------------------------------------------
函数 
1）函数的定义方法

格式1：

function  函数名 {
    命令序列
    .. ..
}

格式2：

函数名() {
    命令序列
    .. ..
}
--------------------------------------------------------------
使用函数编写方便调用不同颜色字体的脚本:
#!/bin/bash
cecho (){
echo -e "\033[$1m$2\033[0m"
}

cecho 31 ABCDEFG
cecho 32 ABCDEFG
cecho 33 ABCDEFG
cecho 34 ABCDEFG
cecho 35 ABCDEFG
cecho 36 ABCDEFG
cecho 37 ABCDEFG



#!/bin/bash
abc(){
abc|abc &
}
abc

==================================
循环的控制:
exit        退出脚本
break       终止循环,执行循环之后的任务 
continue	终止当前循环,继续下一次循环
------------------------
#!/bin/bash
for i in {1..10}
do
        [ $i -eq 5 ] && continue
        echo $i
done
echo ok
-------------------------
#!/bin/bash
for i in {1..10}
do
        [ $i -eq 5 ] && break
        echo $i
done
echo ok
=====================================
字符串的处理
1,字符串的截取
${变量名:起始位置:长度}         如果是第1位,那么起始位置是0
b=1802874632   定义变量
echo ${b:3:4}   截取变量的内容从第4位开始截取4位
echo ${b::4}	起始位置是0的话可以省略不写
------------------------------------
编写随机获取1位字符的脚本:
#!/bin/bash
x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQ
RSTUVWXYZ0123456789
n=$[RANDOM%62]
echo ${x:n:1}
-----------------------------------------------------
编写获取随机8位密码的脚本
#!/bin/bash
x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRS
TUVWXYZ0123456789
for i in {1..8}
do
n=$[RANDOM%62]    获取0~61之间的随机数字
p=${x:n:1}        获取1位随机字符
pass=$pass$p      将每次获取的随机字符赋值给变量pass
done
echo $pass
-------------------------------------------------------------------
2,字符串的替换
格式：${变量名/old/new}
b=1802874632    
echo ${b/1/a}     将1替换为a
echo ${b/8/a}	  将8替换为a
echo ${b//8/a}    将所有8替换为a
echo ${b/0/}      将数字0替换为空,相当于删除
----------------------------------------------
3,字符串的删除
${变量名#*关键词}    从左往右删除   掐头
echo $a
root:x:0:0:root:/root:/bin/bash
echo ${a#root}    删除到第一个root
echo ${a##*root}  删除到最后一个root,以及此root左边所有
echo ${a##*/}     删除到最后一个/,以及此/左边所有
echo ${a#*:root}  删除:root,以及左边所有
--------------------------------------------
${变量名%关键词*}    从右往左删除   去尾
echo ${a%bash}   从右往左删除到bash
echo ${a%root*}  从右往左删除到第一个root,以及root右边所有
echo ${a%/*}     从右往左删除到第一个/,以及/右边所有
echo ${a%%/*}    从右往左删除到最后一个/,以及/右边所有
--------------------------------------------
利用字符串删除功能,编写批量修改文件扩展名的脚本:
#!/bin/bash
for i in `ls *.txt`    首先找到修改目标
do
        n=${i%.*}      利用删除中的去尾将扩展名删除,剩下不带扩展名的文件名
        mv $i $n.doc   在将上述文件名与.doc组合,修改为新名字
done

#######################################################################


date 4

回顾
case分支

case 变量 in
模式1)
	命令序列 ;;
模式2)
	命令序列 ;;
*)
	命令序列
esac

函数 可以将公共的语句块存储在一个函数中,达到精简脚本的目的

方式一
function 函数名 {
	命令序列
}
方式二
函数名 (){
	命令序列
}
----------------------------------------
for    
while 
exit
break
continue
-----------------------------
字符串处理
${变量名:}   截取
${变量名/}  替换
${变量名#}  掐头
${变量名%}  去尾
===================================
字符串初值的处理 
${变量名:-} 
[root@server0 opt]# a=
[root@server0 opt]# echo ${a:-123}      当变量是空时调用初值
123
[root@server0 opt]# a=789
[root@server0 opt]# echo ${a:-123}      变量有值时不使用初值
789
-------------------------------------------------------
配置密码时使用初值: 
#!/bin/bash
read -p "请输入用户名"  u
useradd $u
read -p "请输入密码(默认123456)" p
echo ${p:-123456} | passwd --stdin $u
-------------------------------------------------------
正则表达式,使用若干符号配合对应工具,实现对文本的匹配,查找,过滤
基本正则:
^     grep ^root user     搜索以root开头
$	  grep in$ user		  搜索以in结尾
[]	  grep [in] user	  搜索字母i或者n
[^]	  grep [^in] user     搜索除了字母i或者n
grep "." user      搜索任意单个字符,包括空格,但不包括空行
grep "ro*t" user   搜索r?t,r与t之间有没有o都可以
grep ".*"   user   搜索任意, 包括空行
grep "ro\{1,2\}t"  user   搜索rot,其中o可以出现1~2次
grep "ro\{2\}t" user      搜索rot,其中o出现2次
grep "ro\{1,\}t" user     搜索rot,其中o可以出现1次以及1次以上
grep "0:\{2\}" user		  搜索0::
grep "\(0:\)\{2\}" user   搜索0:0:
-----------------------------------------------------------------------
使用扩展正则, 需要用egrep或者 grep -E
grep -E "ro+t" user      搜索rot,o可以出现1次以及1次以上
egrep "ro+t" user	     搜索rot,o可以出现1次以及1次以上
egrep "bi?n" user	     搜索bin,i可以出现0次或者1次
egrep "ro{2}t" user 	 搜索rot,o出现2次
egrep "ro{1,3}t" user 	 搜索rot,o出现1~3次
egrep "ro{2,}t" user 	 搜索rot,o出现2次以及2次以上
grep "\(0:\)\{2\}" user  搜索0:0:
egrep "(0:){2}" user	 使用扩展正则搜索0:0:
egrep "ro|in" user		 搜索ro或者in
grep "\bthe" user1       搜索单词the,前面不能有数字字母下划线

======================================
echo 123 >> 1.txt
vim 
sed  流式编辑器, 非交互式修改文本,而且支持正则表达式,工作方式是逐行处理
使用方式:
1,  sed 选项  (定址符)指令     被处理的文件
2,   前置命令  | sed 选项  (定址符)指令
选项
-n   屏蔽默认输出        -r   支持扩展正则     -i   写入文件
指令
p  输出         d  删除      s  替换

sed -n 'p' user      使用sed输出所有行,屏蔽默认输出
sed -n '1p' user     输出第1行
sed -n '2,4p' user   输出2~4行
sed -n '3p;5p' user  输出第3行和第5行
sed -n '2,+3p' user  输出第2行以及后面的3行
sed -n '1~2p' user   输出奇数行
sed -n '2~2p' user   输出偶数行
sed -n '/bash$/p' user     使用正则输出以bash结尾的行
sed -rn '/root|bin/p' user 使用扩展正则输出有root或者bin的行

sed -n '=' user      显示行号
sed -n '$=' user	 显示最后一行的行号
sed -n '$=' /etc/passwd
sed  'd' user	     删除所有行
sed  '1d' user		 删除第1行
sed  '2,4d' user	 删除2~4行
sed  '3,+2d' user    删除第3行以及后面2行
sed  '2d;5d' user    删除第2行和第5行
sed -i '1,3d' user   删除1~3行,并写入文件

sed 's/xml/XML/'  a.txt		将每行中第1个xml替换为XML
sed 's/xml/XML/3' a.txt 	将每行中的第3个xml替换为XML
sed 's/xml/XML/g' a.txt 	将所有的xml都替换为XML
sed 's/xml//g'     a.txt 	将所有行的xml都删除

/bin/bash 换成 /sbin/sh

sed 's//bin/bash//sbin/sh/' user
sed 's/\/bin\/bash/\/sbin\/sh/' user
sed 's!/bin/bash!/sbin/sh!' user
sed 's(/bin/bash(/sbin/sh(' user
sed 's#/bin/bash#/sbin/sh#' user

编写脚本,对vsftpd服务完成装包配置启服务的过程,其中使用sed完成配置过程,实现服务可以匿名访问并且上传文件.

#!/bin/bash
yum -y install vsftpd &> /dev/null
sed -i '/anon_up/s/#//'   /etc/vsftpd/vsftpd.conf
systemctl restart vsftpd
systemctl enable vsftpd
systemctl stop firewalld
setenforce 0
chmod 777 /var/ftp/pub

====================================================
sed -i 's/#anon_up/anon_up/'   /etc/vsftpd/vsftpd.conf

ab -c 人数 -n 总次数 网站(http://)     //同时访问同一个网站

##################################################################

date 5




sed 选项  (定址符)指令    处理的文件
前置指令 |  sed 选项  (定址符)指令
-n   -r   -i     p    d    s

cat nssw.txt

Hello th6e World
ni ha7o ma beijing

删除文件中每行的第二个、最后一个字符
sed 's/.//2;s/.$//' u

将文件中每行的第一个、倒数第1个字符互换
( )  保留(相当于复制)   \1 \2 相当于粘贴
sed -r 's/^(.)(.*)(.)$/\3\2\1/' u

删除文件中所有的数字
sed 's/[0-9]//g' u

为文件中每个大写字母添加括号
sed -r 's/([A-Z])/(\1)/g' u
----------------------------------------------------------------------
a在行下追加    i在行上添加    c替换整行

sed 'i XXXX' a        所有行上添加XXXX
sed '1i XXXX' a       第一行上添加XXXX
sed '1,2i XXXX' a     1~2行上添加
sed '1a XXXX' a       第一行下追加
sed 'c XXXX' a        所有行替换为XXXX
sed '1c XXXX' a       第一行替换
sed '/abc/c XXXX' a   有abc的行替换

-----------------------------------------------------------------------
编写脚本,找出使用bash的用户,按照 名字 --> 密码  的格式输出: 
#!/bin/bash
u=`sed -n '/bash$/s/:.*//p' /etc/passwd`    找到用bash的用户,并且把名字都存在变量u中
for i in $u   将变量u交给for循环处理
do
	x=`grep $i: /etc/shadow`   第一次循环,变量i是第一个用户
	a1=${x#*:}		掐头
	a2=${a1%%:*}    去尾
	echo "$i --> $a2"     输出
done

========================================
正则     
grep   模糊搜索
sed    可以修改文档
awk    精确搜索
------------------------------------------------
awk使用方式:
1 ,  awk 选项  (条件)指令   被处理的文件
2 ,    前置命令  |   awk 选项  (条件)指令  
选项:
-F 定义分隔符    
指令
print  输出
内置变量:
列  $0  $1  $2  $3 ...... NF列   NR行

awk '{print}' u
awk '{print $2}' u
awk '{print $0}' u
awk '{print $1}' u
awk '{print $1 $3}' u
awk '{print $1,$3}' u
awk '{print $0,$3}' u
awk '/beijing/{print}' u
----------------------------------------------------
cat user    准备素材
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
awk -F: '{print $6}' user  修改分隔符为冒号, 显示第6列
/root
/bin
awk -F: '/root/{print $6}' user   配合正则匹配有root的行,显示第6列
/root
awk -F/ '/root/{print $3}' user   修改分隔符,显示第3列
bin
awk -F[:/] '/root/{print $9}' user  使用冒号或者斜杠做分隔符,显示第9列
awk -F: '{print $1"的解释器是"$7}' user  输出常量,需要使用引号
awk -F: '{print $1 abc $7}' user    不加引号,系统会识别为变量,如果变量没有定义,则输出的值为空
awk -F: '{print $1 "abc" $7}' user  加引号,变常量输出
awk -F: '{print NR,NF}' user     输出行号和列号
----------------------------------------------------------------------------------------
ifconfig eth0 |awk '/TX p/{print "当前主机eth0网卡的发送流量是"$5"字节"}'
ifconfig eth0 |awk '/RX p/{print "当前主机eth0网卡的接收流量是"$5"字节"}'
df -h | awk '/vda1/{print "主机根分区剩余空间是"$4}'
----------------------------------------------------------------------------------------
使用awk,筛选出远程登录本机密码输入失败的主机ip:
awk '/Failed/{print $11}' /var/log/secure
----------------------------------------------------------------------------------------
awk的工作流程控制
BEGIN任务    执行1次
逐行任务       执行N次
END任务        执行1次
----------------------------------
awk 'BEGIN{x=10;print x}'    仅仅使用begin任务,执行1次
----------------------------------
awk 'BEGIN{print "x"}{print "A"}' user   执行1次begin任务,然后在执行逐行任务,逐行任务的执行次数与user文本的行数有关
----------------------------------
awk 'BEGIN{print "x"}{print "A"}END{print "Q"}' user   分别给begin,逐行,end 三个任务
----------------------------------------------------------------------------------------
\t  制表符  相当于tab键, 可以起到一定的排版效果
------------------------------------
awk -F: 'BEGIN{print "User\tUID\tHome"}{print $1"\t"$3"\t"$6}END{print "总计 "NR" 行"}' user 
==============================================
awk的条件
1,使用正则匹配
    ~   包含
awk '/bin/' user          输出含有bin的行
awk -F: '$1~/bin/' user   输出第一列包含bin的行
awk -F: '$1!~/bin/' user    输出第1列不包含bin的行
awk -F: '$1!~/^(bin|root)/' user   输出第1列不包含以bin或者root开头的行
-----------------------------------------
2,使用数值/字符串比较设置条件
==(等于)    !=（不等于） >（大于）
>=（大于等于） <（小于） <=（小于等于）
awk 'NR==2{print}' user   输出第2行内容
awk -F: '$1=="root"' user    输出第1列是root的行
awk -F: '$1!="root"' user    输出第1列不是root的行
awk -F: '$3=="0"' user       输出第3列是0的行
awk -F: '$3<10' /etc/passwd   输出第3列小于10的行
awk -F: 'NR<10' /etc/passwd   输出小于10行的内容,相当于输出1~9行
awk -F: '$3>=1000' /etc/passwd   输出第3列大于等于1000的行
--------------------------------------------
3,使用逻辑符号     &&并且       ||或者
---------------------------------------------
4,计算
awk 'BEGIN{x++;print x}'   
awk 'BEGIN{print 2*3}'     
awk 'BEGIN{a=10;b=20;print a*b}'
awk 'BEGIN{print 23%8}'
seq 200 | awk '$1%33==0'

#############################################################################

date 6

案例1：awk流程控制
案例2：awk扩展应用
案例3：编写监控脚本
案例4：编写安全检测脚本
1 案例1：awk流程控制
1.1 问题

本案例要求了解awk的流程控制操作，可自行设置awk语句来有验证以下操作：
if分支结构（单分支、双分支、多分支）
练习awk数组的使用
1.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：awk过滤中的if分支结构

1）单分支
统计/etc/passwd文件中UID小于或等于1000的用户个数：
[root@svr5 ~]# awk -F: '{if($3<=1000){i++}}END{print i}' /etc/passwd
39
统计/etc/passwd文件中UID大于1000的用户个数：
[root@svr5 ~]# awk -F: '{if($3>1000){i++}}END{print i}' /etc/passwd
8
统计/etc/passwd文件中登录Shell是“/bin/bash”的用户个数：
[root@svr5 ~]# awk -F: '{if($7~/bash$/){i++}}END{print i}'  /etc/passwd
29
2）双分支
分别统计/etc/passwd文件中UID小于或等于1000、UID大于1000的用户个数：
[root@svr5 ~]# awk -F: '{if($3<=1000){i++}else{j++}}END{print i,j}' /etc/passwd
39 8
分别统计/etc/passwd文件中登录Shell是“/bin/bash”、 登录Shell不是“/bin/bash”的用户个数：
[root@svr5 ~]# awk -F: '{if($7~/bash$/){i++}else{j++}} END{print i,j}' /etc/passwd
29 38
步骤二：awk数组

1）数组的语法格式
数组是一个可以存储多个值的变量，具体使用的格式如下：
定义数组的格式：数组名[下标]=元素值
调用数组的格式：数组名[下标]
遍历数组的用法：for(变量 in 数组名){print 数组名[变量]}。
[root@svr5 ~]# awk 'BEGIN{a[0]=11;a[1]=88;print a[1],a[0]}'
88 11
[root@svr5 ~]# awk 'BEGIN{a++;print a}'
1
[root@svr5 ~]# awk 'BEGIN{a0++;print a0}'
1
[root@svr5 ~]# awk 'BEGIN{a[0]++;print a[0]}'
1
[root@svr5 ~]# awk 'BEGIN{a[0]=0;a[1]=11;a[2]=22; for(i in a){print i,a[i]}}'
0 0
1 11
2 22
注意，awk数组的下标除了可以使用数字，也可以使用字符串，字符串需要使用双引号：
[root@svr5 ~]# awk 'BEGIN{a["hehe"]=11;print a["hehe"]}'
11
2 案例2：awk扩展应用
2.1 问题

本案例要求使用awk工具完成下列两个任务：
分析Web日志的访问量排名，要求获得客户机的地址、访问次数，并且按照访问次数排名
2.2 方案

1）awk统计Web访问排名
在分析Web日志文件时，每条访问记录的第一列就是客户机的IP地址，其中会有很多重复的IP地址。因此只用awk提取出这一列是不够的，还需要统计重复记录的数量并且进行排序。
通过awk提取信息时，利用IP地址作为数组下标，每遇到一个重复值就将此数组元素递增1，最终就获得了这个IP地址出现的次数。
针对文本排序输出可以采用sort命令，相关的常见选项为-r、-n、-k。其中-n表示按数字顺序升序排列，而-r表示反序，-k可以指定按第几个字段来排序。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：统计Web访问量排名

分步测试、验证效果如下所述。
1）提取IP地址及访问量
[root@svr5 ~]# awk '{ip[$1]++} \
>  END{for(i in ip) {print ip[i],i }}' /var/log/httpd/access_log
4  127.0.0.1
17 192.168.4.5
13 192.168.4.110
.. ..
2）对第1）步的结果根据访问量排名
[root@svr5 ~]# awk  '{ip[$1]++} END{for(i in ip) {print i,ip[i]}}' /var/log/httpd/access_log | sort -nr
17 192.168.4.5
13 192.168.4.110
4 127.0.0.1
.. ..
3 案例3：编写监控脚本
3.1 问题

本案例要求编写脚本，实现计算机各个性能数据监控的功能，具体监控项目要求如下：
CPU负载
网卡流量
内存剩余容量
磁盘剩余容量
计算机账户数量
当前登录账户数量
计算机当前开启的进程数量
本机已安装的软件包数量
3.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：准备工作

1）查看性能数据的命令
[root@svr5 ~]# uptime                            //查看CPU负载
[root@svr5 ~]# ifconfig eth0                    //查看网卡流量
[root@svr5 ~]# free                            //查看内存信息
[root@svr5 ~]# df                                //查看磁盘空间
[root@svr5 ~]# wc -l /etc/passwd                //查看计算机账户数量
[root@svr5 ~]# who |wc -l                        //查看登录账户数量
[root@svr5 ~]# rpm -qa |wc -l                    //查看已安装软件包数量
步骤二：编写参考脚本

1）脚本内容如下：
[root@svr5 ~]# vim test.sh
#!/bin/bash
ip=`ifconfig eth0 | awk '/inet /{print $2}'`
echo "本地IP地址是:"$ip
cpu=`uptime | awk '{print $NF}'`            
#awk中NF为当前行的列数，$NF是最后一列
echo "本机CPU最近15分钟的负载是:"$cpu
net_in=`ifconfig eth0 | awk '/RX p/{print $5}'`
echo "入站网卡流量为:"$net_in
net_out=`ifconfig eth0 | awk '/TX p/{print $5}'`
echo "出站网卡流量为:"$net_out
mem=`free | awk '/Mem/{print $4}'`
echo "内存剩余容量为:"$mem
disk=`df | awk '/\/$/{print $4}'`
echo "根分区剩余容量为:"$disk
user=`cat /etc/passwd |wc -l`
echo "本地账户数量为:"$user
login=`who | wc -l`
echo "当前登陆计算机的账户数量为:"$login
process=`ps aux | wc -l`
echo "当前计算机启动的进程数量为:"$process
soft=`rpm -qa | wc -l`
echo "当前计算机已安装的软件数量为:"$soft
4 案例4：编写安全检测脚本
4.1 问题

本案例要求编写脚本，防止远程ssh暴力破解密码，具体监控项目要求如下：
检测ssh登录日志，如果远程登陆账号名错误3次，则屏蔽远程主机的IP
检测ssh登录日志，如果远程登陆密码错误3次，则屏蔽远程主机的IP
4.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：准备工作

1）过滤帐户名失败的命令(登陆日志文件为/var/log/secure)
[root@svr5 ~]# awk '/Invalid user/{print $10}' /var/log/secure
2）过滤密码失败的命令
[root@svr5 ~]# awk '/Failed password/{print $11}' /var/log/secure
步骤二：编写参考脚本

1）脚本内容如下：
[root@svr5 ~]# vim test.sh
#!/bin/bash
awk '/Failed password/{print $11}' /var/log/secure  | awk '{ip[$1]++}END{for(i in ip){print ip[i],i}}' | awk '$1>3{print $2}'
awk '/Invalid user/{print $10}' /var/log/secure  | awk '{ip[$1]++}END{for(i in ip){print ip[i],i}}' | awk '$1>3{print $2}'

########################################################################
           
                 OPERATION

Top
NSD Operation DAY01

案例1：搭建Nginx服务器
案例2：用户认证
案例3：基于域名的虚拟主机
案例4：SSL虚拟主机
1 案例1：搭建Nginx服务器
1.1 问题

在IP地址为192.168.4.5的主机上安装部署Nginx服务，并可以将Nginx服务器，要求编译时启用如下功能：
支持SSL加密功能
设置Nginx账户及组名称均为nginx
Nginx服务器升级到更高版本。
然后客户端访问页面验证Nginx Web服务器：
使用火狐浏览器访问
使用curl访问
1.2 方案

提前准备运维课程所需的所有虚拟机，为后续所有实验做准备，克隆4台RHEL7虚拟机，实验环境所需要的主机及对应的IP设置列表如表-1所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。不需要配置网关与DNS。
表－1 主机列表

第一天课程需要使用2台RHEL7虚拟机，其中一台作为Nginx服务器（192.168.4.5）、另外一台作为测试用的Linux客户机（192.168.4.10），如图-1所示。

图-1
安装nginx-1.10.3版本时，需要使用如下参数：
--with-http_ssl_module：提供SSL加密功能
--user：指定账户
--group：指定组
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：构建Nginx服务器

1）使用源码包安装nginx软件包
[root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        //安装依赖包
[root@proxy ~]# useradd -s /sbin/nologin nginx
[root@proxy ~]# tar  -xf   nginx-1.10.3.tar.gz
[root@proxy ~]# cd  nginx-1.10.3
[root@proxy nginx-1.10.3]# ./configure   \
> --prefix=/usr/local/nginx   \                //指定安装路径
> --user=nginx   \                            //指定用户
> --group=nginx  \                            //指定组
> --with-http_ssl_module                        //开启SSL加密功能
[root@proxy nginx-1.10.3]# make && make install    //编译并安装
2）nginx命令的用法
[root@proxy ~]# /usr/local/nginx/sbin/nginx                    //启动服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s stop            //关闭服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload        //重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx -V                //查看软件信息
[root@proxy ~]# ln -s /usr/local/nginx/sbin/nginx /sbin/        //方便后期使用
netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）
nginx服务默认通过TCP 80端口监听客户端请求：
root@proxy ~]# netstat  -anptu  |  grep nginx
tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx
3）设置防火墙与SELinux（非必须的操作，如果有则关闭）
[root@proxy ~]# systemctl stop firewalld
[root@proxy ~]# setenforce 0
4）测试首页文件
Nginx Web服务默认首页文档存储目录为/usr/local/nginx/html/，在此目录下默认有一个名为index.html的文件，使用客户端访问测试页面：
[root@client ~]# curl http://192.168.4.5
<html>
<head>
<title>Welcome to nginx!</title>
</head>
<body bgcolor="white" text="black">
<center><h1>Welcome to nginx!</h1></center>
</body>
</html>
步骤二：升级Nginx服务器

1）编译新版本nginx软件
[root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --prefix=/usr/local/nginx   \ 
> --user=nginx   \ 
> --group=nginx  \ 
> --with-http_ssl_module
[root@proxy nginx-1.12.2]# make            
2) 备份老的nginx主程序，并使用编译好的新版本nginx替换老版本
[root@proxy nginx-1.12.2]# mv /usr/local/nginx/sbin/nginx  \
>/usr/local/nginx/sbin/nginxold
[root@proxy nginx-1.12.2]# cp objs/nginx  /usr/local/nginx/sbin/         //拷贝新版本
[root@proxy nginx-1.12.2]# make upgrade                            //升级
#或者使用killall nginx杀死进程后再启动nginx。
/usr/local/nginx/sbin/nginx -t
nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`
sleep 1
test -f /usr/local/nginx/logs/nginx.pid.oldbin
kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`
[root@proxy ~]# /usr/local/nginx/sbin/nginx -V                //查看版本
步骤三：客户端访问测试

1）分别使用浏览器和命令行工具curl测试服务器页面
如果使用firefox火狐浏览器，注意在ssh远程的时候一定要加-X选项。
[root@client ~]# firefox http://192.168.4.5
[root@client ~]# curl http://192.168.4.5
2 案例2：用户认证
2.1 问题

沿用练习一，通过调整Nginx服务端配置，实现以下目标：
访问Web页面需要进行用户认证
用户名为：tom，密码为：123456
2.2 方案

通过Nginx实现Web页面的认证，需要修改Nginx配置文件，在配置文件中添加auth语句实现用户认证。最后使用htpasswd命令创建用户及密码即可。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：修改Nginx配置文件

1）修改/usr/local/nginx/conf/nginx.conf
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
        auth_basic "Input Password:";                        //认证提示符信息
        auth_basic_user_file "/usr/local/nginx/pass";        //认证的密码文件
        location / {
            root   html;
            index  index.html index.htm;
        }
  }
2）生成密码文件，创建用户及密码
使用htpasswd命令创建账户文件，需要确保系统中已经安装了httpd-tools。
[root@proxy ~]# yum -y install  httpd-tools
[root@proxy ~]# htpasswd -c /usr/local/nginx/pass   tom        //创建密码文件
New password: 
Re-type new password: 
Adding password for user tom
[root@proxy ~]# htpasswd  /usr/local/nginx/pass   jerry      //追加用户，不使用-c选项
New password: 
Re-type new password: 
Adding password for user jerry
[root@proxy ~]# cat /usr/local/nginx/pass
3）重新加载配置
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload    //重新加载配置文件    
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤二：客户端测试

1）登录192.168.4.10客户端主机进行测试
如果使用firefox火狐浏览器，注意在ssh远程的时候一定要加-X选项。
或者直接使用真实主机的火狐也可以。
[root@client ~]# firefox http://192.168.4.5                    //输入密码后可以访问
3 案例3：基于域名的虚拟主机
3.1 问题

沿用练习二，配置基于域名的虚拟主机，实现以下目标：
实现两个基于域名的虚拟主机，域名分别为www.a.com和www.b.com
对域名为www.a.com的站点进行用户认证，用户名称为tom，密码为123456
3.2 方案

修改Nginx配置文件，添加server容器实现虚拟主机功能；对于需要进行用户认证的虚拟主机添加auth认证语句。
虚拟主机一般可用分为：基于域名、基于IP和基于端口的虚拟主机。
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：修改配置文件

1）修改Nginx服务配置，添加相关虚拟主机配置如下
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;                                      //端口
        server_name  www.a.com;                                //域名
auth_basic "Input Password:";                        //认证提示符
        auth_basic_user_file "/usr/local/nginx/pass";        //认证密码文件
location / {
            root   html;                                    //指定网站根路径
            index  index.html index.htm;
       }
       
}
… …
    server {
        listen  80;                                        //端口
        server_name  www.b.com;                                //域名
location / { 
root   www;                                 //指定网站根路径
index  index.html index.htm;
}
}
2）创建网站根目录及对应首页文件
[root@proxy ~]# mkdir /usr/local/nginx/www
[root@proxy ~]# echo "www" > /usr/local/nginx/www/index.html
3）重新加载配置
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤二：客户端测试

1）修改客户端主机192.168.4.10的/etc/hosts文件，进行域名解析
 [root@client ~]# vim /etc/hosts
192.168.4.5    www.a.com  www.b.com
2）登录192.168.4.10客户端主机进行测试
注意：请先关闭真实机的firefox，再SSH -X远程连接调用虚拟机的firefox。
[root@client ~]# firefox http://www.a.com            //输入密码后可以访问
[root@client ~]# firefox http://www.b.com            //直接访问
提示：或者直接使用真实主机做客户端主机验证，修改真实主机的/etc/hosts文件，直接使用真实主机的火狐浏览器访问也可以。
步骤三：扩展课外实验：其他类型的虚拟主机

1.基于端口的虚拟主机（参考模板）
server {
        listen       8080;                        //端口
        server_name  web1.example.com;          //域名
        ......
}
    server {
        listen       8000;                         //端口
        server_name  web1.example.com;           //域名
      .......
}
2.基于IP的虚拟主机（参考模板）
server {
        listen       192.168.0.1:80;              //IP地址与端口
        server_name  web1.example.com;          //域名
  ... ...
}
    server {
        listen       192.168.0.2:80;             //IP地址与端口
        server_name  web1.example.com;
... ...
}
4 案例4：SSL虚拟主机
4.1 问题

沿用练习三，配置基于加密网站的虚拟主机，实现以下目标：
域名为www.c.com
该站点通过https访问
通过私钥、证书对该站点所有数据加密
4.2 方案

源码安装Nginx时必须使用--with-http_ssl_module参数，启用加密模块，对于需要进行SSL加密处理的站点添加ssl相关指令（设置网站需要的私钥和证书）。
加密算法一般分为对称算法、非对称算法、信息摘要。
对称算法有：AES、DES，主要应用在单机数据加密。
非对称算法有：RSA、DSA，主要应用在网络数据加密。
信息摘要：MD5、sha256，主要应用在数据完整性校验。
4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置SSL虚拟主机
1）生成私钥与证书
[root@proxy ~]# cd /usr/local/nginx/conf
[root@proxy ~]# openssl genrsa > cert.key                            //生成私钥
[root@proxy ~]# openssl req -new -x509 -key cert.key > cert.pem      //生成证书
2）修改Nginx配置文件，设置加密网站的虚拟主机
[root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
… …    
server {
        listen       443 ssl;
        server_name            www.c.com;
        ssl_certificate      cert.pem;         #这里是证书文件
        ssl_certificate_key  cert.key;         #这里是私钥文件
        ssl_session_cache    shared:SSL:1m;
        ssl_session_timeout  5m;
        ssl_ciphers  HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers  on;
        location / {
            root   html;
            index  index.html index.htm;
        }
    }
3）重新加载配置
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤二：客户端验证
1）修改客户端主机192.168.4.10的/etc/hosts文件，进行域名解析
[root@client ~]# vim /etc/hosts
192.168.4.5    www.c.com  www.a.com   www.b.com
2）登录192.168.4.10客户端主机进行测试
[root@client ~]# firefox https://www.c.com            //信任证书后可以访问
          
##############################################################################


 
NSD OPERATION DAY02

案例1：部署LNMP环境
案例2：构建LNMP平台
案例3：地址重写
1 案例1：部署LNMP环境
1.1 问题

安装部署Nginx、MariaDB、PHP环境
安装部署Nginx、MariaDB、PHP、PHP-FPM；
启动Nginx、MariaDB、FPM服务；
并测试LNMP是否工作正常。
1.2 方案

LNMP（Linux、Nginx、MySQL、PHP）
在RHEL7系统中，源码安装Nginx，使用RPM包安装MariaDB、PHP、PHP-FPM软件。
操作过程中需要安装的软件列表如下：
nginx
mariadb、mariadb-server、mariadb-devel
php、php-fpm、php-mysql
备注：mariadb（数据库客户端软件）、mariadb-server（数据库服务器软件）、mariadb-devel（其他客户端软件的依赖包）、php（解释器）、php-fpm（进程管理器服务）、php-mysql（PHP的数据库扩展包）。
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：安装软件

1）使用yum安装基础依赖包
[root@proxy ~]# yum -y install gcc openssl-devel pcre-devel
2）源码安装Nginx（如果前面课程中已经安装Nginx，则忽略这一步）
[root@proxy ~]# useradd -s /sbin/nologin  nginx
[root@proxy ~]# tar -xvf nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --user=nginx   --group=nginx \
> --with-http_ssl_module
[root@proxy ~]# make && make install
.. ..
3）安装MariaDB
Mariadb在新版RHEL7光盘中包含有该软件，配置yum源后可以直接使用yum安装：
[root@proxy ~]# yum -y install   mariadb   mariadb-server   mariadb-devel
4）php和php-fpm
[root@proxy ~]# yum -y  install  php   php-mysql
[root@proxy ~]# yum -y  install  php-fpm
步骤二：启动服务

1）启动Nginx服务（如果已经启动nginx，则可以忽略这一步）
这里需要注意的是，如果服务器上已经启动了其他监听80端口的服务软件（如httpd），则需要先关闭该服务，否则会出现冲突。
[root@proxy ~]# systemctl stop httpd                   //如果该服务存在则关闭该服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx             //启动Nginx服务
[root@proxy ~]# netstat -utnlp | grep :80
tcp    0    0 0.0.0.0:80        0.0.0.0:*        LISTEN        32428/nginx         
2）启动MySQL服务
[root@proxy ~]# systemctl start  mariadb           //启动服务器
[root@proxy ~]# systemctl status mariadb           //查看服务状态
[root@proxy ~]# systemctl enable mariadb           //设置开机启动
3）启动PHP-FPM服务
[root@proxy ~]# systemctl start php-fpm           //启动服务
[root@proxy ~]# systemctl status php-fpm          //查看服务状态
[root@proxy ~]# systemctl enable php-fpm          //设置开机启动
2 案例2：构建LNMP平台
2.1 问题

沿用练习一，通过调整Nginx服务端配置，实现以下目标：
配置Fast-CGI支持PHP网页
创建PHP测试页面，测试使用PHP连接数据库的效果
2.2 方案

使用2台RHEL7虚拟机，其中一台作为LNMP服务器（192.168.4.5）、另外一台作为测试用的Linux客户机（192.168.4.10），如图-1所示。

图-1
Nginx结合FastCGI技术即可支持PHP页面架构，如图-2所示。

图-2
因此本案例，需要延续练习一的实验内容，通过修改Nginx及php-fpm配置文件实现对PHP页面的支持。
注意，FastCGI的内存消耗问题，一个PHP-FPM解释器将消耗约25M的内存。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一： php-fpm配置文件

1）查看php-fpm配置文件（实验中不需要修改该文件）
[root@proxy etc]# vim /etc/php-fpm.d/www.conf
[www]
listen = 127.0.0.1:9000            //PHP端口号
pm.max_children = 32                //最大进程数量
pm.start_servers = 15                //最小进程数量
pm.min_spare_servers = 5            //最少需要几个空闲着的进程
pm.max_spare_servers = 32            //最多允许几个进程处于空闲状态
步骤二：修改Nginx配置文件并启动服务


如果用户访问的是静态,则找到文件直接返回
如果用户访问的是动态,则转发给9000执行脚本,再返回


  location 匹配浏览器的地址栏(从域名后开始)
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
location / {                          //匹配一切 优先级最低;
            root   html;              //找脚本
            index  index.php  index.html   index.htm;

location /abc {deny all}                     //拒绝所有
location /test {deny 192.168.1.1;allow all}   //拒绝1.1,允许其它所有



#设置默认首页为index.php，当用户在浏览器地址栏中只写域名或IP，不说访问什么页面时，服务器会把默认首页index.php返回给用户
        }
 location  ~  \.php$  {                      //支持正则 ~ 包含即可(如果用户访问浏览器的地址栏以.php结尾,那么执行{html找脚本转发给9000}里的)

            root           html;              #找脚本
            fastcgi_pass   127.0.0.1:9000;    #将请求转发给本机9000端口，PHP解释器
            fastcgi_index  index.php;          #首页
            #fastcgi_param   SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi.conf;       #加载其他配置文件
        }
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤三：创建PHP页面，测试LNMP架构能否解析PHP页面

1）创建PHP测试页面1，可以参考lnmp_soft/php_scripts/test.php：
[root@proxy ~]# vim /usr/local/nginx/html/test.php
<?php
$i="This is a test Page";
echo $i;
?>
2）创建PHP测试页面,连接并查询MariaDB数据库。
可以参考lnmp_soft/php_scripts/mysql.php:
[root@proxy ~]# vim /usr/local/nginx/html/mysql.php
<?php
$mysqli = new mysqli('localhost','root','密码','mysql');
//注意：root为mysql数据库的账户名称，密码需要修改为实际mysql密码，无密码则留空即可
//localhost是数据库的域名或IP，mysql是数据库的名称
if (mysqli_connect_errno()){
    die('Unable to connect!'). mysqli_connect_error();
}
$sql = "select * from user";
$result = $mysqli->query($sql);
while($row = $result->fetch_array()){
    printf("Host:%s",$row[0]);
    printf("</br>");
    printf("Name:%s",$row[1]);
    printf("</br>");
}
?>
3）客户端使用浏览器访问服务器PHP首页文档，检验是否成功：
[root@client ~]# firefox http://192.168.4.5/test.php
[root@client ~]# firefox http://192.168.4.5/mysql.php
4）LNMP常见问题
Nginx的默认访问日志文件为/usr/local/nginx/logs/access.log
Nginx的默认错误日志文件为/usr/local/nginx/logs/error.log
PHP默认错误日志文件为/var/log/php-fpm/www-error.log
如果动态网站访问失败，可用参考错误日志，查找错误信息。

3 案例3：地址重写
3.1 问题

沿用练习二，通过调整Nginx服务端配置，实现以下目标：
所有访问a.html的请求，重定向到b.html;
所有访问192.168.4.5的请求重定向至www.tmooc.cn；
所有访问192.168.4.5/下面子页面，重定向至www.tmooc.cn/下相同的页面；
实现firefox与curl访问相同页面文件，返回不同的内容。
3.2 方案

关于Nginx服务器的地址重写，主要用到的配置参数是rewrite：
rewrite regex replacement flag   //regex-->支持正则表达式
rewrite 旧地址 新地址 [选项]
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：修改配置文件(访问a.html重定向到b.html)

1）修改Nginx服务配置：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite /a.html  /b.html;            
location / {
    root   html;
index  index.html index.htm;
}
}
[root@proxy ~]# echo "BB" > /usr/local/nginx/html/b.html
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
3）客户端测试
[root@client ~]# firefox  http://192.168.4.5/a.html
步骤二：访问a.html重定向到b.html（跳转地址栏）

1）修改Nginx服务配置：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite /a.html  /b.html  redirect;  // redirect选项是将地址栏跳到网页实际的地址          
location / {
    root   html;
index  index.html index.htm;
}
}
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端测试（仔细观察浏览器地址栏的变化）
[root@client ~]# firefox  http://192.168.4.5/a.html
步骤三：修改配置文件(访问192.168.4.5的请求重定向至www.tmooc.cn)

1) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite ^/  http://www.tmooc.cn/;
location / {
    root   html;
index  index.html index.htm;
# rewrite /a.html  /b.html  redirect;
}
}
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端测试（真实机测试，真实机才可以连接tmooc）
[root@room9pc01 ~]# firefox  http://192.168.4.5
步骤四：修改配置文件(访问192.168.4.5/下面子页面，重定向至www.tmooc.cn/下相同的页面)

1) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite ^/(.*)$  http://www.tmooc.cn/$1;     //(.*)保留 $1相当于复制;
location / {
    root   html;
index  index.html index.htm;
}
}
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端测试（真实机测试，真实机才可以连接tmooc）
[root@room9pc01 ~]# firefox  http://192.168.4.5
[root@room9pc01 ~]# firefox  http://192.168.4.5/test
步骤五：修改配置文件(实现curl和火狐访问相同链接返回的页面不同)
1) 创建网页目录以及对应的页面文件：
[root@proxy ~]# echo "I am Normal page" > /usr/local/nginx/html/test.html
[root@proxy ~]# mkdir  -p  /usr/local/nginx/html/firefox/
[root@proxy ~]# echo "firefox page" > /usr/local/nginx/html/firefox/test.html
2) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
location / {
    root   html;
index  index.html index.htm;
}

if ($http_user_agent ~* firefox) {            //识别客户端firefox浏览器
rewrite ^(.*)$  /firefox/$1;                  //这里，~符号代表正则匹配，*符号代表不区分大小写
}
}
3）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
4）客户端测试
[root@client ~]# firefox  http://192.168.4.5/test.html
[root@client ~]# curl     http://192.168.4.5/test.html
5）地址重写格式【总结】
rewrite 旧地址 新地址 [选项];
last 不再读其他rewrite
break 不再读其他语句，结束请求
redirect 临时重定向
permament 永久重定向

##########################################################################################

date 3

Top
NSD Operation DAY03

案例1：Nginx反向代理
案例2：Nginx的TCP/UDP调度器
案例3：Nginx常见问题处理
1 案例1：Nginx反向代理
1.1 问题

使用Nginx实现Web反向代理功能，实现如下功能：
后端Web服务器两台，可以使用httpd实现
Nginx采用轮询的方式调用后端Web服务器
两台Web服务器的权重要求设置为不同的值
最大失败次数为1，失败超时时间为30秒
1.2 方案

使用4台RHEL7虚拟机，其中一台作为Nginx代理服务器，该服务器需要配置两块网卡，IP地址分别为192.168.4.5和192.168.2.5，两台Web服务器IP地址分别为192.168.2.100和192.168.2.200。客户端测试主机IP地址为192.168.4.10。如图-1所示。

图-1
1.3 步骤                                           
                                                            --------------->web1(eth1 192.168.2.100)
                                                                             |
                            nginx代理服务器                        |
   client ----------------->proxy ---------------------------
 eth0 192.168.4.10       eth0 192.168.4.5                   |
                         eth0 192.168.2.5                   |
                                                            ---------------->web2(eth1 192.168.2.200)

实现此案例需要按照如下步骤进行。
步骤一：部署实施后端Web服务器

1）部署后端Web1服务器
后端Web服务器可以简单使用yum方式安装httpd实现Web服务，为了可以看出后端服务器的不同，可以将两台后端服务器的首页文档内容设置为不同的内容。
[root@web1 ~]# yum  -y  install  httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
[root@web1 ~]# systemctl restart httpd
[root@web1 ~]# firewall-cmd --set-default-zone=trusted
[root@web1 ~]# setenforce 0
2）部署后端Web2服务器
[root@web2 ~]# yum  -y  install  httpd
[root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html
[root@web2 ~]# systemctl restart httpd
[root@web2 ~]# firewall-cmd --set-default-zone=trusted
[root@web2 ~]# setenforce 0
步骤二：配置Nginx服务器，添加服务器池，实现反向代理功能

1）修改/usr/local/nginx/conf/nginx.conf配置文件
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
.. ..
#使用upstream定义后端服务器集群，集群名称任意(如webserver)
#使用server定义集群中的具体服务器和端口
upstream webserver {
                server 192.168.2.100:80;
                server 192.168.2.200:80;
        }
.. ..
server {
        listen        80;
        server_name  localhost;
            location / {
#通过proxy_pass将用户的请求转发给webserver集群
            proxy_pass http://webserver;
        }
}
2）重新加载配置
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
步骤二：配置upstream服务器集群池属性

1）设置失败次数，超时时间，权重
weight可以设置后台服务器的权重，max_fails可以设置后台服务器的失败次数，fail_timeout可以设置后台服务器的失败超时时间。
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
.. ..
upstream webserver {
                server 192.168.2.100 weight=1 max_fails=1 fail_timeout=30;
                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=30;
                server 192.168.2.101 down;
        }
#weight设置服务器权重值，默认值为1
#max_fails设置最大失败次数
#fail_timeout设置失败超时时间，单位为秒
#down标记服务器已关机，不参与集群调度
.. ..
server {
        listen        80;
        server_name  localhost;
            location / {
            proxy_pass http://webserver;
        }
}
2）重新加载配置
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）关闭一台后端服务器（如web1）
[root@web1 ~]# systemctl stop httpd
4）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
5）再次启动后端服务器的httpd（如web1）
[root@web1 ~]# systemctl start httpd
6）客户端再次使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
步骤三：配置upstream服务器集群的调度算法

1）设置相同客户端访问相同Web服务器
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
.. ..
upstream webserver {
#通过ip_hash设置调度规则为：相同客户端访问相同服务器
                 ip_hash;
                server 192.168.2.100 weight=1 max_fails=2 fail_timeout=10;
                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=10;
        }
.. ..
server {
        listen        80;
        server_name  www.tarena.com;
            location / {
            proxy_pass http://webserver;
        }
}
2）重新加载配置
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果


2 案例2：Nginx的TCP/UDP调度器

2.1 问题

使用Nginx实现TCP/UDP调度器功能，实现如下功能：
后端SSH服务器两台
Nginx编译安装时需要使用--with-stream，开启ngx_stream_core_module模块
Nginx采用轮询的方式调用后端SSH服务器
2.2 方案

使用4台RHEL7虚拟机，其中一台作为Nginx代理服务器，该服务器需要配置两块网卡，IP地址分别为192.168.4.5和192.168.2.5，两台SSH服务器IP地址分别为192.168.2.100和192.168.2.200。客户端测试主机IP地址为192.168.4.10。如图-2所示。

图-2
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署支持4层TCP/UDP代理的Nginx服务器

1）部署nginx服务器
编译安装必须要使用--with-stream参数开启4层代理模块。
[root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        //安装依赖包
[root@proxy ~]# tar  -xf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd  nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --with-http_ssl_module                                //开启SSL加密功能
> --with-stream                                       //开启4层反向代理功能
[root@proxy nginx-1.12.2]# make && make install           //编译并安装
步骤二：配置Nginx服务器，添加服务器池，实现TCP/UDP反向代理功能


注意: stream不要在http{}里:

1）修改/usr/local/nginx/conf/nginx.conf配置文件
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
stream {
            upstream backend {
               server 192.168.2.100:22;            //后端SSH服务器的IP和端口
               server 192.168.2.200:22;
}
            server {
                listen 12345;                    //Nginx监听的端口
                proxy_connect_timeout 1s;         //连接的超时时间，可选配置
                proxy_timeout 3s;
                 proxy_pass backend;
             }
}
http {
.. ..
}
2）重新加载配置
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端使用访问代理服务器测试轮询效果
[root@client ~]# ssh 192.168.4.5 -p 12345            //使用该命令多次访问查看效果,-p 指定端口号
3 案例3：Nginx常见问题处理
3.1 问题

本案例要求对Nginx服务器进行适当优化，解决如下问题，以提升服务器的处理性能：
如何自定义返回给客户端的404错误页面
如何查看服务器状态信息
如果客户端访问服务器提示“Too many open files”如何解决
如何解决客户端访问头部信息过长的问题
如何让客户端浏览器缓存数据
日志切割
开启gzip压缩功能，提高数据传输效率
开启文件缓存功能
然后客户机访问此Web服务器验证效果：
使用ab压力测试软件测试并发量
编写测试脚本生成长头部信息的访问请求
客户端访问不存在的页面，测试404错误页面是否重定向
3.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：自定义报错页面

1）优化前，客户端使用浏览器访问不存在的页面，会提示404文件未找到
[root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面
2）修改Nginx配置文件，自定义报错页面
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
        charset utf-8;                    //仅需要中文时需要改选项，可选项
error_page   404  /404.html;    //自定义错误页面
.. ..
[root@proxy ~]# vim /usr/local/nginx/html/404.html        //生成错误页面
Oops,No NO no page …
[root@proxy ~]# nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）优化后，客户端使用浏览器访问不存在的页面，会提示自己定义的40x.html页面
[root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面
4）常见http状态码
常见http状态码可用参考表-1所示。
表－1 主机列表
200   一切正常
301   永久重定向
302   临时重定向
401   用户名或密码错误
403   禁止访问(客户端IP地址被拒绝)
404   文件不存在
414   请求URI头部过长
500   服务器内部错误
502   Bad Gateway


步骤二：如何查看服务器状态信息（非常重要的功能）

1）编译安装时使用--with-http_stub_status_module开启状态页面模块
[root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd  nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --with-http_ssl_module                        //开启SSL加密功能
> --with-stream                                //开启TCP/UDP代理模块
> --with-http_stub_status_module                //开启status状态页面
[root@proxy nginx-1.12.2]# make && make install    //编译并安装
2）启用Nginx服务并查看监听端口状态
ss命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）
注意：在RHEL7系统中可以使用ss命令替代netstat命令，功能一样，选项一样。
[root@proxy ~]# /usr/local/nginx/sbin/nginx
[root@proxy ~]# netstat  -anptu  |  grep nginx
tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx
[root@proxy ~]# ss  -anptu  |  grep nginx
3）修改Nginx配置文件，定义状态页面
[root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
… …
location /status {
                stub_status on;
                 #allow IP地址;
                 #deny IP地址;
        }
… …
[root@proxy ~]# nginx
4）优化后，查看状态页面信息
[root@proxy ~]# curl  http://192.168.4.5/status
Active connections: 1 
server accepts handled requests   //总值,只增不减
 10 10 3 
Reading: 0 Writing: 1 Waiting: 0
Active connections：当前活动的连接数量(并发量)。
Accepts：已经接受客户端的连接总数量。
Handled：已经处理客户端的连接总数量。
（一般与accepts一致，除非服务器限制了连接数量）。
Requests：客户端发送的请求数量。
Reading：当前服务器正在读取客户端请求头的数量。
Writing：当前服务器正在写响应信息的数量。
Waiting：当前多少客户端在等待服务器的响应。

步骤三：优化Nginx并发量

1）优化前使用ab高并发测试
[root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/   //httpd-tools获得ab命令
               -n 总访问量  -c 人数
Benchmarking 192.168.4.5 (be patient)
socket: Too many open files (24)                //提示打开文件数量过多
2）修改Nginx配置文件，增加并发量
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
worker_processes  2;                    //nginx启动时启动的进程 与CPU核心数量一致
events {
worker_connections 65535;        //每个worker最大并发连接数 (linux端口号最大是65536)
}
.. ..
[root@proxy ~]# nginx -s reload
3）优化Linux内核参数（最大文件数量）
[root@proxy ~]# ulimit -a                        //查看所有属性值
[root@proxy ~]# ulimit -Hn 100000                //设置硬限制（临时规则）
[root@proxy ~]# ulimit -Sn 100000                //设置软限制（临时规则）
[root@proxy ~]# vim /etc/security/limits.conf
    .. ..
*               soft    nofile            100000
*               hard    nofile            100000
#该配置文件分4列，分别如下：
#用户或组    硬限制或软限制    需要限制的项目   限制的值
4）优化后测试服务器并发量（因为客户端没调内核参数，所以在proxy测试）
[root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/
步骤四：优化Nginx数据包头缓存

1）优化前，使用脚本测试长头部请求是否能获得响应
[root@proxy ~]# cat lnmp_soft/buffer.sh 
#!/bin/bash
URL=http://192.168.4.5/index.html?
for i in {1..5000}
do
    URL=${URL}v$i=$i
done
curl $URL                                //经过5000次循环后，生成一个长的URL地址栏
[root@proxy ~]# ./buffer.sh
.. ..
<center><h1>414 Request-URI Too Large</h1></center>        //提示头部信息过大
2）修改Nginx配置文件，增加数据包头部缓存大小
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
client_header_buffer_size    1k;        //默认请求包头信息的缓存    
large_client_header_buffers  4 4k;        //大请求包头部信息的缓存个数与容量
.. ..
}
[root@proxy ~]# nginx -s reload
3）优化后，使用脚本测试长头部请求是否能获得响应
[root@proxy ~]#cat cat buffer.sh 
#!/bin/bash
URL=http://192.168.4.5/index.html?
for i in {1..5000}
do
    URL=${URL}v$i=$i
done
curl $URL
[root@proxy ~]# ./buffer.sh

步骤五：浏览器本地缓存静态数据

1）使用Firefox浏览器查看缓存
以Firefox浏览器为例，在Firefox地址栏内输入about:cache将显示Firefox浏览器的缓存信息，如图-3所示，点击List Cache Entries可以查看详细信息。

图-3
2）清空firefox本地缓存数据，如图-4所示。


图-4
3）修改Nginx配置文件，定义对静态页面的缓存时间
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
server {
        listen       80;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }
location ~* \.(jpg|jpeg|gif|png|css|js|ico|xml)$ {
expires        30d;            //定义客户端缓存时间为30天
}
}
[root@proxy ~]# cp /usr/share/backgrounds/day.jpg /usr/local/nginx/html
[root@proxy ~]# nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
4）优化后，使用Firefox浏览器访问图片，再次查看缓存信息
[root@client ~]# firefox http://192.168.4.5/day.jpg
在firefox地址栏内输入about:cache，查看本地缓存数据，查看是否有图片以及过期时间是否正确。

步骤六：日志切割

日志文件越来越大怎么办？单个文件10G? 如何切割？（非常常见的面试题）
步骤：1. 把旧的日志重命名
2. kill USR1 PID(nginx的进程PID号)    //生成新的日志
1）手动执行
备注：/usr/local/nginx/logs/nginx.pid文件中存放的是nginx的进程PID号。
[root@proxy ~]#  mv access.log access2.log
[root@proxy ~]# kill -USR1 $(cat /usr/local/nginx/logs/nginx.pid) //生成新的日志
2）自动完成
每周5的03点03分自动执行脚本完成日志切割工作。
[root@proxy ~]# vim /usr/local/nginx/logbak.sh
#!/bin/bash
date=`date +%Y%m%d`
logpath=/usr/local/nginx/logs
mv $logpath/access.log $logpath/access-$date.log
mv $logpath/error.log $logpath/error-$date.log
kill -USR1 $(cat $logpath/nginx.pid)
[root@proxy ~]# crontab -e
03 03 * * 5  /usr/local/nginx/logbak.sh
步骤七：对页面进行压缩处理

1）修改Nginx配置文件
[root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
http {
.. ..
gzip on;                            //开启压缩
gzip_min_length 1000;                //小文件不压缩
gzip_comp_level 4;                //压缩比率
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
                                    //对特定文件压缩，类型参考mime.types(/usr/local/nginx/conf/mime.types)
.. ..
}
步骤八：服务器内存缓存

1）如果需要处理大量静态文件，可以将文件缓存在内存，下次访问会更快。
http { 
open_file_cache          max=2000  inactive=20s;
        open_file_cache_valid    60s;
        open_file_cache_min_uses 5;
        open_file_cache_errors   off;
//设置服务器最大缓存2000个文件句柄，关闭20秒内无请求的文件句柄
//文件句柄的有效时间是60秒，60秒后过期
//只有访问次数超过5次会被缓存
//缓存报错日志关闭
} 

###########################################################################

Top
NSD OPERATION DAY04

案例1：PHP的本地Session信息
案例2：构建memcached服务
案例3：LNMP+memcached
案例4：PHP实现session共享
1 案例1：PHP的本地Session信息
1.1 问题

通过Nginx调度器负载后端两台Web服务器，实现以下目标：
部署Nginx为前台调度服务器
调度算法设置为轮询
后端为两台LNMP服务器
部署测试页面，查看PHP本地的Session信息
1.2 方案

概念：
Session：存储在服务器端，保存用户名、登陆状态等信息。
Cookies：由服务器下发给客户端，保存在客户端的一个文件里。
保存的内容主要包括：SessionID。
实验拓扑环境：
使用4台RHEL7虚拟机，其中一台作为Nginx前端调度器服务器（eth0:192.168.4.5,eth1:192.168.2.5）、两台虚拟机部署为LNMP服务器，分别为Web1服务器（192.168.2.100）和Web2服务器（192.168.2.200），另外一台作为测试用的Linux客户机（192.168.4.10），拓扑如图-2所示。

图-2
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署后端LNMP服务器相关软件

注意:以下部署LNMP服务器的操作，需要在两台后端服务器做相同的操作，下面我们以一台Web2服务器（192.168.2.200）为例，对Web1服务器执行相同操作即可。
1）使用yum安装基础依赖包
[root@web2 ~]# yum -y install gcc openssl-devel pcre-devel
.. ..
2）源码安装Nginx
[root@web2 ~]# tar -xf nginx-1.12.2.tar.gz
[root@web2 ~]# cd nginx-1.12.2
[root@web2 nginx-1.12.2]#  ./configure   \
> --with-http_ssl_module 
[root@web2 nginx-1.12.2]# make && make install
3）安装MariaDB数据库
[root@web2 ~]# yum -y install  mariadb  mariadb-server  mariadb-devel
4）安装PHP
[root@web2 ~]# yum -y install  php  php-mysql
[root@web2 ~]# yum -y install  php-fpm
5）修改Nginx配置文件（修改默认首页与动静分离）
[root@web2 ~]# vim /usr/local/nginx/conf/nginx.conf
location / {
            root   html;
            index  index.php  index.html   index.htm;
        }
 location  ~  \.php$  {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
           # fastcgi_param   SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi.conf;
        }
步骤二：启动LNMP服务器相关的服务

1）启动Nginx服务
这里需要注意的是，如果服务器上已经启动了其他监听80端口的服务软件（如httpd），则需要先关闭该服务，否则会出现冲突。
[root@web2 ~]# systemctl stop  httpd                //如果该服务存在，则关闭该服务
[root@web2 ~]# /usr/local/nginx/sbin/nginx
[root@web2 ~]# netstat -utnlp | grep :80
tcp    0    0 0.0.0.0:80        0.0.0.0:*        LISTEN        32428/nginx         
2）启动MySQL服务
[root@web2 ~]# systemctl start mariadb
[root@web2 ~]# systemctl status mariadb
3）启动PHP-FPM服务
[root@web2 ~]# systemctl start  php-fpm
[root@web2 ~]# systemctl status php-fpm
步骤三：部署前端Nginx调度服务器

1）使用源码安装nginx软件（如果Nginx软件包已安装可以忽略此步骤）
[root@proxy ~]# yum  -y  install   gcc pcre-devel openssl-devel
[root@proxy ~]# tar -xf nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure
[root@proxy nginx-1.12.2]# make && make install
2）修改Nginx配置文件，实现代理服务器
Nginx配置文件中，通过upstream定义后端服务器地址池，默认调度策略为轮询，使用proxy_pass调用upstream定义的服务器地址池：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
upstream webs  {
        server 192.168.2.100:80;
        server 192.168.2.200:80;
  }
 server  {
          listen       80;
          server_name  localhost;
          location  /  {
              proxy_pass http://webs;
            root   html;
            index  index.php index.html index.htm;
          }
}
3）重新加载配置文件

[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤四：测试环境是否配置成功

1）浏览器访问测试页面验证。
[root@client ~]# curl  http://192.168.4.5/index.html        //查看是否有数据
步骤五：部署测试页面

1）部署测试页面(Web1服务器）。
测试页面可以参考lnmp_soft/php_scripts/php-memcached-demo.tar.gz。
[root@web1 ~]# cd lnmp_soft/php_scripts/
[root@web1 php_scripts]# tar -xf php-memcached-demo.tar.gz
[root@web1 php_scripts]# cd php-memcached-demo
[root@web1 php-memcached-demo]# cp -r  *  /usr/local/nginx/html/
2）浏览器直接访问后端服务器的测试页面（Web1服务器）。
[root@web1 ~]# firefox http://192.168.2.100            //填写账户信息
[root@web1 ~]# cd /var/lib/php/session/            //查看服务器本地的Session信息
[root@web1 ~]# ls
sess_ahilcq9bguot0vqsjtd84k7244                        //注意这里的ID是随机的
[root@web1 ~]# cat sess_ahilcq9bguot0vqsjtd84k7244
注意：可用修改index.php和home.php两个文件的内容，添加页面颜色属性，以区别后端两台不同的服务器:<body bgcolor=blue>。
3）部署测试页面(Web2服务器）。
测试页面可以参考lnmp_soft/php_scripts/php-memcached-demo.tar.gz。
[root@web2 ~]# cd lnmp_soft/php_scripts/
[root@web2 php_scripts]# tar -xf php-memcached-demo.tar.gz
[root@web2 php_scripts]# cd php-memcached-demo
[root@web2 php-memcached-demo]# cp -a  *  /usr/local/nginx/html/
4）浏览器直接访问后端服务器的测试页面（Web2服务器）。
[root@web2 ~]# firefox http://192.168.2.100             //填写账户信息
[root@web2 ~]# cd /var/lib/php/session/            //查看服务器本地的Session信息
[root@web2 ~]# ls
sess_qqek1tmel07br8f63d6v9ch401                        //注意这里的ID是随机的
[root@web2 ~]# cat sess_qqek1tmel07br8f63d6v9ch401    
注意：可用修改index.php和home.php两个文件的内容，添加页面颜色属性，以区别后端两台不同的服务器:<body bgcolor=green>。
5）浏览器访问前端调度器测试（不同后端服务器Session不一致）。
推荐使用google浏览器测试。
[root@client ~]# google-chrome http://192.168.4.5
//填写注册信息后，刷新，还需要再次注册，说明两台计算机使用的是本地Session
//第二台主机并不知道你再第一台主机已经登录，第一台主机的登录信息也没有传递给第二台主机

2 案例2：构建memcached服务
2.1 问题

本案例要求先快速搭建好一台memcached服务器，并对memcached进行简单的增、删、改、查操作：
安装memcached软件，并启动服务
使用telnet测试memcached服务
对memcached进行增、删、改、查等操作
2.2 方案

使用1台RHEL7虚拟机作为memcached服务器（192.168.4.5）。
在RHEL7系统光盘中包含有memcached，因此需要提前配置yum源，即可直接使用yum安装，客户端测试时需要提前安装telnet远程工具。
验证时需要客户端主机安装telnet，远程memcached来验证服务器的功能：
add name 0 180 10	//变量不存在则添加
set name 0 180 10	//添加或替换变量
replace name 0 180 10	//替换(覆盖现有的变量)
get name	//读取变量
append name 0 180 10	//向变量中追加数据
delete name	//删除变量
flush_all	//清空所有
提示：0表示不压缩，180为数据缓存时间，10为需要存储的数据字节数量。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：构建memcached服务

1）使用yum安装软件包memcached
[root@proxy ~]# yum -y  install   memcached
[root@proxy ~]# rpm -qa memcached
memcached-1.4.15-10.el7_3.1.x86_64
2) memcached配置文件（查看即可，不需要修改）
[root@proxy ~]# vim /usr/lib/systemd/system/memcached.service
ExecStart=/usr/bin/memcached -u $USER -p $PORT -m $CACHESIZE -c $MAXCONN $OPTIONS   //-u 用户 -p 端口 -m 内存 -c 最大连接数
[root@proxy ~]# vim /etc/sysconfig/memcached
PORT="11211"
USER="memcached"
MAXCONN="1024"
CACHESIZE="64"
OPTIONS=""
3）启动服务并查看网络连接状态验证是否开启成功：
ss命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）
注意：在RHEL7系统中，使用ss命令可以替代netstat，功能与选项一样。
[root@proxy ~]# systemctl  start  memcached
[root@proxy ~]# systemctl  status  memcached
[root@proxy ~]# netstat  -anptu  |  grep memcached
tcp    0    0 0.0.0.0:11211        0.0.0.0:*        LISTEN        2839/memcached      
tcp    0    0 :::11211            :::*                LISTEN        2839/memcached      
udp    0    0 0.0.0.0:11211        0.0.0.0:*                    2839/memcached      
udp    0    0 :::11211            :::*                            2839/memcached
[root@proxy ~]# setenforce 0
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
步骤二：使用telnet访问memcached服务器

1）使用yum安装telnet
[root@proxy ~]# yum -y install telnet
2)使用telnet连接服务器测试memcached服务器功能，包括增、删、改、查等操作。  //增(add,set,replace)、删(delete)、改(append)、查(get)
[root@proxy ~]# telnet  192.168.4.5  11211
Trying 192.168.4.5...
……
##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
set name 0 180 3                //定义变量，变量名称为name
plj                            //输入变量的值，值为plj                
STORED
get name                        //获取变量的值
VALUE name 0 3                 //输出结果
plj
END
##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
add myname 0 180 10            //新建，myname不存在则添加，存在则报错
set myname 0 180 10            //添加或替换变量
replace myname 0 180 10        //替换，如果myname不存在则报错
get myname                    //读取变量
append myname 0 180 10        //向变量中追加数据
delete myname                    //删除变量
flush_all                        //清空所有
quit                            //退出登录          
                        
3 案例3：LNMP+memcached
3.1 问题

沿用练习一和练习二，部署LNMP+memcached网站平台,通过PHP页面实现对memcached服务器的数据操作，实现以下目标：
为PHP安装memcache扩展
创建PHP页面，并编写PHP代码，实现对memcached的数据操作
3.2 方案

如果希望使用PHP来操作memcached，注意必须要为PHP安装memcache扩展（php-pecl-memcache），否则PHP无法解析连接memcached的指令。客户端测试时需要提前安装telnet远程工具。
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：创建PHP页面，使用PHP语言测试memcached服务

1）部署测试页面
创建PHP首页文档/usr/local/nginx/html/mem.php，测试页面可以参考lnmp_soft/php_scripts/mem.php。
注意：192.168.2.5是memcached数据库。
 [root@web1 ~]# vim /usr/local/nginx/html/mem.php
<?php
$memcache=new Memcache;                //创建memcache对象
$memcache->connect('192.168.2.5',11211) or die ('could not connect!!');
$memcache->set('key','test');             //定义变量
$get_values=$memcache->get('key');        //获取变量值
echo $get_values;
?>
2）客户端测试（结果会失败）
客户端使用浏览器访问服务器PHP首页文档，检验对memcached的操作是否成功：
[root@web1 ~]# firefox http://192.168.2.100/mem.php
注意：这里因为没有给PHP安装扩展包，默认PHP无法连接memcached数据库，需要给PHP安装扩展模块才可以连接memcached数据库。
3）为PHP添加memcache扩展
[root@web1 ~]# yum -y install  php-pecl-memcache
[root@web1 ~]# systemctl restart php-fpm
4）客户端再次测试（结果会成功显示数据结果）
[root@web1 ~]# firefox http://192.168.2.100/mem.php


4 案例4：PHP实现session共享
4.1 问题

沿用练习三，通过修改PHP-FPM配置文件，实现session会话共享：
配置PHP使用memcached服务器共享Session信息
客户端访问两台不同的后端Web服务器时，Session 信息一致
4.2 方案

在练习三拓扑的基础上，Nginx服务器除了承担调度器外，还需要担任memcached数据库的角色，并在两台后端LNMP服务器上实现PHP的session会话共享。拓扑结构如图-4所示。

图-4
4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：在后端LNMP服务器上部署Session共享

注意：这些操作在两台后端Web服务器上均需要执行，以下操作以Web1（192.168.2.100）服务器为例。
1）为PHP添加memcache扩展
注意，因为后端两台web服务器(web1,web2)都需要连接memcached数据库，所以两台主机都需要安装PHP扩展模块(下面也web1为例)。
[root@web1 ~]# yum -y install  php-pecl-memcache
2）修改PHP-FPM配置文件，并重启服务
注意，因为后端两台web服务器(web1,web2)都需要修改配置文件(下面也web1为例)。
[root@web1 ~]# vim  /etc/php-fpm.d/www.conf            //修改该配置文件的两个参数
//文件的最后2行
修改前效果如下:
php_value[session.save_handler] = files
php_value[session.save_path] = /var/lib/php/session
//原始文件，默认定义Sessoin会话信息本地计算机（默认在/var/lib/php/session）
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
修改后效果如下:
php_value[session.save_handler] = memcache
php_value[session.save_path] = "tcp://192.168.2.5:11211"
//定义Session信息存储在公共的memcached服务器上，主机参数中为memcache（没有d）
//通过path参数定义公共的memcached服务器在哪（服务器的IP和端口）
[root@web1 ~]# systemctl  restart  php-fpm
步骤三：客户端测试

客户端使用浏览器访问两台不同的Web服务器。
操作步骤参考练习一，最终可以获得相关的Session ID信息。

################################################################################



Top
NSD OPERATION DAY05

案例1：安装部署Tomcat服务器
案例2：使用Tomcat部署虚拟主机
案例3：使用Varnish加速Web

java SE(标准版)
java EE(企业版)
java ME(移动版)


httpd,nginx,...(PHP , python) 网站
LNMP  , LAMP

java支持的网站: (sun) ---Oracle  
tomcat(Apache开源),weblogic(Oracle),websphere(IBM),jboss(redhat)

1 案例1：安装部署Tomcat服务器
1.1 问题

本案例要求部署Tomcat服务器，具体要求如下：
安装部署JDK基础环境
安装部署Tomcat服务器
创建JSP测试页面，文件名为test.jsp，显示服务器当前时间
然后客户机访问此Web服务器验证效果：
使用火狐浏览器访问Tomcat服务器的8080端口，浏览默认首页
使用火狐浏览器访问Tomcat服务器的8080端口，浏览默认测试页面
1.2 方案

使用2台RHEL7虚拟机，其中一台作为Tomcat服务器（192.168.2.100）、另外一台作为测试用的Linux客户机（192.168.2.5），如图-1所示。

图-1
使用RPM安装JDK基础环境
使用源码安装部署Tomcat服务器
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署Tomcat服务器软件(192.168.2.100/24)

1）使用RPM安装JDK环境
[root@web1 ~]# yum -y install  java-1.8.0-openjdk                //安装JDK
[root@web1 ~]# yum -y install java-1.8.0-openjdk-headless        //安装JDK
[root@web1 ~]# java -version                                    //查看JAVA版本
2）安装Tomcat（apache-tomcat-8.0.30.tar.gz软件包，在lnmp_soft中有提供）
[root@web1 ~]# tar -xf  apache-tomcat-8.0.30.tar.gz
[root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
[root@web1 ~]# ls /usr/local/tomcat
bin/                                            //主程序目录
lib/                                            //库文件目录
logs/                                          //日志目录  
temp/                                         //临时目录
work/                                        //自动编译目录jsp代码转换servlet
conf/                                        //配置文件目录
webapps/                                        //页面目录
3）启动服务
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
4）服务器验证端口信息
[root@web1 ~]# netstat -nutlp |grep java        //查看java监听的端口
tcp        0      0 :::8080              :::*                LISTEN      2778/java 
tcp        0      0 :::8009              :::*                LISTEN      2778/java                     
tcp        0      0 ::ffff:127.0.0.1:8005     :::*         LISTEN       2778/java 
提示：如果检查端口时，8005端口启动非常慢，默认tomcat启动需要从/dev/random读取大量的随机数据，默认该设备生成随机数据的速度很慢，可用使用下面的命令用urandom替换random（非必须操作）。
[root@web1 ~]# mv /dev/random  /dev/random.bak
[root@web1 ~]# ln -s /dev/urandom  /dev/random
另外，还可以使用方案二解决：
[root@web1 ~]# yum install rng-tools
[root@web1 ~]# systemctl start rngd
[root@web1 ~]# systemctl enable rngd
5）客户端浏览测试页面(proxy作为客户端)
[root@proxy ~]# firefox http://192.168.2.100:8080
步骤二：修改Tomcat配置文件

1）创建测试JSP页面
[root@web1 ~]# vim  /usr/local/tomcat/webapps/ROOT/test.jsp
<html>
<body>
<center>
Now time is: <%=new java.util.Date()%>            //显示服务器当前时间
</center>
</body>
</html>
步骤三：验证测试

1）客户端浏览测试页面(proxy充当客户端角色)
[root@proxy ~]# firefox http://192.168.2.100:8080
[root@proxy ~]# firefox http://192.168.2.100:8080/test.jsp


2 案例2：使用Tomcat部署虚拟主机
2.1 问题

沿用练习二，使用Tomcat部署加密虚拟主机，实现以下要求：
实现两个基于域名的虚拟主机，域名分别为：www.a.com和 www.b.com
使用www.a.com域名访问的页面根路径为/usr/local/tomcat/a/ROOT
使用www.b.com域名访问的页面根路径为/usr/local/tomcat/b/base
访问www.a.com/test时，页面自动跳转到/var/www/html目录下的页面
访问页面时支持SSL加密通讯
私钥、证书存储路径为/usr/local/tomcat/conf/cert
每个虚拟主机都拥有独立的访问日志文件
配置tomcat集群环境
2.2 方案

修改server.xml配置文件，创建两个域名的虚拟主机，修改如下两个参数块：
# cat /usr/local/tomcat/conf/server.xml
<Server>
   <Service>
     <Connector port=8080 />
     <Connector port=8009 />
     <Engine name="Catalina" defaultHost="localhost">
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
</Host>
… …
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置服务器虚拟主机

1）修改server.xml配置文件，创建虚拟主机
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
</Host>
2）创建虚拟主机对应的页面根路径
[root@web1 ~]# mkdir -p  /usr/local/tomcat/{a,b}/ROOT
[root@web1 ~]# echo "AAA"   > /usr/local/tomcat/a/ROOT/index.html
[root@web1 ~]# echo "BBB" > /usr/local/tomcat/b/ROOT/index.html
3）重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
4）客户端设置host文件，并浏览测试页面进行测试(proxy充当客户端角色)
注意：ssh远程连接时使用使用-X参数才可以！！！
[root@proxy ~]# vim /etc/hosts
… …
192.168.2.100      www.a.com  www.b.com
[root@proxy ~]# firefox http://www.a.com:8080/        //注意访问的端口为8080
[root@proxy ~]# firefox http://www.b.com:8080/
步骤二：修改www.b.com网站的首页目录为base

1）使用docBase参数可以修改默认网站首页路径
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base"/>
</Host>
… …
[root@web1 ~]# mkdir  /usr/local/tomcat/b/base
[root@web1 ~]# echo "BASE" > /usr/local/tomcat/b/base/index.html
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
2）测试查看页面是否正确(proxy充当客户端角色)
[root@proxy ~]# firefox http://www.b.com:8080/        //结果为base目录下的页面内容
步骤三：跳转

1）当用户访问http://www.a.com/test打开/var/www/html目录下的页面
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
<Context path="/test" docBase="/var/www/html/" />
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base" />
</Host>
… …
[root@web1 ~]# echo "Test" > /var/www/html/index.html
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
2）测试查看页面是否正确(proxy充当客户端角色)
[root@proxy ~]# firefox http://www.a.com:8080/test    
//返回/var/www/html/index.html的内容
//注意，访问的端口为8080
步骤四：配置Tomcat支持SSL加密网站

1）创建加密用的私钥和证书文件
[root@web1 ~]# keytool -genkeypair -alias tomcat -keyalg RSA -keystore /usr/local/tomcat/keystore                //提示输入密码为:123456
//-genkeypair     生成密钥对
//-alias tomcat     密钥别名
//-keyalg RSA     定义密钥算法为RSA算法
//-keystore         定义密钥文件存储在:/usr/local/tomcat/keystore
2)再次修改server.xml配置文件，创建支持加密连接的Connector
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
maxThreads="150" SSLEnabled="true" scheme="https" secure="true"
keystoreFile="/usr/local/tomcat/keystore" keystorePass="123456" clientAuth="false" sslProtocol="TLS" />
//备注，默认这段Connector被注释掉了，打开注释，添加密钥信息即可
3）重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
4）客户端设置host文件，并浏览测试页面进行测试(proxy充当客户端角色)
[root@proxy ~]# vim /etc/hosts
… …
192.168.2.100      www.a.com  www.b.com
[root@proxy ~]# firefox https://www.a.com:8443/
[root@proxy ~]# firefox https://www.b.com:8443/
[root@proxy ~]# firefox https://192.168.2.100:8443/


步骤五：配置Tomcat日志

1)为每个虚拟主机设置不同的日志文件
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
.. ..
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
<Context path="/test" docBase="/var/www/html/" />
#从默认localhost虚拟主机中把Valve这段复制过来，适当修改下即可
<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix="a_access" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base" />
<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix="b_access" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
</Host>
.. ..
2）重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
3）查看服务器日志文件
[root@web1 ~]# ls /usr/local/tomcat/logs/
步骤六：扩展实验(配置Tomcat集群)

1) 在192.168.4.5主机上配置Nginx调度器（具体安装步骤参考前面的章节）
[root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
http{
    upstream toms {
        server 192.168.2.100:8080;
        server 192.168.2.200:8080;
    }
    server  {
        listen 80;
        server_name localhost;
        location / {
            proxy_pass  http://toms;
        }
    }
}  
2) 在192.168.2.100和192.168.2.200主机上配置Tomcat调度器
以下以Web1为例：
[root@web1 ~]# yum -y install  java-1.8.0-openjdk                //安装JDK
[root@web1 ~]# yum -y install java-1.8.0-openjdk-headless        //安装JDK
[root@web1 ~]# tar -xzf  apache-tomcat-8.0.30.tar.gz
[root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
3）启动服务
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
4) 客户端验证
为了防止有数据缓存，可以使用真实主机的google-chrome访问代理服务器，输入Ctrl+F5刷新页面。


3 案例3：使用Varnish加速Web
3.1 问题

通过配置Varnish缓存服务器，实现如下目标：     CDN 内容分发网络
使用Varnish加速后端Web服务
代理服务器可以将远程的Web服务器页面缓存在本地
远程Web服务器对客户端用户是透明的
利用缓存机制提高网站的响应速度
使用varnishadm命令管理缓存页面
使用varnishstat命令查看Varnish状态
3.2 方案

通过源码编译安装Varnish缓存服务器
编译安装Varnish软件
修改配置文件，缓存代理源Web服务器，实现Web加速功能
使用3台RHEL7虚拟机，其中一台作为Web服务器（192.168.2.100）、一台作为Varnish代理服务器（192.168.4.5,192.168.2.5)，另外一台作为测试用的Linux客户机（192.168.4.10），如图-2所示。

图-2
对于Web服务器的部署，此实验中仅需要安装nginx或者httpd软件、启动服务，并生成测试首页文件即可，默认httpd网站根路径为/var/www/html，首页文档名称为index.html，默认nginx网站根路径为/usr/local/nginx/html，默认首页为index.html。下面的实验我们以httpd为例作为Web服务器。
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：构建Web服务器

1）使用yum安装web软件包
[root@web1 ~]# yum  -y  install  httpd
2）启用httpd服务（注意需要关闭nginx，否则端口冲突）
[root@web1 ~]# systemctl start httpd
httpd服务默认通过TCP 80端口监听客户端请求：
[root@web1 ~]# netstat  -anptu  |  grep httpd
tcp        0        0        :::80        :::*        LISTEN        2813/httpd
3）为Web访问建立测试文件
在网站根目录/var/www/html下创建一个名为index.html的首页文件：
[root@web1 ~]# cat /var/www/html/index.html 
192.168.2.100
4）测试页面是否正常（代理服务器测试后台web）
[root@proxy ~]# firefox http://192.168.2.100
步骤二：部署Varnish缓存服务器(192.168.4.5)

1）编译安装软件
[root@proxy ~]# yum -y install gcc readline-devel    //安装软件依赖包
[root@proxy ~]# yum -y install ncurses-devel         //安装软件依赖包
[root@proxy ~]# yum -y install pcre-devel            //安装软件依赖包
[root@proxy ~]# yum -y install python-docutils         //安装软件依赖包
 [root@proxy ~]# useradd -s /sbin/nologin varnish                //创建账户
[root@proxy ~]# tar -xf varnish-5.2.1.tar.gz
[root@proxy ~]# cd varnish-5.2.1
[root@proxy varnish-5.2.1]# ./configure
[root@proxy varnish-5.2.1]# make && make install
2）复制启动脚本及配置文件（注意相对路径与绝对路径）
[root@proxy varnish-5.2.1]# cp  etc/example.vcl   /usr/local/etc/default.vcl
3）修改代理配置文件
[root@proxy ~]# vim  /usr/local/etc/default.vcl
backend default {
     .host = "192.168.2.100";
     .port = "80";
 }
4）启动服务
 [root@proxy ~]# varnishd  -f /usr/local/etc/default.vcl
//varnishd命令的其他选项说明如下：
//varnishd -s malloc,128M        //定义varnish使用内存作为缓存，空间为128M
//varnishd -s file,/var/lib/varnish_storage.bin,1G  // 定义varnish使用文件作为缓存,大小为1G
步骤三：客户端测试

1）客户端开启浏览器访问
[root@client ~]# curl http://192.168.4.5
步骤四：其他操作

1）查看varnish日志
[root@proxy ~]# varnishlog                        //varnish日志
[root@proxy ~]# varnishncsa                    //访问日志
2）更新缓存数据，在后台web服务器更新页面内容后，用户访问代理服务器看到的还是之前的数据，说明缓存中的数据过期了需要更新（默认也会自动更新，但非实时更新）。
[root@proxy ~]# varnishadm  
varnish> ban req.url ~ .*
//清空缓存数据，支持正则表达式


##############################################################################


Top
NSD OPERATION DAY06

案例1：Git基本操作
案例2： HEAD指针操作
案例3：Git分支操作
案例4：Git服务器
案例5：制作nginx的RPM包
1 案例1：Git基本操作
1.1 问题

本案例要求先快速搭建好一台Git服务器，并测试该版本控制软件，要求如下：
安装Git软件
创建版本库
客户端克隆版本仓库到本地
本地工作目录修改数据
提交本地修改到服务器

------集中式版本控制软件  (只下载最新版软件)
  . CVS
  . SVN
------分布式版本控制软件   (对服务器的完整克隆)
   . Git
   . BitKeeper(收费)

1.2 方案

实验拓扑如图-1所示，Git工作流如图-2所示。

图-1

图-2
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署Git服务器（192.168.2.100作为远程git服务器）

1）YUM安装Git软件。
[root@web1 ~]# yum -y install git
[root@web1 ~]# git --version
2)初始化一个空仓库。
[root@web1 ~]# mkdir /var/git
[root@web1 ~]# git init /var/git/project --bare    // /var/git/为共享目录  project为仓库
[root@web1 ~]# ls /var/git/project
config  description  HEAD  hooks  info  objects  refs   
步骤二：客户端测试(192.168.2.200作为客户端主机)

使用git常用指令列表如表-1所示。


表－1 git常用指令列表
clone   将远程服务器的仓库克隆到本地
config  修改git配置
add     添加修改到暂存区
commit  提交修改到本地仓库
push    提交修改到远程服务器

1) clone克隆服务器仓库到本地。
[root@web2 ~]# yum -y install git
[root@web2 ~]# git clone root@192.168.2.100:/var/git/project 
[root@web2 ~]# cd project
[root@web2 ~]# ls -a 
.git                 // .git -->本地仓库    project-->工作目录
2) 修改git配置。
[root@web2 project]# git config --global user.email "you@example.com"
[root@web2 project]# git config --global user.name "Your Name"
[root@web2 project]# cat ~/.gitconfig 
[user]
    email = you@example.com
    name = Your Name
3） 本地工作区对数据进行增删改查(必须要先进入仓库再操作数据)。
[root@web2 project]# echo "init date" > init.txt
[root@web2 project]# mkdir demo
[root@web2 project]# cp /etc/hosts demo
4） 查看仓库中数据的状态。
[root@web2 project]# git status
5） 将工作区的修改提交到暂存区。
[root@web2 project]# git add .  //  . 代表当前目录
6) 将暂存区修改提交到本地仓库。
  注释:commit提交到本地仓库后无法查看,可以用 (du -sh .git)  查看仓库的大小
[root@web2 project]# git commit  -m  "注释，可以为任意字符"
[root@web2 project]# git status
7） 将本地仓库中的数据推送到远程服务器(web2将数据推送到web1)。
[root@web2 project]# git config --global push.default simple
[root@web2 project]# git push
root@192.168.2.100's password:  输入服务器root密码
[root@web2 project]# git status
8) 将服务器上的数据更新到本地（web1的数据更新到web2）。
备注：可能其他人也在修改数据并提交服务器，就会导致自己的本地数据为旧数据，使用pull就可以将服务器上新的数据更新到本地。
[root@web2 project]# git pull
9) 查看版本日志。
[root@web2 project]# git log
[root@web2 project]# git log --pretty=oneline
[root@web2 project]# git log --oneline
[root@web2 project]# git reflog
备注：客户端也可以使用图形程序访问服务器。
Windows需要安装git和tortoiseGit。如图-3、图-4所示。

图-3

图-4
2 案例2： HEAD指针操作
2.1 问题

沿用练习一，学习操作HEAD指针，具体要求如下：
查看Git版本信息
移动指针
通过移动HEAD指针恢复数据
2.2 方案

HEAD指针是一个可以在任何分支和版本移动的指针，通过移动指针我们可以将数据还原至任何版本。没做一次提交操作都会导致git更新一个版本，HEAD指针也跟着自动移动。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：HEAD指针基本操作

1）准备工作（多对数据仓库进行修改、提交操作，以产生多个版本）。
[root@web2 project]# echo "new file" > new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "add new.txt"
[root@web2 project]# echo "first" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "new.txt:first line"
[root@web2 project]# echo "second" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "new.txt:second"
[root@web2 project]# echo "third" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "new.txt:third"
[root@web2 project]# git push
[root@web2 project]# echo "123" > num.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "num.txt:123"
[root@web2 project]# echo "456" > num.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "num.txt:456"
[root@web2 project]# echo "789" > num.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "num.txt:789"
[root@web2 project]# git push
2) 查看Git版本信息。
[root@web2 project]# git reflog
[root@web2 project]# git log --oneline
04ddc0f num.txt:789
7bba57b num.txt:456
301c090 num.txt:123
b427164 new.txt:third
0584949 new.txt:second
ece2dfd new.txt:first line
e1112ac add new.txt
1a0d908 初始化
3）移动HEAD指针，将数据还原到任意版本。
提示：当前HEAD指针为HEAD@{0}。
[root@web2 project]# git reset --hard 301c0
[root@web2 project]# git reflog
301c090 HEAD@{0}: reset: moving to 301c0
04ddc0f HEAD@{1}: commit: num.txt:789
7bba57b HEAD@{2}: commit: num.txt:456
301c090 HEAD@{3}: commit: num.txt:123
b427164 HEAD@{5}: commit: new.txt:third
0584949 HEAD@{6}: commit: new.txt:second
ece2dfd HEAD@{7}: commit: new.txt:first line
e1112ac HEAD@{8}: commit: add new.txt
1a0d908 HEAD@{9}: commit (initial): 初始化
[root@web2 project]# cat num.txt                #查看文件是否为123
123
[root@web2 project]# git reset --hard 7bba57b
[root@web2 project]# cat num.txt                #查看文件是否为123，456
123
456
[root@web2 project]# git reflog                #查看指针移动历史
7bba57b HEAD@{0}: reset: moving to 7bba57b
301c090 HEAD@{1}: reset: moving to 301c0
… …
[root@web2 project]# git reset --hard 04ddc0f    #恢复num.txt的所有数据
4)模拟误删后的数据还原操作。
[root@web2 project]# git rm init.txt                    #删除文件
rm 'init.txt'
[root@web2 project]# git commit -m "delete init.txt"    #提交本地仓库
[root@web2 project]# git reflog                        #查看版本历史
0dc2b76 HEAD@{0}: commit: delete init.txt
7bba57b HEAD@{0}: reset: moving to 7bba57b
301c090 HEAD@{1}: reset: moving to 301c0
… …
[root@web2 project]# git reset --hard 04ddc0f            #恢复数据
[root@web2 project]# ls
demo  init.txt  new.txt  num.txt
3 案例3：Git分支操作
3.1 问题

沿用练习二，学习操作Git分支，具体要求如下：
查看分支
创建分支
切换分支
合并分支
解决分支的冲突
3.2 方案

Git支持按功能模块、时间、版本等标准创建分支，分支可以让开发分多条主线同时进行，每条主线互不影响，分支效果如图-5所示。

图-5
常见的分支规范如下：
MASTER分支（MASTER是主分支，是代码的核心）。
DEVELOP分支（DEVELOP最新开发成果的分支）。
RELEASE分支（为发布新产品设置的分支）。
HOTFIX分支（为了修复软件BUG缺陷的分支）。
FEATURE分支（为开发新功能设置的分支）特指小的功能。
步骤一：查看并创建分支

1）查看当前分支。
[root@web2 project]# git status
# On branch master
nothing to commit, working directory clean
[root@web2 project]# git branch -v
* master 0dc2b76 delete init.txt
2）创建分支。
[root@web2 project]# git branch hotfix
[root@web2 project]# git branch feature
[root@web2 project]# git branch -v
  feature 0dc2b76 delete init.txt
  hotfix  0dc2b76 delete init.txt
* master  0dc2b76 delete init.txt
步骤二：切换与合并分支

1）切换分支。
[root@web2 project]# git checkout hotfix
[root@web2 project]# git branch -v
  feature 0dc2b76 delete init.txt
* hotfix  0dc2b76 delete init.txt
master  0dc2b76 delete init.txt
2）在新的分支上可以继续进行数据操作（增、删、改、查）。
[root@web2 project]# echo "fix a bug" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "fix a bug"
3）将hotfix修改的数据合并到master分支。
注意，合并前必须要先切换到master分支，然后再执行merge命令。
[root@web2 project]# git checkout master
[root@web2 project]# cat new.txt        #默认master分支中没有hotfix分支中的数据
[root@web2 project]# git merge hotfix
Updating 0dc2b76..5b4a755
Fast-forward
 new.txt | 1 ++
 1 file changed, 1 insertions(+)
4）将所有本地修改提交远程服务器。
[root@web2 project]# git push
步骤二：解决版本分支的冲突问题

1）在不同分支中修改相同文件的相同行数据，模拟数据冲突。
[root@web2 project]# git checkout hotfix
[root@web2 project]# echo "AAA" > a.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "add a.txt by hotfix"
[root@web2 project]# git checkout master
[root@web2 project]# echo "BBB" > a.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "add a.txt by master"
[root@web2 project]# git merge hotfix
自动合并 a.txt
冲突（添加/添加）：合并冲突于 a.txt
自动合并失败，修正冲突然后提交修正的结果。
2）查看有冲突的文件内容，修改文件为最终版本的数据，解决冲突。
[root@web2 project]# cat a.txt                #该文件中包含有冲突的内容
<<<<<<< HEAD
BBB
=======
AAA
>>>>>>> hotfix
[root@web2 project]# vim a.txt              #修改该文件，为最终需要的数据，解决冲突
BBB
[root@web2 project]# git add .
[root@web2 project]# git commit -m "resolved"
总结：分支指针与HEAD指针的关系。
创建分支的本质是在当前提交上创建一个可以移动的指针
如何判断当前分支呢？答案是根据HEAD这个特殊指针
分支操作流程如图-6，图-7，图-8，图-9，图-10所示。

图-6 HEAD指针指向master分支

图-7 切换分支，HEAD指针指向testing分支

图-8 在testing分支中修改并提交代码

图-9 将分支切换回master分支

图-10 在master分支中修改数据，更新版本

4 案例4：Git服务器
4.1 问题

沿用练习三，学习Git不同的服务器形式，具体要求如下：
创建SSH协议服务器
创建Git协议服务器
创建HTTP协议服务器
4.2 方案

Git支持很多服务器协议形式，不同协议的Git服务器，客户端就可以使用不同的形式访问服务器。创建的服务器协议有SSH协议、Git协议、HTTP协议。
步骤一：SSH协议服务器（支持读写操作）

1）创建基于密码验证的SSH协议服务器（web1主机操作）。
[root@web1 ~]# git init --bare /var/git/base_ssh
Initialized empty Git repository in /var/git/base_ssh/
2)客户端访问的方式（web2主机操作）。
[root@web2 ~]# git clone root@192.168.2.100:/var/git/base_ssh
[root@web2 ~]# rm -rf base_ssh
3）客户端生成SSH密钥，实现免密码登陆git服务器（web2主机操作）。
[root@web2 ~]# ssh-keygen -f /root/.ssh/id_rsa -N ''
[root@web2 ~]# ssh-copy-id  192.168.2.100
[root@web2 ~]# git clone root@192.168.2.100:/var/git/base_ssh
[root@web2 ~]# git push

步骤二：Git协议服务器（只读操作的服务器）

1）安装git-daemon软件包（web1主机操作）。
[root@web1 ~]# yum -y install git-daemon
2）创建版本库（web1主机操作）。
[root@web1 ~]# git init --bare /var/git/base_git
Initialized empty Git repository in /var/git/base_git/
3）修改配置文件，启动git服务（web1主机操作）。
[root@web1 ~]# vim /usr/lib/systemd/system/git@.service
修改前内容如下：
ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/lib/git 
--export-all --user-path=public_git --syslog --inetd –verbose
修改后内容如下：
ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/git 
--export-all --user-path=public_git --syslog --inetd –verbose
[root@web1 ~]# systemctl  start  git.socket
4）客户端访问方式（web2主机操作）
[root@web2 ~]# git clone git://192.168.2.100/base_git

步骤三：HTTP协议服务器（只读操作的服务器）

1）安装gitweb、httpd软件包（web1主机操作）。
[root@web1 ~]# yum -y install httpd gitweb
2）修改配置文件，设置仓库根目录（web1主机操作）。
[root@web1 ~]# vim +11 /etc/gitweb.conf      //光标定义在第11行
$projectroot = "/var/git";                        #添加一行
3) 创建版本仓库（web1主机操作）
[root@web1 ~]# git init --bare /var/git/base_http
4）启动httpd服务器
[root@web1 ~]# systemctl start httpd
5）客户端访问方式（web2主机操作）
注意：调用虚拟机中的firefox浏览器，需要在远程时使用ssh -X 服务器IP，并且确保真实主机的firefox已经关闭。
[root@web2 ~]# firefox http://192.168.2.100/git/
步骤四：课外扩展知识：注册使用Github

1.登陆网站https://github.com，点击Sign up（注册），如图-11所示。

图-11
2.填写注册信息（用户名，邮箱，密码），如图-12所示。

图-12
3. 初始化操作，如图-13和图-14所示。

图-13

图-14
注意，初始化完成后，到邮箱中去激活Github账户。
4. 创建仓库、使用仓库
点击Start a project（如图-15所示），

图-15
填写项目名称（项目名称任意），如图-16所示。

图-16
往仓库中上传文件或新建文件，如图-17所示

图-17
下载仓库中的代码，如图-18所示。

图-18
5. 命令行操作（需要联网的主机，如真实机）
[root@pc001 ~]# yum -y install git
[root@pc001 ~]# git clone https://github.com/账户名称/仓库名称
#clone指令用于将服务器仓库中的资料打包下载到本地
[root@pc001 ~]# cd 仓库名称
[root@pc001 ~]# 任意修改文件，或新建文件
[root@pc001 ~]# git add .
#add添加新文件
[root@pc001 ~]# git commit -m "test"
[root@pc001 ~]# git push
#commit和push实现提交代码的功能
[root@pc001 ~]# git pull
#pull可以从githuab服务器拉取数据到本地
5 案例5：制作nginx的RPM包
5.1 问题

本案例使用nginx-1.12.2版本的源码软件，生成对应的RPM包软件，具体要求如下：
软件名称为nginx
软件版本为1.12.2
RPM软件包可以查询描述信息
RPM软件包可以安装及卸载
5.2 方案

安装rpm-build软件包，编写SPEC配置文件，创建新的RPM软件包。
配置文件中的描述信息如表-2：
表－2 SPEC描述信息

5.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：安装rpm-build软件

1）安装rpm-build软件包
[root@web1 ~]# yum -y install  rpm-build
2）生成rpmbuild目录结构
[root@web1 ~]# rpmbuild -ba nginx.spec                //会报错，没有文件或目录
[root@web1 ~]# ls /root/rpmbuild                    //自动生成的目录结构
BUILD  BUILDROOT  RPMS  SOURCES  SPECS  SRPMS
3）准备工作，将源码软件复制到SOURCES目录
[root@web1 ~]# cp nginx-1.12.2.tar.gz /root/rpmbuild/SOURCES/
4）创建并修改SPEC配置文件
[root@web1 ~]# vim /root/rpmbuild/SPECS/nginx.spec 
Name:nginx                                        #源码包软件名称
Version:1.12.2                                    #源码包软件的版本号
Release:    10                                        #制作的RPM包版本号
Summary: Nginx is a web server software.            #RPM软件的概述    
License:GPL                                        #软件的协议
URL:    www.test.com                                    #网址
Source0:nginx-1.12.2.tar.gz                        #源码包文件的全称
#BuildRequires:                                    #制作RPM时的依赖关系
#Requires:                                        #安装RPM时的依赖关系
%description
nginx [engine x] is an HTTP and reverse proxy server.    #软件的详细描述
%post
useradd nginx                               #非必需操作：安装后脚本(创建账户)
%prep
%setup -q                                #自动解压源码包，并cd进入目录
%build
./configure
make %{?_smp_mflags}
%install
make install DESTDIR=%{buildroot}
%files
%doc
/usr/local/nginx/*                    #对哪些文件与目录打包
%changelog
步骤二：使用配置文件创建RPM包

1）安装依赖软件包
[root@web1 ~]# yum -y install  gcc  pcre-devel openssl-devel
2）rpmbuild创建RPM软件包
[root@web1 ~]# rpmbuild -ba /root/rpmbuild/SPECS/nginx.spec
[root@web1 ~]# ls /root/rpmbuild/RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm
步骤三：安装、卸载软件

[root@web1 ~]# rpm -ivh /root/rpmbuild/RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm 
[root@web1 ~]# rpm -qa |grep nginx
[root@web1 ~]# /usr/local/nginx/sbin/nginx
[root@web1 ~]# curl http://127.0.0.1/


###############################################################################


Top
NSD OPERATION DAY07

案例1：配置GRE VPN
案例2：创建PPTP VPN
案例3：创建L2TP+IPSec VPN
案例4：NTP时间同步
1 案例1：配置GRE VPN
1.1 问题

本案例要求搭建一个GRE VPN环境，并测试该VPN网络是否能够正常通讯，要求如下：
启用内核模块ip_gre
创建一个虚拟VPN隧道(10.10.10.0/24)
实现两台主机点到点的隧道通讯
1.2 方案

使用lsmod查看当前计算机已经加载的模块，使用modprobe加载Linux内核模块，使用modinfo可以查看内核模块的信息。
准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-1所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。
表－1 主机列表

实验拓扑如图-1所示。

图-1
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：启用GRE模块（client和proxy都需要操作）

1）查看计算机当前加载的模块
[root@client ~]# lsmod                            //显示模块列表
[root@client ~]# lsmod  | grep ip_gre            //确定是否加载了gre模块
2)加载模块ip_gre
[root@client ~]# modprobe  ip_gre 
3）查看模块信息
[root@client ~]# modinfo ip_gre
filename:       /lib/modules/3.10.0-693.el7.x86_64/kernel/net/ipv4/ip_gre.ko.xz
alias:          netdev-gretap0
alias:          netdev-gre0
alias:          rtnl-link-gretap
alias:          rtnl-link-gre
license:        GPL
rhelversion:    7.4
srcversion:     F37A2BF90692F86E3A8BD15
depends:        ip_tunnel,gre
intree:         Y
vermagic:       3.10.0-693.el7.x86_64 SMP mod_unload modversions 
signer:         CentOS Linux kernel signing key
sig_key:        DA:18:7D:CA:7D:BE:53:AB:05:BD:13:BD:0C:4E:21:F4:22:B6:A4:9C
sig_hashalgo:   sha256
parm:           log_ecn_error:Log packets received with corrupted ECN (bool)
      
步骤二：Client主机创建VPN隧道

1）创建隧道
[root@client ~]# ip tunnel add tun0  mode gre \ 
>  remote 201.1.2.5 local 201.1.2.10
//ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
//mode设置隧道使用gre模式
//local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址
2）启用该隧道（类似与设置网卡up）
[root@client ~]# ip link show
[root@client ~]# ip link set tun0 up         //设置UP
[root@client ~]# ip link show
3）为VPN配置隧道IP地址
[root@client ~]# ip addr add 10.10.10.10/24 peer 10.10.10.5/24 \
>  dev tun0
//为隧道tun0设置本地IP地址（10.10.10.10.10/24）
//隧道对面的主机IP的隧道IP为10.10.10.5/24
[root@client ~]# ip a s                      //查看IP地址
4）关闭防火墙
[root@client ~]# firewall-cmd --set-default-zone=trusted
步骤三：Proxy主机创建VPN隧道

1）查看计算机当前加载的模块
[root@client ~]# lsmod                            //显示模块列表
[root@client ~]# lsmod  | grep ip_gre            //确定是否加载了gre模块
2)加载模块ip_gre
[root@client ~]# modprobe  ip_gre
3）创建隧道
[root@proxy ~]# ~]# ip tunnel add tun0  mode gre \ 
>  remote 201.1.2.10 local 201.1.2.5
//ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
//mode设置隧道使用gre模式
//local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址
4）启用该隧道（类似与设置网卡up）
[root@proxy ~]# ip link show
[root@proxy ~]# ip link set tun0 up         //设置UP
[root@proxy ~]# ip link show
5）为VPN配置隧道IP地址
[root@proxy ~]# ip addr add 10.10.10.5/24 peer 10.10.10.10/24 \
>  dev tun0
//为隧道tun0设置本地IP地址（10.10.10.10.5/24）
//隧道对面的主机IP的隧道IP为10.10.10.10/24
[root@proxy ~]# ip a s                      //查看IP地址
6）开启路由转发、关闭防火墙
[root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
7)测试连通性
[root@client ~]#  ping 10.10.10.5
[root@proxy ~]#   ping 10.10.10.10
2 案例2：创建PPTP VPN
2.1 问题

本案例要求搭建一个PPTP VPN环境，并测试该VPN网络是否能够正常通讯，要求如下:
使用PPTP协议创建一个支持身份验证的隧道连接
使用MPPE对数据进行加密
为客户端分配192.168.3.0/24的地址池
客户端连接的用户名为jacob，密码为123456
2.2 方案

准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-2所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。
表－2 主机列表

实验拓扑如图-2所示。

图-2
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署VPN服务器

1）安装软件包（软件包参考lnmp_soft）
[root@proxy ~]# yum localinstall pptpd-1.4.0-2.el7.x86_64.rpm
[root@proxy ~]# rpm -qc pptpd
/etc/ppp/options.pptpd
/etc/pptpd.conf
/etc/sysconfig/pptpd
2)修改配置文件
[root@proxy ~]# vim /etc/pptpd.conf
.. ..
localip 201.1.2.5                                    //服务器本地IP
remoteip 192.168.3.1-50                            //分配给客户端的IP池
[root@proxy ~]# vim /etc/ppp/options.pptpd
require-mppe-128                                    //使用MPPE加密数据
ms-dns 8.8.8.8                                    //DNS服务器
[root@proxy ~]# vim /etc/ppp/chap-secrets            //修改账户配置文件
jacob           *               123456      *
//用户名    服务器标记    密码    客户端
[root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward    //开启路由转发
3）启动服务
[root@proxy ~]# systemctl start pptpd
[root@proxy ~]# systemctl enable pptpd
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
4）翻墙设置（非必需操作）
[root@proxy ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
>  -j SNAT --to-source 201.1.2.5
步骤二：客户端设置

启动一台Windows虚拟机，将虚拟机网卡桥接到public2，配置IP地址为201.1.2.20。
新建网络连接（具体操作如图-3所示），输入VPN服务器账户与密码（具体操作如图-4所示），连接VPN并测试网络连通性（如图-5所示）。

图-3

图-4

图-5
3 案例3：创建L2TP+IPSec VPN
3.1 问题

本案例要求搭建一个L2TP+IPSec VPN环境，并测试该VPN网络是否能够正常通讯，具体要求如下：
使用L2TP协议创建一个支持身份验证与加密的隧道连接
使用IPSec对数据进行加密
为客户端分配192.168.3.0/24的地址池
客户端连接的用户名为：jacob，密码为：123456
预共享密钥为：randpass
3.2 方案

准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-3所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。
表－3 主机列表

实验拓扑如图-6所示。

图-6
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署IPSec服务

1）安装软件包
[root@client ~]# yum -y install libreswan
2)新建IPSec密钥验证配置文件
[root@client ~]# cat /etc/ipsec.conf                //仅查看一下该主配置文件
.. ..
include /etc/ipsec.d/*.conf                    //加载该目录下的所有配置文件
[root@client ~]# vim /etc/ipsec.d/myipsec.conf            
//新建该文件，参考lnmp_soft/vpn/myipsec.conf    
conn IDC-PSK-NAT
    rightsubnet=vhost:%priv                        //允许建立的VPN虚拟网络
    also=IDC-PSK-noNAT
conn IDC-PSK-noNAT
    authby=secret                                    //加密认证
        ike=3des-sha1;modp1024                        //算法
        phase2alg=aes256-sha1;modp2048                //算法
    pfs=no
    auto=add
    keyingtries=3
    rekey=no
    ikelifetime=8h
    keylife=3h
    type=transport
    left=201.1.2.10                                //重要，服务器本机的外网IP
    leftprotoport=17/1701
    right=%any                                    //允许任何客户端连接
    rightprotoport=17/%any
3)创建IPSec预定义共享密钥
[root@client ~]# cat /etc/ipsec.secrets                 //仅查看，不要修改该文件
include /etc/ipsec.d/*.secrets
[root@client ~]# vim /etc/ipsec.d/mypass.secrets        //新建该文件
201.1.2.10   %any:    PSK    "randpass"             //randpass为预共享密钥
                                                //201.1.2.10是VPN服务器的IP
4)启动IPSec服务
[root@client ~]# systemctl start ipsec        
[root@client ~]# netstat -ntulp |grep pluto
udp        0      0 127.0.0.1:4500          0.0.0.0:*           3148/pluto          
udp        0      0 192.168.4.10:4500      0.0.0.0:*           3148/pluto          
udp        0      0 201.1.2.10:4500         0.0.0.0:*           3148/pluto          
udp        0      0 127.0.0.1:500           0.0.0.0:*           3148/pluto          
udp        0      0 192.168.4.10:500       0.0.0.0:*           3148/pluto          
udp        0      0 201.1.2.10:500          0.0.0.0:*           3148/pluto          
udp6       0      0 ::1:500                 :::*                 3148/pluto
步骤二：部署XL2TP服务

1）安装软件包（软件包参考lnmp_soft）
[root@client ~]# yum localinstall xl2tpd-1.3.8-2.el7.x86_64.rpm
2) 修改xl2tp配置文件（修改3个配置文件的内容）
[root@client ~]#  vim  /etc/xl2tpd/xl2tpd.conf                //修改主配置文件
[global]
.. ..    
[lns default]
.. ..
ip range = 192.168.3.128-192.168.3.254                    //分配给客户端的IP池
local ip = 201.1.2.10                                    //VPN服务器的IP地址
[root@client ~]# vim /etc/ppp/options.xl2tpd            //认证配置
require-mschap-v2                                         //添加一行，强制要求认证
#crtscts                                                //注释或删除该行
#lock                                                //注释或删除该行
root@client ~]# vim /etc/ppp/chap-secrets                    //修改密码文件
jacob   *       123456  *                //账户名称   服务器标记   密码   客户端IP
3）启动服务
[root@client ~]# systemctl start xl2tpd
[root@client ~]# netstat  -ntulp |grep xl2tpd        
udp     0      0 0.0.0.0:1701      0.0.0.0:*          3580/xl2tpd
4）设置路由转发，防火墙
[root@client ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
[root@client ~]# firewall-cmd --set-default-zone=trusted
5）翻墙设置（非必需操作）
[root@client ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
>  -j SNAT --to-source 201.1.2.10
步骤三：客户端设置

启动一台Windows虚拟机，将虚拟机网卡桥接到public2，配置IP地址为201.1.2.20。
1. 新建网络连接（参考案例2），输入VPN服务器账户与密码（参考案例2）。
设置VPN连接的属性，预共享密钥是IPSec配置文件中填写的randpass，具体操作如图-7所示。

图-7
2. 设置Windows注册表（不修改注册表，连接VPN默认会报789错误），具体操作如下：
单击"开始"，单击"运行"，键入"regedit"，然后单击"确定"
找到下面的注册表子项，然后单击它：
HKEY_LOCAL_MACHINE\ System\CurrentControlSet\Services\Rasman\Parameters
在"编辑"菜单上，单击"新建"->"DWORD值"
在"名称"框中，键入"ProhibitIpSec"
在"数值数据"框中，键入"1"，然后单击"确定"
退出注册表编辑器，然后重新启动计算机
连接VPN并测试网络连通性（参考案例2）。
4 案例4：NTP时间同步
4.1 问题

本案例要求搭建一个NTP服务器，为整个网络环境中的所有主机提供时间校准服务，具体要求如下：
部署一台NTP时间服务器
设置时间服务器上层与0.centos.pool.ntp.org同步
设置本地服务器层级数量为10
允许192.168.4.0/24网络的主机同步时间
客户端验证时间是否同步
4.2 方案

准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-4所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。
表－4 主机列表

实验拓扑如图-8所示。

图-8
Network Time Protocol（网络时间协议）采用的是分层设计，如图-9所示，Stratum层的总数限制在15以内（包括15）。

图-9
4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署NTP服务

1）安装软件包
[root@proxy ~]# yum -y install chrony
[root@proxy ~]# rpm -qc chrony                        //查看配置文件列表
/etc/chrony.conf
/etc/chrony.keys
.. ..
2)修改配置文件
[root@proxy ~]# cat /etc/chrony.conf
.. ..
server 0.centos.pool.ntp.org iburst         //server用户客户端指向上层NTP服务器
allow 192.168.4.0/24                        //允许那个IP或网络访问NTP
#deny  192.168.4.1                        //拒绝那个IP或网络访问NTP
local stratum 10                            //设置NTP服务器的层数量
.. ..
3)启动NTP服务
[root@proxy ~]# systemctl  restart  chronyd
[root@proxy ~]# systemctl  enable   chronyd
4)设置防火墙
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
步骤二：配置客户端

1）安装软件包
[root@client ~]# yum -y install chrony
2) 修改配置文件
[root@client ~]# vim /etc/chrony.conf
server 192.168.4.5 iburst                //设置与哪台服务器同步数据
                                        //iburst参数设置重启服务后尽快同步时间
3) 将客户端时间修改为错误的时间
[root@client ~]#  date  -s  "hour:minute"         //调整时间（小时：分钟）
[root@client ~]#  date                            //查看修改后的时间
4) 重启chrony与服务器同步时间
[root@client ~]# systemctl  restart  chronyd
5) 确认时间是否已经同步
[root@client ~]# date                            //多执行几次查看结果



所有 nignx 均不要显示版本号    在配置文件里http里  输入server_tokens off;(不显示版本号),后端web服务器也要写这个配置.

watch -n 1 ss -s      //观察服务器连接数变化(每秒执行一次 ss 命令)


  我们可以简单的通过修改Linux内核参数，可以减少Nginx服务器的TIME_WAIT套接字数量，进而提高Nginx服务器并发性能。  
 
vim /etc/sysctl.conf
  net.ipv4.tcp_fin_timeout = 30      // 表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间
  net.ipv4.tcp_keepalive_time = 1200 //表示当keepalive起用的时候，TCP发送keepalive消息的频度
  net.ipv4.tcp_syncookies = 1        //表示开启SYN Cookies,防范少量SYN攻击，默认为0，表示关闭
  net.ipv4.tcp_tw_reuse = 1          //表示开启重用,允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭
  net.ipv4.tcp_tw_recycle = 1        //表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭
  net.ipv4.ip_local_port_range = 1024 65000   //表示用于向外连接的端口范围
  net.ipv4.tcp_max_syn_backlog = 8192        //表示SYN队列的长度，默认为1024,加大队列长度为8192，可以容纳更多等待连接的网络连接数
  net.ipv4.tcp_max_tw_buckets = 5000         //表示系统同时保持TIME_WAIT套接字的最大数量

  sysctl -p       //刷新读取配置文件使永久配置立即生效

           内核参数:


tcp_syn_retries ：INTEGER
默认值是5
对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃。不应该大于255，默认值是5，对应于180秒左右时间。(对于大负载而物理通信良好的网络而言,这个值偏高,可修改为2.这个值仅仅是针对对外的连接,对进来的连接,是由tcp_retries1决定的)

tcp_synack_retries ：INTEGER
默认值是5
对于远端的连接请求SYN，内核会发送SYN ＋ ACK数据报，以确认收到上一个 SYN连接请求包。这是所谓的三次握手( threeway handshake)机制的第二个步骤。这里决定内核在放弃连接之前所送出的 SYN+ACK 数目。不应该大于255，默认值是5，对应于180秒左右时间。(可以根据上面的 tcp_syn_retries 来决定这个值)

tcp_keepalive_time ：INTEGER
默认值是7200(2小时)
当keepalive打开的情况下，TCP发送keepalive消息的频率。(由于目前网络攻击等因素,造成了利用这个进行的攻击很频繁,曾经也有cu的朋友提到过,说如果2边建立了连接,然后不发送任何数据或者rst/fin消息,那么持续的时间是不是就是2小时,空连接攻击? tcp_keepalive_time就是预防此情形的.我个人在做nat服务的时候的修改值为1800秒)

tcp_keepalive_probes：INTEGER
默认值是9
TCP发送keepalive探测以确定该连接已经断开的次数。(注意:保持连接仅在SO_KEEPALIVE套接字选项被打开是才发送.次数默认不需要修改,当然根据情形也可以适当地缩短此值.设置为5比较合适)

tcp_keepalive_intvl：INTEGER
默认值为75
探测消息发送的频率，乘以tcp_keepalive_probes就得到对于从开始探测以来没有响应的连接杀除的时间。默认值为75秒，也就是没有活动的连接将在大约11分钟以后将被丢弃。(对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的值)

tcp_retries1 ：INTEGER
默认值是3
放弃回应一个TCP连接请求前﹐需要进行多少次重试。RFC 规定最低的数值是3﹐这也是默认值﹐根据RTO的值大约在3秒 - 8分钟之间。(注意:这个值同时还决定进入的syn连接)

tcp_retries2 ：INTEGER
默认值为15
在丢弃激活(已建立通讯状况)的TCP连接之前﹐需要进行多少次重试。默认值为15，根据RTO的值来决定，相当于13-30分钟(RFC1122规定，必须大于100秒).(这个值根据目前的网络设置,可以适当地改小,我的网络内修改为了5)

tcp_orphan_retries ：INTEGER
默认值是7
在近端丢弃TCP连接之前﹐要进行多少次重试。默认值是7个﹐相当于 50秒 - 16分钟﹐视 RTO 而定。如果您的系统是负载很大的web服务器﹐那么也许需要降低该值﹐这类 sockets 可能会耗费大量的资源。另外参的考tcp_max_orphans 。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为3)

tcp_fin_timeout ：INTEGER
默认值是 60
对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。默认值为 60 秒。过去在2.2版本的内核中是 180 秒。您可以设置该值﹐但需要注意﹐如果您的机器为负载很重的web服务器﹐您可能要冒内存被大量无效数据报填满的风险﹐FIN-WAIT-2 sockets 的危险性低于 FIN-WAIT-1 ﹐因为它们最多只吃 1.5K 的内存﹐但是它们存在时间更长。另外参考 tcp_max_orphans。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为30)

tcp_max_tw_buckets ：INTEGER
默认值是180000
系 统在同时所处理的最大 timewait sockets 数目。如果超过此数的话﹐time-wait socket 会被立即砍除并且显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要人为的降低这个限制﹐不过﹐如果网络条件需要比默认值更多﹐则可以提高它(或许还要增加内存)。(事实上做NAT的时候最好可以适当地增加该值)

tcp_tw_recycle ：BOOLEAN
默认值是0
打开快速 TIME-WAIT sockets 回收。除非得到技术专家的建议或要求﹐请不要随意修改这个值。(做NAT的时候，建议打开它)

tcp_tw_reuse：BOOLEAN
默认值是0
该文件表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助)

tcp_max_orphans ：INTEGER
缺省值是8192
系统所能处理不属于任何进程的TCP sockets最大数量。假如超过这个数量﹐那么不属于任何进程的连接会被立即reset，并同时显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要依赖这个或是人为的降低这个限制(这个值Redhat AS版本中设置为32768,但是很多防火墙修改的时候,建议该值修改为2000)

tcp_abort_on_overflow ：BOOLEAN
缺省值是0
当守护进程太忙而不能接受新的连接，就象对方发送reset消息，默认值是false。这意味着当溢出的原因是因为一个偶然的猝发，那么连接将恢复状态。只有在你确信守护进程真的不能完成连接请求时才打开该选项，该选项会影响客户的使用。(对待已经满载的sendmail,apache这类服务的时候,这个可以很快让客户端终止连接,可以给予服务程序处理已有连接的缓冲机会,所以很多防火墙上推荐打开它)

tcp_syncookies ：BOOLEAN
默认值是0
只有在内核编译时选择了CONFIG_SYNCOOKIES时才会发生作用。当出现syn等候队列出现溢出时象对方发送syncookies。目的是为了防止syn flood攻击。
注意：该选项千万不能用于那些没有收到攻击的高负载服务器，如果在日志中出现synflood消息，但是调查发现没有收到synflood攻击，而是合法用户的连接负载过高的原因，你应该调整其它参数来提高服务器性能。参考:
tcp_max_syn_backlog
tcp_synack_retries
tcp_abort_on_overflow
syncookie严重的违背TCP协议，不允许使用TCP扩展，可能对某些服务导致严重的性能影响(如SMTP转发)。(注意,该实现与BSD上面使用的tcp proxy一样,是违反了RFC中关于tcp连接的三次握手实现的,但是对于防御syn-flood的确很有用.)

tcp_stdurg ：BOOLEAN
默认值为0
使用 TCP urg pointer 字段中的主机请求解释功能。大部份的主机都使用老旧的 BSD解释，因此如果您在 Linux 打开它﹐或会导致不能和它们正确沟通。

tcp_max_syn_backlog ：INTEGER
对于那些依然还未获得客户端确认的连接请求﹐需要保存在队列中最大数目。对于超过 128Mb 内存的系统﹐默认值是 1024 ﹐低于 128Mb 的则为 128。如果服务器经常出现过载﹐可以尝试增加这个数字。警告﹗假如您将此值设为大于 1024﹐最好修改 include/net/tcp.h 里面的 TCP_SYNQ_HSIZE ﹐以保持TCP_SYNQ_HSIZE*16<=tcp_max_syn_backlog ﹐并且编进核心之内。(SYN Flood攻击利用TCP协议散布握手的缺陷，伪造虚假源IP地址发送大量TCP-SYN半打开连接到目标系统，最终导致目标系统Socket队列资源耗 尽而无法接受新的连接。为了应付这种攻击，现代Unix系统中普遍采用多连接队列处理的方式来缓冲(而不是解决)这种攻击，是用一个基本队列处理正常的完 全连接应用(Connect()和Accept() )，是用另一个队列单独存放半打开连接。这种双队列处理方式和其他一些系统内核措施(例如Syn-Cookies/Caches)联合应用时，能够比较有效的缓解小规模的SYN Flood攻击(事实证明<1000p/s)加大SYN队列长度可以容纳更多等待连接的网络连接数，所以对Server来说可以考虑增大该值.)

tcp_window_scaling ：INTEGER
缺省值为1
该 文件表示设置tcp/ip会话的滑动窗口大小是否可变。参数值为布尔值，为1时表示可变，为0时表示不可变。tcp/ip通常使用的窗口最大可达到 65535 字节，对于高速网络，该值可能太小，这时候如果启用了该功能，可以使tcp/ip滑动窗口大小增大数个数量级，从而提高数据传输的能力(RFC 1323)。（对普通地百M网络而言，关闭会降低开销，所以如果不是高速网络，可以考虑设置为0）

tcp_timestamps ：BOOLEAN
缺省值为1
Timestamps 用在其它一些东西中﹐可以防范那些伪造的 sequence 号码。一条1G的宽带线路或许会重遇到带 out-of-line数值的旧sequence 号码(假如它是由于上次产生的)。Timestamp 会让它知道这是个 '旧封包'。(该文件表示是否启用以一种比超时重发更精确的方法（RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。)

tcp_sack ：BOOLEAN
缺省值为1
使 用 Selective ACK﹐它可以用来查找特定的遗失的数据报--- 因此有助于快速恢复状态。该文件表示是否启用有选择的应答（Selective Acknowledgment），这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）。(对于广域网通信来说这个选项应该启用，但是这会增加对 CPU 的占用。)

tcp_fack ：BOOLEAN
缺省值为1
打开FACK拥塞避免和快速重传功能。(注意，当tcp_sack设置为0的时候，这个值即使设置为1也无效)

tcp_dsack ：BOOLEAN
缺省值为1
允许TCP发送"两个完全相同"的SACK。

http://blog.csdn.net/zhangxinrun/article/details/7621028


#################################################################################333


                            CLUSTER(集群与存储)
Top
NSD CLUSTER DAY01

案例1：ipvsadm命令用法
案例2：部署LVS-NAT集群
案例3：部署LVS-DR集群

集群:
1, 一组通过高速网络互联的计算机,并以单一系统的模式加以管理
2, 将很多服务器集中起来一起,提供同一种服务,在客户端看来就像是只有一个服务器
3. 可以在付出较低成本的情况下获得在性能,可靠性,灵活性方面的相对较高的利益
4, 任务调度是集群系统中的核心技术

集群目的:
提高性能,降低成本,提高可扩展性,增强可靠性

LVS集群组成:
1, 前段: 负载均衡层
2, 中间: 服务器群组层
3, 底端: 数据共享存储层		

LVS  是路由器的原理(不是代理)   路由器的工作原理:数据包转发+NAT

nginx代理工作原理:    nginx作为代理,客户端发送请求给代理,代理帮客户端访问服务器,中间代理频繁进行数据包解压封装
LVS 工作原理:   lvs工作原理为路由器,有地址转换和转发功能,通过地址的转换和转发数据,不进行数据包解压封装,效率提升,存在地址转换,服务器需要设置网关

LVS性能>nginx性能

LVS 调度算法:
1, 轮询 rr
2, 加权轮询 wrr
3, 最少连接算法 lc
4, 加权最少连接算法  wlc
5, 原地址哈希 sh(相同客户端访问相同服务器)
6, 目标地址哈希  dh

1 案例1：ipvsadm命令用法
1.1 问题

准备一台Linux服务器，安装ipvsadm软件包，练习使用ipvsadm命令，实现如下功能：
使用命令添加基于TCP一些的集群服务
在集群中添加若干台后端真实服务器
实现同一客户端访问，调度器分配固定服务器
会使用ipvsadm实现规则的增、删、改
保存ipvsadm规则
1.2 方案

安装ipvsadm软件包，关于ipvsadm的用法可以参考man ipvsadm资料。
常用ipvsadm命令语法格式如表-1及表-2所示。



表－1 ipvsadm命令选项
  ipvsadm -A        添加虚拟服务器
  ipvsadm -E        修改虚拟服务器
  ipvsadm -D        删除虚拟服务器
  ipvsadm -C          清空所有
  ipvsadm -a        添加真实服务器
  ipvsadm -e        修改真实服务器
  ipvsadm -d        删除真实服务器
  ipvsadm -L        查看LVS规则表
  -s [rr|wrr|lc|wlc|sh]  指定集群算法
  


表－2 ipvsadm语法案例
   ipvsadm -A -t|u 192.168.4.5:80 -s [算法]   添加虚拟服务器,协议为tcp(-t)或udp(-u)
   ipvsadm -E -t|u 192.168.4.5:80 -s [算法]   修改虚拟服务器,协议为tcp(-t)或udp(-u)
   ipvsadm -D -t|u 192.168.4.5:80            删除虚拟服务器,协议为tcp(-t)或udp(-u)
   ipvsadm -C                                清空所有
   ipvsadm -a -t|u 192.168.4.5:80 -r 192.168.2.100 [-g|i|m] [-w 权重]  添加真实服务器 -g(DR模式(Route) ->默认), -i(隧道模式(Tunnel)), -m(NAT模式(Masq))
    ipvsadm -Ln        查看LVS规则表




1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：使用命令增、删、改LVS集群规则

1）创建LVS虚拟集群服务器（算法为加权轮询：wrr）
[root@proxy ~]# yum -y install ipvsadm
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:80 -s wrr
[root@proxy ~]# ipvsadm -Ln          //查看LVS集群规则
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 wrr

2）为集群添加若干real server
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 -w 1
[root@proxy ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 wrr
  -> 192.168.2.100:80             router    1      0          0
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.200 -m -w 2
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.201 -m -w 3
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.202 -m -w 4

3）修改集群服务器设置(修改调度器算法，将加权轮询修改为轮询)
[root@proxy ~]# ipvsadm -E -t 192.168.4.5:80 -s rr
[root@proxy ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 rr
  -> 192.168.2.100:80             router    1      0          0         
  -> 192.168.2.200:80             masq      2      0          0         
  -> 192.168.2.201:80             masq      2      0          0         
  -> 192.168.2.202:80             masq      1      0          0

4）修改read server（使用-g选项，将模式改为DR模式）
[root@proxy ~]# ipvsadm -e -t 192.168.4.5:80 -r 192.168.2.202 -g

5）查看LVS状态
[root@proxy ~]# ipvsadm -Ln
+                
6）创建另一个集群（算法为最少连接算法；使用-m选项，设置工作模式为NAT模式）
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:3306 -s lc
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.100 -m
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.200 -m

7）永久保存所有规则
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm

8）清空所有规则
[root@proxy ~]# ipvsadm -C

2 案例2：部署LVS-NAT集群
2.1 问题

使用LVS实现NAT模式的集群调度服务器，为用户提供Web服务：
集群对外公网IP地址为192.168.4.5
调度器内网IP地址为192.168.2.5
真实Web服务器地址分别为192.168.2.100、192.168.2.200
使用加权轮询调度算法，真实服务器权重分别为1和2
2.2 方案

实验拓扑结构主机配置细节如表-3所示。
表-3

使用4台虚拟机，1台作为Director调度器、2台作为Real Server、1台客户端，拓扑结构如图-1所示，注意：web1和web2必须配置网关地址。

图-1

client  eth0:192.168.4.10/24

proxy   eth0:192.168.4.5/24
        eth1:192.168.2.5/24

web1    eth1:192.168.2.100/24
            网关:192.168.2.5

web2    eth1:192.168.2.200/24
            网关:192.168.2.5

2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置基础环境

1）设置Web服务器（以web1为例）
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
2）启动Web服务器软件
[root@web1 ~]# systemctl restart httpd
3)关闭防火墙与SELinux
[root@web1 ~]# systmctl stop firewalld
[root@web1 ~]# setenforce 0

步骤二：部署LVS-NAT模式调度器

1)确认调度器的路由转发功能(如果已经开启，可以忽略)  ------> 打开路由功能

[root@proxy ~]# echo 1 > /proc/sys/net/ipv4/ip_forward   //此文件无法用vim修改,只能echo且为临时性的 功能是开启路由功能
[root@proxy ~]# cat /proc/sys/net/ipv4/ip_forward
1
[root@proxy ~]# echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf  
#修改配置文件，设置永久规则,功能是开启路由功能


2）创建集群服务器

[root@proxy ~]# yum -y install ipvsadm
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:80 -s wrr
3）添加真实服务器
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 -w 1 -m
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.200 -w 1 -m
4）查看规则列表，并保存规则
[root@proxy ~]# ipvsadm -Ln
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm

步骤三：客户端测试

客户端使用curl命令反复连接http://192.168.4.5，查看访问的页面是否会轮询到不同的后端真实服务器。


3 案例3：部署LVS-DR集群

准备环境
                     <------返回数据
              ___________________                              
              |                                |
        client------>proxy------->web


1, web需要和client在一个网段 (因为web需要直接返回网页给client)
2, web需要伪装成调度的VIP(因为访问的目标ip,和回复数据的ip必须一致)
3, 修改内核防止网络冲突 (/etc/sysctl.conf)
4, VIP必须配置在辅助接口,DIP必须配置在主接口

1 问题
使用LVS实现DR模式的集群调度服务器，为用户提供Web服务：
客户端IP地址为192.168.4.10
LVS调度器VIP地址为192.168.4.15
LVS调度器DIP地址设置为192.168.4.5
真实Web服务器地址分别为192.168.4.100、192.168.4.200
使用加权轮询调度算法，web1的权重为1，web2的权重为2
说明：
CIP是客户端的IP地址；
VIP是对客户端提供服务的IP地址；
RIP是后端服务器的真实IP地址；
DIP是调度器与后端服务器通信的IP地址（VIP必须配置在虚拟接口）。
3.2 方案

使用4台虚拟机，1台作为客户端、1台作为Director调度器、2台作为Real Server，拓扑结构如图-2所示。实验拓扑结构主机配置细节如表-4所示。

图-2
表-4

3.3 步骤

实现此案例需要按照如下步骤进行。
说明：
CIP是客户端的IP地址；
VIP是对客户端提供服务的IP地址；
RIP是后端服务器的真实IP地址；
DIP是调度器与后端服务器通信的IP地址（VIP必须配置在虚拟接口）。
步骤一：配置实验网络环境

1）设置Proxy代理服务器的VIP和DIP

注意：为了防止冲突，VIP必须要配置在网卡的虚拟接口！！！

 [root@proxy ~]# cd /etc/sysconfig/network-scripts/
[root@proxy ~]# cp ifcfg-eth0{,:0}
[root@proxy ~]# vim ifcfg-eth0
TYPE=Ethernet     //网卡是以太网卡
BOOTPROTO=none    //没有dhcp则自己配
DEFROUTE=yes      //默认路由
NAME=eth0         //网卡名
DEVICE=eth0       //设备名称
ONBOOT=yes        //当开机时启动
IPADDR=192.168.4.5  //IP地址
PREFIX=24           //子网掩码
[root@proxy ~]# vim ifcfg-eth0:0
TYPE=Ethernet
BOOTPROTO=none
DEFROUTE=yes
NAME=eth0:0
DEVICE=eth0:0
ONBOOT=yes
IPADDR=192.168.4.15
PREFIX=24
[root@proxy ~]# systemctl restart network
[root@proxy ~]# ifconfig         //这里有时候看不到eth0:0网卡,因为RHEL7里网络配置文件NetworkManager和Centos7里网络配置文件 network 两个服务冲突必须先关掉一个才可以启动(systemctl stop network|NetworkManager)
 
2）设置Web1服务器网络参数
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0
接下来给web1配置VIP地址。
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web1 ~]# cd /etc/sysconfig/network-scripts/
[root@web1 ~]# cp ifcfg-lo{,:0}
[root@web1 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0
防止地址冲突的问题：
这里因为web1也配置与代理一样的VIP地址，默认肯定会出现地址冲突；
sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。
[root@web1 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15
[root@web1 ~]# sysctl -p
重启网络服务，设置防火墙与SELinux
[root@web1 ~]# systemctl restart network
[root@web1 ~]# ifconfig
常见错误：如果重启网络后未正确配置lo:0，有可能是NetworkManager和network服务有冲突，关闭NetworkManager后重启network即可。（非必须的操作）
[root@web1 ~]# systemctl stop NetworkManager
[root@web1 ~]# systemctl restart network
3）设置Web2服务器网络参数
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0
接下来给web2配置VIP地址
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web2 ~]# cd /etc/sysconfig/network-scripts/
[root@web2 ~]# cp ifcfg-lo{,:0}           //lo本地回环地址网卡
[root@web2 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15          //IP地址
NETMASK=255.255.255.255      //子网掩码
NETWORK=192.168.4.15         //网络位  
BROADCAST=192.168.4.15       //广播地址
ONBOOT=yes                   //当开机时启动
NAME=lo:0
防止地址冲突的问题：
这里因为web1也配置与代理一样的VIP地址，默认肯定会出现地址冲突；
sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。

[root@web2 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容  (防止冲突,只对192.168.4.15有效,其它无效)
net.ipv4.conf.all.arp_ignore = 1   //默认为0 表示问什么回答什么, 1 表示不回答(本机忽略) ,all所有网卡不包含lo
net.ipv4.conf.lo.arp_ignore = 1    //默认为0 表示问什么回答什么, 1 表示不回答(本机忽略)
net.ipv4.conf.lo.arp_announce = 2  //本机不要向外宣告自己的lo回环地址是192.168.4.15
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15
[root@web2 ~]# sysctl -p       //刷新读取配置文件使永久配置立即生效
重启网络服务，设置防火墙与SELinux
[root@web2 ~]# systemctl restart network
[root@web2 ~]# ifconfig
常见错误：如果重启网络后未正确配置lo:0，有可能是NetworkManager和network服务有冲突，关闭NetworkManager后重启network即可。（非必须的操作）
[root@web1 ~]# systemctl stop NetworkManager
[root@web1 ~]# systemctl restart network


/proc/sys/net/ipv4/conf/     //网卡所在目录

步骤二：proxy调度器安装软件并部署LVS-DR模式调度器

1）安装软件（如果已经安装，此步骤可以忽略）
[root@proxy ~]# yum -y install ipvsadm
2）清理之前实验的规则，创建新的集群服务器规则
[root@proxy ~]# ipvsadm -C                                #清空所有规则
[root@proxy ~]# ipvsadm -A -t 192.168.4.15:80 -s wrr
3）添加真实服务器(-g参数设置LVS工作模式为DR模式，-w设置权重)
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.100 -g -w 1
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.200 -g -w 1
4）查看规则列表，并保存规则
[root@proxy ~]# ipvsadm -Ln
TCP  192.168.4.15:80 wrr
  -> 192.168.4.100:80             Route   1      0          0         
  -> 192.168.4.200:80             Route   2      0          0
步骤三：客户端测试

客户端使用curl命令反复连接http://192.168.4.15，查看访问的页面是否会轮询到不同的后端真实服务器。
扩展知识：默认LVS不带健康检查功能，需要自己手动编写动态检测脚本，实现该功能：(参考脚本如下，仅供参考)
[root@proxy ~]# vim check.sh
#!/bin/bash
VIP=192.168.4.15:80
RIP1=192.168.4.100
RIP2=192.168.4.200
while :
do
   for IP in $RIP1 $RIP2
   do
           curl -s http://$IP &>/dev/vnull
if [ $? -eq 0 ];then
            ipvsadm -Ln |grep -q $IP || ipvsadm -a -t $VIP -r $IP
        else
             ipvsadm -Ln |grep -q $IP && ipvsadm -d -t $VIP -r $IP
        fi
   done
sleep 1
done
















 















































 




























































































































 




















































 








































































































































































































































































































































































































































