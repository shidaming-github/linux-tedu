 
   damin 

date 1

Linux系统简介        
Linux是一种操作系统!

Unix/Linux发展史

• UNIX诞生,1970-1-1

Linux的诞生
• Linux之父,Linus Torwalds
– 1991年10月,发布0.02版(第一个公开版)内核
– 1994年03月,发布1.0版内核
– 标准读音:“哩呐科斯”

– 内核版本号:主版本.次版本.修订号       4.10.123
        用户------>内核------>硬件
内核分为（ 进程管理系统   ） 、（ 内存管理系统   ）、（ I\O管理系统   ） 和（ 文件管理系统  ） 等四个子系统。
Linux内核引导时，从文件（    /etc/fstab    ）中读取要加载的文件系统

#################################################
Linux版本及应用
• 发行版的名称/版本由发行方决定
– Red Hat Enterprise Linux 5/6/7
– Suse Linux Enterprise 12
– Debian Linux 7.8
– Ubuntu Linux 14.10/15.04

#############################################
利用虚拟机Linux安装:CentOS7.5
  CentOS需要内存2G
 
  Ctrl+Alt=鼠标回到真机

################################################
预备知识
Linux目录结构

   根目录(/): 所有的数据都在此目录下(Linux系统的起点)
   /dev:存放设备(键盘\鼠标\显示器\磁盘\光驱等)相关的数据
   
    路径:/dev/abc/mp3.txt

– Unix/Linux的基本哲学理念:一切皆文件

利用root登录系统:
  点击"未列出"---->输入用户名root----->输入密码 

###################################################
Linux磁盘表示

hd,表示IDE设备
sd,表示SCSI设备

       /dev/sda :表示SCSI设备,第一块
       /dev/sdb :表示SCSI设备,第二块
       /dev/sdc :表示SCSI设备,第三块

       /dev/hdd :表示IDE设备,第四块

Linux系统中第三块SCSI硬盘如何表示?
     /dev/sdc

###################################################
获取命令行界面      

• 虚拟控制台切换( Ctrl + Alt + Fn 组合键)
– tty1:图形桌面
– tty2~tty6:字符控制台

图形命令行界面:鼠标右击--->打开终端

 快捷键:  
    变大:Ctrl  shift  +
    变小:Ctrl  -

命令行提示符:
    [当前登录的用户@当前主机名 当前所在位置]#

    #:代表当前身份为超级管理员 root
    $:代表当前身份为普通用户

二、TCP/IP协议简介
1.什么是协议
协议就是一组规则
TCP/IP协议就是一组通信协议的集合
2.计算机通信三要素
IP地址
子网掩码
网关
3.什么是IP地址
标识网络中某一个节点的地址
ipv4	32位二进数
ipv6	128位二进数
ip地址每一个字段最大范围255

172.60.50.150(十进制)
10101100.00111100.00110010.10010110(二进制)

00000000.00000000.00000000.00000000 ~ 0.0.0.0
11111111.11111111.11111111.11111111 ~ 255.255.255.255
4. IP地址分类
A 	1 ~ 127		
B	128 ~ 191	
C	192 ~ 223

D  组播	224 ~ 239
E  科研	240 ~ 254

IP地址：网络位+主机位
网络位 = 电话号码的区号：标识一个网络
主机位 = 具体的电话号码：标识具体的一个主机
电话号码：区号+座机号
北京：010-63527788	
广州：020-63527788
A	网络+主机+主机+主机		10.1.1.10
B	网络+网络+主机+主机		173.5.5.10
C	网络+网络+网络+主机		192.168.10.10

相同网络位的主机可以直接通信
192.168.10.10	192.168.10.0
192.168.10.20	192.168.10.0
5.子网掩码
设置IP时必须有子网掩码
作用：判断IP地址的网络位，相同网络位的主机可以直接通信
默认子网掩码
A类地址	255.0.0.0
B类地址	255.255.0.0
C类地址	255.255.255.0

192.168.10.10	11000000.10101000.00001010.00001010
255.255.255.0	11111111.11111111.11111111.00000000
		        11000000.10101000.00001010.00000000
			192.168.10.0
192.168.10.20	11000000.10101000.00001010.00010100
255.255.255.0
6.网关
在同一个网络里面通信不需要网关
和另外网络中的计算机通信需要网关
网关：从你当前网络去往对方网络的出口
网关一定和你当前IP在同一网段
在实际生产环境中一般网关是路由器或者防火墙
10.0.0.10	255.255.255.0  = 10.0.0.10/24

三、基本环境配置
1.为虚拟机win2008配置IP地址。利用管理员进行登录，密码为：tedu
配置IP地址：　　192.168.1.1　　子网掩码：255.255.255.0
– 右击桌面网络 --＞属性 --＞更改适配器设置
– 双击“本地连接” --＞ 属性
– 双击“Internet协议版本4(TCP/IPv4)”　　　
– 配置完成后,单击“确定”完成

查看IP地址：　
– 右击桌面网络 --＞属性 --＞更改适配器设置
– 双击“本地连接” --＞ 详细信息

采用ipconfig命令的方式，查看IP地址：
   　windows键　＋　ｒ＝　开始＋运行
　　　输入cmd-->敲回车--＞输入　ipconfig-->敲回车
　　　--＞输入　exit　关闭命令行界面

案例一：配置win2008网络参数，确保连通性
克隆虚拟机win2008　　　　　　　　　　
1.双击桌面windows还原,打开桌面虚拟系统管理器,双击win2008,选择查看,详情,把内存4096修改成2048,应用.
2.进行虚拟机克隆
　双击＂虚拟系统管理器＂--＞右击＂win2008＂--＞克隆--＞克隆
3. 配置二台win2008的网络参数
配置win2008的IP地址	192.168.1.10  
			子网掩码	255.255.255.0
			网关	192.168.1.254
			dns	202.106.0.20　
 – 右击桌面网络 --＞属性 --＞更改适配器设置
 – 双击“本地连接” --＞ 属性
 – 双击“Internet协议版本4(TCP/IPv4)”　　　
 – 配置完成后,单击“确定”完成

配置win2008-clone的IP地址：192.168.1.20  
			子网掩码	255.255.255.0
			网关	192.168.1.254
			dns	202.106.0.20　
 – 右击桌面网络 --＞属性 --＞更改适配器设置
 – 双击“本地连接” --＞ 属性
 – 双击“Internet协议版本4(TCP/IPv4)”　　　
 – 配置完成后,单击“确定”完成

采用ipconfig命令的方式，查看IP地址：
   　windows键　＋　ｒ＝　开始＋运行
　　　输入cmd-->敲回车--＞输入　ipconfig-->敲回车
　　　--＞输入　exit　关闭命令行界面

采用命令方式，测试网络联通性：
　　ping　　命令
　　ping   对方IP地址　　　ping命令是双向，有去有回
　　ping 　192.168.1.20　

　　ping 　192.168.1.２　

DNS服务器：将网站的域名解析为,对应的IP地址
  
         www.qq.com-------＞腾讯的服务器
         www.baidu.com-------＞百度的服务器

1. 访问京东查看主流服务器价格和硬件配置信息
2. 为什么IDC数据中心的服务器没有显示器,键盘,鼠标
3. 为什么企业会把核心服务器放到IDC数据中心
4. 传一个ipv4-ipv6激情小视频
5. 为什么主机设置的网关地址都和本机IP在同一网段
6. 请问ABC三类地址,哪类地址容纳主机数最多?哪些容纳主机数最少?
7. 假设主机选择自动获取IP,但是网络中没有dhcp服务器可以分配地址的时候怎么办?
8. 电脑能够正常上QQ,但是打不开baidu,sina等网站?		          
			  
#########################################################################
   date 2
﻿早自习默写
1.IP地址的分类及范围？
2.子网掩码的作用？
3.网关的作用？ 
4.ABC类IP地址默认子网掩码是？

一、Linux系统简介
1.什么是Linux?
Linux是一种操作系统，主要用在企业服务器上面
2.Linux系统内核
版本号:主版本.次版本.修订号
3.RedHat系列版本
– Red Hat Enterprise Linux（RHEL） 5/6/7/8
– CentOS
– Fedora Core社区版

二、安装Linux系统
1.Linux 一切皆文件
  Linux严格区分大小写
2.建议内存2G以上
3.Linux磁盘表示
/dev/xdy
/dev	表示/dev目录
xd	hd	ide接口硬盘
	sd	非ide接口硬盘（SATA、SCSI）
	vd	虚拟机磁盘
y	a	第一块硬盘
	b	第二块硬盘
	c	第三块硬盘
	...
/dev/hdb		第二块IDE接口的硬盘
/dev/vda3	第一块虚拟磁盘第三个分区
/dev/sdd1	第四块非IDE接口的第一个分区



4.默认Linux管理员 root
5.Ctrl + Alt = 鼠标回到真机
6.目录结构
/	Linux文件系统的起点，所有Linux数据全部存放在/下
/dev	存放设备相关的
/root	管理员的家目录
/home	普通用户的家目录


三、命令行基本操作
1.Linux虚拟控制台
tty1 ~ tty6
tty1 		图形
tty2~tty6	字符
切换：
图形切换到字符	ctrl+alt+(F2~F6)
字符之间切换	alt+(F2~F6)
字符到图形	alt+F1
2.Linux命令行提示符
[登录用户@主机名 工作目录] 身份标识
# 代表管理员
$ 代表普通用户
3.Linux基本命令
# pwd		//显示当前工作目录
# cd		//切换路径
# cd .		//当前不变
# cd ..		//返回上一层目录
# cd ../..	//返回上一层的上一层
# cd -		//返回上一次工作目录
# cd ~ = cd 	//进入当前用户家目录
绝对路径：以/开始的路径
相对路径：不以/开始的路径
eg:
[student@room9pc01 home]$ cd
[student@room9pc01 ~]$ pwd
/home/student
[student@room9pc01 ~]$ cd .
[student@room9pc01 ~]$ pwd
/home/student
[student@room9pc01 ~]$ cd ..
[student@room9pc01 home]$ pwd
/home
[student@room9pc01 home]$ cd -
/home/student
[student@room9pc01 ~]$ pwd
/home/student
[student@room9pc01 ~]$ cd ../..
[student@room9pc01 /]$ pwd
/

# ls		//列出目录内容/文件权限
# cat		//查看文件内容
eg:
[student@room9pc01 /]$ cd
[student@room9pc01 ~]$ pwd
/home/student
[student@room9pc01 ~]$ ls
[student@room9pc01 ~]$ cd /etc/redhat-release 
-bash: cd: /etc/redhat-release: 不是目录
[student@room9pc01 ~]$ cat /etc/redhat-release 
CentOS Linux release 7.5.1804 (Core) 

# lscpu		//查看cpu信息
# cat /proc/meminfo	//查看内存信息
eg:
[student@room9pc01 ~]$ lscpu 
[student@room9pc01 ~]$ cat /proc/meminfo
		16:10  -  16:30
# hostname		//查看主机名
# ifconfig		//查看ip地址
# mkdir			//创建目录
# touch			//创建文件
eg:
[student@room9pc01 ~]$ hostname
[student@room9pc01 ~]$ ifconfig
[student@room9pc01 ~]$ ls /tmp/
[student@room9pc01 ~]$ mkdir /tmp/vod
[student@room9pc01 ~]$ ls /tmp/
vod
[student@room9pc01 ~]$ ls /tmp/
vod
[student@room9pc01 ~]$ touch /tmp/nsd1907.txt
[student@room9pc01 ~]$ ls /tmp/
nsd1907.txt  vod

# less			//查看大文件内容分屏查看
# head			//默认查看文件头10行
# tail			//默认查看文件尾10行
# grep			//过滤包含关键字的行
# nmtui			//配置网络参数（ip地址、子网掩码、网关、dns、主机名）
# poweroff		//关机
# reboot		//重启

# cd /root
# cd root	
5.编辑命令或路径的技巧：　Tab可以进行补全       
# if(tab)(tab)
if         ifdown     ifup
ifcfg      ifenslave  
ifconfig   ifstat     
# ifco(tab)
# cat /et(tab)/red(tab)
CentOS Linux release 7.5.1804 (Core)
# ls /etc/sysconfig/network-scripts/ifcfg-eth0 
# ls /et(tab)/sysco(tab)/netw(tab)-(tab)/ifc(tab)-e(tab)

补充: Linux下的颜色
蓝色 --> 目录
红色 --> 压缩文件
绿色 --> 可执行文件

课外作业：
1. 为什么计算机的时间是从1970年1月1开始?
https://mixer-b.iteye.com/blog/1563869
2.C语言之父
3. 什么是Linux?
4. 如何破解Linux密码?
5.


###########################################################

date 3

早自习默写
1. Linux下目录作用（day02讲解的四个）
2. Linux命令行提示符
3. 写出10个以上的Linux命令

一、命令行基础
1. 命令行的格式
命令字   [选项]…   [参数1] [参数2]…
[ ] 表示里面的内容可有可无
在执行一个命令的时候，命令字必须存在，选项和参数可有可无
命令字 选项 参数之间必须有空格
选项：用来调控执行方式
     单个字符一般用-
     单词一般用--
eg：
（以下命令不需要理解意思，只需要知道谁是命令字，谁是选项，选项什么时候-，什么时候用--）
# ls
# ls -l
# ls -l -h  = # ls -lh
# ls --help
# ls -ld /home
# ls -ld /home  /boot
参数：命令的操作对象，如文档的存放路径、用户名等
2.快捷编辑
tab键功能：
命令或者路径的补齐，如果输入的内容唯一标识某一个命令或者路径，tab一次会自动补齐。如果不唯一则tab2次显示出以输入内容开头的所有的命令或者路径
      排错
eg：
# if(tab)(tab)
if         ifdown     ifup
ifcfg      ifenslave  
ifconfig   ifstat     
# ifco(tab)
# cat /et(tab)/red(tab)
CentOS Linux release 7.5.1804 (Core)
# ls /etc/sysconfig/network-scripts/ifcfg-eth0 
# ls /et(tab)/sysco(tab)/netw(tab)-(tab)/ifc(tab)-e(tab)
快捷键
Ctrl + l	清空整个屏幕
Ctrl + c	废弃当前编辑的命令行
Esc+.		粘贴上一个命令的参数
3.mount挂载操作
挂载
将光盘/U盘/分区/网络存储等设备装到某个Linux目录，通过访问这个目录来操作设备上的文档
mount 设备 挂载点（一定是目录）
卸载
umount 设备
umount 挂载点
Linux下的光驱设备
/dev/sr0
/dev/cdrom

eg:访问centos7安装镜像文件内容
1.把centos7镜像放入光驱
点击虚拟机图形的查看/详情/，找到IDE CDROM1，选择连接。选择ISO映像位置，浏览/iso/CentOS7-1804.iso/选择卷/确定
2.mount命令挂载
[root@localhost ~]# ls /mnt/
[root@localhost ~]# mount /dev/cdrom  /mnt/
3.验证是否挂载成功
[root@localhost ~]# ls /mnt/
4.umount命令卸载
[root@localhost ~]# umount /dev/cdrom
或者
[root@localhost ~]# umount /mnt
5.验证是否卸载成功
[root@localhost ~]# ls /mnt/

注意事项:
1.卸载不要在当前的挂载点(访问点)目录下
[root@localhost ~]# cd /mnt
[root@localhost mnt]# umount /mnt
umount: /dvd：目标忙。
2.挂载允许一个设备具备多个挂载点(访问点)
3.不允许多个设备挂载到一个挂载点(访问点)

二、目录和文件管理
1. cd ~user	表示进入用户user的家目录
2. ls 		列出文档及属性
	-l	以长格式显示,显示目录内容的详细属性
	-A	包括名称以 . 开头的隐藏文档
	-d	显示目录本身(而不是内容)的属性
	-h	提供易读的容量单位(K、M等)
eg：
[root@localhost ~]# cd ~
[root@localhost ~]# pwd
[root@localhost ~]# ls /root/
[root@localhost ~]# mkdir ~/day03
[root@localhost ~]# ls /root/
[root@localhost ~]# cd ~/day03/
[root@localhost day03]# pwd
[root@localhost day03]# cd ~root
[root@localhost ~]# pwd
备注：
~后面接/的表示的是路径
~后面不是接/的表示是用户
[root@localhost ~]# cd 
[root@localhost ~]# ls
[root@localhost ~]# ls /root
[root@localhost ~]# ls -l  /root   //显示目录内容的详细属性
[root@localhost ~]# ls -ld /root   //显示目录本身的详细属性
[root@localhost ~]# ls -lh /root
[root@localhost ~]# ls -l /dev/cdrom   //显示文件详细属性
[root@localhost ~]# ls -l /etc/passwd
[root@localhost ~]# ls -lh /etc/passwd
[root@localhost ~]# ls /root
[root@localhost ~]# ls -A /root
3. 使用通配符		
针对不确定的文档名称,以特殊字符表示
*	匹配0到任意个字符                
?	单个字符
eg：
[root@localhost ~]# ls /boot
[root@localhost ~]# ls /boot/vm*     //以vm开头
[root@localhost ~]# ls /root/a*      //以a开头
[root@localhost ~]# ls /dev/tty*     //以tty开头
[root@localhost ~]# ls /etc/*tab     //以tab结尾
[root@localhost ~]# ls /etc/*.conf   //以.conf结尾
[root@localhost ~]# ls /etc/r*.conf  //以r开头并且.conf结尾
[root@localhost ~]# ls /etc/*passwd*
[root@localhost ~]# ls /dev/tty?
[root@localhost ~]# ls /dev/tty??

[a-z]		多个字符或连续范围中的一个,若无则忽略
{a,min,xy}	多组不同的字符串,全匹配
eg:
[root@localhost ~]# ls /dev/tty[3-8]
[root@localhost ~]# ls /dev/tty[0-9]
[root@localhost ~]# ls /dev/tty{1,3,5,7,9}
[root@localhost ~]# ls /dev/tty{1,3,5,7,9,23}
[root@localhost ~]# ls /dev/tty{1,3,S0,S1}
[root@localhost ~]# ls /dev/tty{1,3,S0,haha}
4.别名的定义:简化复杂命令
alias					查看已设置的别名
alias 别名名称='实际执行的命令行'	定义新的别名
unalias [别名名称]			取消已设置的别名
		16:10 - 16:25
eg:
[root@localhost ~]# hostname
localhost.localdomain
[root@localhost ~]# hn
bash: hn: 未找到命令...
[root@localhost ~]# alias hn='hostname'  //定义别名
[root@localhost ~]# hn                   //运行别名测试
[root@localhost ~]# alias        //查看当前系统有效的别名
[root@localhost ~]# unalias hn   //删除别名
[root@localhost ~]# hn
bash: hn: 未找到命令...
红帽考试题：
[root@localhost ~]# alias qstat='/bin/ps -Ao pid,tt,user,fname,rsz',
[root@localhost ~]# qstat
5. mkdir 创建目录
-p	创建父目录
ls
-R	递归:目录本身以及目录下所有
[root@localhost ~]# ls /opt
[root@localhost ~]# mkdir /opt/nsd01
[root@localhost ~]# ls /opt/
[root@localhost ~]# mkdir  /opt/nsd02   /opt/nsd03
[root@localhost ~]# ls /opt/
[root@localhost ~]# mkdir /vod/movie/cartoon
[root@localhost ~]# ls -R /vod
[root@localhost ~]# mkdir -p /vod/movie/cartoon
[root@localhost ~]# ls -R /vod
6.grep针对文本文件内容进行过滤,输出包含指定字符串的行
-v	取反匹配
-i	忽略大小写
eg:
[root@localhost /]# grep root /etc/passwd
[root@localhost /]# grep -v root /etc/passwd
[root@localhost /]# grep ROOT /etc/passwd
[root@localhost /]# grep -i ROOT /etc/passwd
word 	包含字符串word
^word 	以字符串word开头
word$ 	以字符串word结尾
eg:
[root@localhost /]# grep ^root /etc/passwd
[root@localhost /]# grep root$ /etc/passwd
[root@localhost /]# grep bash$ /etc/passwd

grep -w -o root /etc/passwd       //-w精确匹配 -o匹配行放在一列

去重命令中的uniq和sort的区别
	sort -u '文件'
	sort -n '文件' | uniq -c
查看目录中最近被修改的文件
	ls -t '目录'
如何计算字符串与数组的长度
	字符串: expr length '字符串'/$变量名
		${#字符串/变量名}
	数组: ${#数组名[*]}
 vim中查看匹配的单词,并显示具体个数
	:%s/root//gn
 vim中不忽略大小写查找匹配的单词
	:set noignorecase
 vim中如何将文件最后一行置顶
	z+t按键

7.复制
格式:
cp [选项]... 原文件...      目标路径
-r	递归,复制目录时必须有此选项
eg:
[root@localhost ~]# ls /tmp/bak
[root@localhost ~]# mkdir /tmp/bak
[root@localhost ~]# ls /tmp/bak
[root@localhost ~]# cp /etc/passwd  /tmp/bak
[root@localhost ~]# ls /tmp/bak
[root@localhost ~]# cp /home/  /tmp/bak
[root@localhost ~]# ls /tmp/bak
[root@localhost ~]# cp -r /home/  /tmp/bak
[root@localhost ~]# ls /tmp/bak
//可以支持两个以上的参数,永远将最后一个参数做目标,其他所有参数作为源
[root@localhost ~]# ls /tmp/bak
[root@localhost ~]# cp -r  /etc/hosts  /etc/fstab /boot/   /tmp/bak
[root@localhost ~]# ls /tmp/bak
//cp经常与点  . 连用,将数据复制到当前路径下
.	当前目录
[root@localhost ~]# cd /tmp/bak
[root@localhost bak]# pwd
[root@localhost bak]# ls
[root@localhost bak]# cp /etc/shadow  .  
[root@localhost bak]# ls
//复制到目标路径下,可以重新命名   
[root@localhost /]# ls /tmp/bak
[root@localhost /]# cp /etc/passwd  /tmp/bak
[root@localhost /]# ls /tmp/bak
[root@localhost /]# cp /etc/passwd /tmp/bak/pd
[root@localhost /]# ls /tmp/bak
[root@localhost /]# cp -r /home/ /tmp/bak/abc
[root@localhost /]# ls /tmp/bak
8.rm 删除		
格式:rm [选项]... 文件或目录...            
-r	递归删除(含目录)
-f	强制删除
[root@localhost ~]# rm /tmp/bak/abc
[root@localhost ~]# rm -r /tmp/bak/abc    
//试了几次不耐烦可以ctrl+c
[root@localhost ~]# rm -rf /tmp/bak/abc
[root@localhost ~]# ls /tmp/bak
[root@localhost ~]# rm -rf /tmp/bak
[root@localhost ~]# ls /tmp/
9.mv 移动/改名
格式: mv [选项]... 原文件...    目标路径
[root@localhost ~]# ls /tmp/nsd01
[root@localhost ~]# mkdir /tmp/nsd01
[root@localhost ~]# ls /tmp/nsd01
[root@localhost ~]# touch /tmp/1.txt
[root@localhost ~]# ls /tmp/
[root@localhost ~]# mv /tmp/1.txt /tmp/nsd01/
[root@localhost ~]# ls /tmp/
[root@localhost ~]# ls /tmp/nsd01/
//重命名:路径不变的移动
[root@localhost ~]# mv /tmp/nsd01/  /tmp/haha01
[root@localhost ~]# ls /tmp/
[root@localhost ~]# mv /tmp/haha01/ /tmp/stu01
[root@localhost ~]# ls /tmp/


补充：
Linux下目录结构
/proc	虚拟目录
/tmp	临时目录,默认数据存放10天不做任何操作系统直接删除
/etc	配置文件存放目录
/mnt	系统提供的挂载点
/boot	启动相关的目录，内核文件存放这里


课外作业：
1. 请问输入以下命令的区别
# cd /home
# cd home
2. 请问输入以下命令的区别
$ cd
$ ls
$ ls /root
3. 请分析下列两次复制的不同:
# rm -rf /opt/*
# cp -r /home/  /opt/redhat
将/home目录复制到/opt/并且重命名为redhat
# cp -r /home/  /opt/redhat
将/home目录复制到/opt/redhat目录下
4.linux虚拟机里查看日历
# cal 2019

##################################################
查看及切换目录
• pwd — Print Working Directory
– 用途:查看当前工作目录

• cd — Change Directory
– 用途:切换工作目录
– 格式:cd  [目标文件夹位置]

• ls — List
– 格式:ls [选项]... [目录或文件名]...

蓝色:目录
黑色:文本文件
[root@localhost ~]# pwd      #显示当前所在位置
[root@localhost ~]# cd  /    #切换到根目录下
[root@localhost /]# pwd       
[root@localhost /]# ls       #显示当前目录下内容
 
[root@localhost /]# cd /bin   #切换到/bin目录
[root@localhost bin]# pwd      
[root@localhost bin]# ls

[root@localhost /]# cd /boot   #切换到/boot目录
[root@localhost boot]# pwd
[root@localhost boot]# ls

[root@localhost /]# cd /root   #切换到/root目录
[root@localhost ~]# pwd
[root@localhost ~]# ls


查看文本文件命令:cat
[root@localhost ~]# ls /root/anaconda-ks.cfg
[root@localhost ~]# cat   /root/anaconda-ks.cfg
查看当前系统的版本
[root@localhost ~]# cat  /etc/redhat-release 
CentOS Linux release 7.5.1804 (Core) 

[root@localhost ~]# ls /etc/passwd
[root@localhost ~]# cat  /etc/passwd

[root@localhost ~]# ls /etc/fstab
[root@localhost ~]# cat  /etc/fstab
[root@localhost ~]# ls /etc/hosts
[root@localhost ~]# cat  /etc/hosts


查看CPU和内存
• 列出CPU处理器信息
[student@room9pc01 ~]$ lscpu 
CPU(s):                4

型号名称：        Intel(R) Core(TM) i5-4430S CPU @ 2.70GHz

• 检查内存大小、空闲情况
[student@room9pc01 ~]$ cat  /proc/meminfo
MemTotal:       16330736 kB

####################################################
• 列出当前系统的主机名称
[root@svr7 桌面]# hostname
[root@svr7 桌面]# hostname  A.tedu.cn   #临时设置主机名

[root@svr7 桌面]# hostname
[root@svr7 桌面]# exit    #关闭当前的终端

再开一个新的终端,查看提示符的变化

• 列出已激活的网卡连接信息
[root@A ~]# ifconfig    #查看网卡IP地址信息

[root@A ~]# ifconfig eth0 192.168.1.1  #临时设置IP地址
[root@A ~]# ifconfig eth0

  eth0:第一张网卡

lo:回环接口  专用于测试   本机访问本机

    127.0.0.1  永远代表本机

[root@A ~]# ping  127.0.0.1  
   按Ctrl + c 结束正在运行指令


• 重启系统命令
[root@A ~]# reboot

[root@localhost ~]# hostname        #查看主机名
[root@localhost ~]# ifconfig eth0   #查看IP地址

• 设置永久的主机名\IP地址\子网掩码\DNS服务器地址\网关地址
[root@A ~]# nmtui                        
 设置系统主机名-->输入新的名字-->确定-->确定

[root@A ~]# nmtui
　编辑连接 -->eth0-->编辑ipv4-->显示-->将自动修改手动
　-->按空格　勾选　自动连接    　    #每次开机自动生效
　-->按空格　勾选　对所有用户有效  

激活配置
[root@A ~]# nmtui
　启用连接 -->eth0-->敲回车　禁用-->敲回车　激活
　最终eth0前面有一个＊代表激活状态
[root@A ~]# ifconfig eth0


####################################################

• mkdir — Make Directory
– 格式:mkdir   [/路径/]目录名...
[root@1906 ~]# mkdir /root/nsd01    #在/root创建nsd01目录
[root@1906 ~]# ls /root/
[root@1906 ~]# mkdir /opt/nsd02  #在/opt创建nsd02目录
[root@1906 ~]# ls /opt/

[root@1906 ~]# mkdir nsd03    #当前路径下创建nsd03目录
[root@1906 ~]# ls             #查看当前路径下内容
[root@1906 ~]# pwd
[root@1906 ~]# mkdir /nsd04   #在/目录创建nsd04目录
[root@1906 ~]# ls /

[root@1906 ~]# touch /root/1.txt   #创建文本文件
[root@1906 ~]# ls /root/
[root@1906 ~]# touch /opt/2.txt
[root@1906 ~]# ls /opt/
##################################################
绝对路径:从根开始的路径
相对路径:不从根开始的路径(相对于当前的路径)

[root@1906 ~]# cd /etc/pki/
[root@1906 pki]# pwd
[root@1906 pki]# ls
[root@1906 pki]# cd  /etc/pki/CA   #绝对路径进入
[root@1906 CA]# pwd

[root@1906 CA]# cd /etc/pki/
[root@1906 pki]# pwd
[root@1906 pki]# ls
[root@1906 pki]# cd  CA     #进入当前路径下的CA
[root@1906 CA]# pwd


  .. :上一级目录
[root@1906 /]# cd /etc/pki/
[root@1906 pki]# pwd
/etc/pki
[root@1906 pki]# cd  ..   #返回当前路径的上一层
[root@1906 etc]# pwd
/etc
[root@1906 etc]# cd  ..
[root@1906 /]# pwd
/
[root@1906 /]# cd  ..

##############################################
文本内容操作
• less分屏阅读工具
• 格式:less [选项] 文件名...

– 优势:支持前后翻页
• 基本交互操作
– 按 / 键向后查找(n、N切换)

[root@1906 /]# less /etc/passwd
   按键盘  上 下 键 进行滚动
   输入 /bin 全文查找bin关键字
   按键盘  n 可以跳转匹配的项
   按键盘  q  退出

#####################################################
• head、tail 命令                                 
– 格式:
	head -n 数字 文件名
	tail -n 数字 文件名

[root@1906 /]# head -2 /etc/passwd  #显示文件头2行内容
[root@1906 /]# head -3 /etc/passwd

[root@1906 /]# tail -2 /etc/passwd
[root@1906 /]# tail -1 /etc/passwd  #显示文件最后一行内容

[root@1906 /]# head  /etc/passwd  #默认显示头10行
[root@1906 /]# tail  /etc/passwd  #默认显示尾10行

####################################################
• grep工具
– 用途:输出包含指定字符串的行
– 格式:grep  '字符串'     目标文件

[root@1906 /]# grep  root  /etc/passwd

[root@1906 /]# grep lisi  /etc/passwd

[root@1906 /]# grep sbin  /etc/passwd

###################################################

date 4

文本编辑器vim

  vim具备创建文本文件功能,不能创建目录

三个模式:
     命令模式      插入模式(编辑模式  输入模式)     末行模式

[root@1906 /]# vim /opt/haxi.txt

        	命----------i 键--------->插入模式(Esc返回到命令模式)
		令
		模
		式----------:  键--------->末行模式(Esc返回到命令模式)

     末行模式     :wq  保存并退出
     末行模式     :q!  强制不保存并退出

##################################################
• 关机:poweroff
[root@svr7 ~]# poweroff

################################################# 3
如何编写命令行

– 用来实现某一类功能的指令或程序
    总结:执行Linux大多数命令,都要找到对应执行程序

– 命令的执行依赖于解释器(默认解释器:/bin/bash)

     用户----->解释器------>内核----->硬件

绿色:可以执行的程序

####################################################
• Linux命令的分类
– 内部命令:属于解释器的一部分
– 外部命令:解释器之外的其他程序

####################################################
命令行的一般格式                                         
• 基本用法
– 命令字      [选项]...     [参数1]       [参数2]...	
  
[root@1906 ~]# cat --help         #查看命令的帮助信息
[root@1906 ~]# cat   /etc/passwd
[root@1906 ~]# cat  -n  /etc/passwd    #显示行号
[root@1906 ~]# cat  -n  /etc/redhat-relese
[root@1906 ~]# cat  -n  /etc/shells
[root@1906 ~]# cat  -n  /etc/shadow

##################################################
快速编辑技巧
• Tab键自动补全
– 可补齐命令字、选项、参数、文件路径、软件名、服务名
]# if(tab)(tab)
]# ifco(tab)

]# cat /et(tab)/red(tab)
 
]# ls /etc/sysconfig/network-scripts/ifcfg-eth0 
]# ls /et(tab)/sysco(tab)/netw(tab)-(tab)/ifc(tab)-e(tab)



• 快捷键
– Ctrl + l:清空整个屏幕
– Ctrl + c:废弃当前编辑的命令行(结束正在运行的命令)
– Esc + . 或  Alt + .:粘贴上一个命令的参数

– Ctrl + u:清空至行首
– Ctrl + w:往回删除一个单词(以空格界定)

[root@1906 ~]# ls /etc/shells 
[root@1906 ~]# cat  ALT+.
[root@1906 ~]# cat -n  ALT+.

]# ls /etc/sysconfig/network-scripts/ifcfg-eth0 
]# cat -n ALT+.

#####################################################
mount挂载操作:让目录成为设备的访问点

1.系统光盘获得众多的软件包,安装软件包
2.系统中显示光盘内容

Windows:
   光盘文件------>光驱设备------->CD驱动器(访问点)

Linux:
   光盘文件------>光驱设备------->访问点(目录)
            /dev/cdrom

青色:快捷方式

1.图形将光盘文件放入到虚拟光驱设备
2.查看光驱设备
[root@1906 ~]# ls -l /dev/cdrom  #光驱快捷方式
[root@1906 ~]# ls /dev/sr0    #实际光驱设备

3.进行挂载                                         
• 使用mount命令
– 格式:mount 设备路径 挂载点目录
[root@1906 ~]# mkdir /dvd
[root@1906 ~]# ls /dvd/

[root@1906 ~]# mount  /dev/cdrom  /dvd
mount: /dev/sr0 写保护，将以只读方式挂载
[root@1906 ~]# ls /dvd/
[root@1906 ~]# ls /dvd/P(tab)

4.卸载
[root@1906 /]# umount /dvd/
[root@1906 /]# ls /dvd

[root@1906 /]# mkdir /nsd1906
[root@1906 /]# mount /dev/cdrom  /nsd1906/
mount: /dev/sr0 写保护，将以只读方式挂载
[root@1906 /]# ls /nsd1906/


常见的提示:
[root@1906 dvd]# pwd
[root@1906 dvd]# umount /dvd/
umount: /dvd：目标忙。

注意事项:
1.允许一个设备可以具备,多个不同的挂载点目录
2.不允许一个挂载点目录,有多个设备
3.建议挂点目录是一个自己创建的目录

##################################################
目录和文件管理

使用pwd、cd
• pwd — Print Working Directory
– 用途:查看当前工作目录

• cd — Change Directory
– 用途:切换工作目录
– 格式:cd  [目标文件夹位置]

	. 表示当前目录
	.. 表示父目录
	~:家目录
	~user表示用户user的家目录

  /root:管理员的家目录
  /home:存放所有普通用户的家目录

[root@1906 /]# cd ~root
[root@1906 ~]# pwd
/root
[root@1906 ~]# cd ~lisi
[root@1906 lisi]# pwd
/home/lisi
[root@1906 lisi]# useradd tom   #创建普通用户tom
[root@1906 lisi]# cd ~tom
[root@1906 tom]# pwd
/home/tom
[root@1906 tom]# 

• ls — List
– 格式:ls [选项]... [目录或文件名]

• 常用命令选项
– -l:以长格式显示,显示详细信息
– -A:包括名称以 . 开头的隐藏文档
– -d:显示目录本身(而不是内容)的属性
– -h:提供易读的容量单位(K、M等)

[root@1906 ~]# ls -l /etc/passwd
[root@1906 ~]# ls -l -h /etc/passwd

[root@1906 ~]# ls -lh /etc/passwd  #显示文件的详细属性

[root@1906 ~]# ls -l /boot/     #显示目录内容详细属性
[root@1906 ~]# ls -lh /boot/   

[root@1906 /]# ls -ld /        #显示目录本身的详细属性
[root@1906 /]# ls -ld /opt
[root@1906 /]# ls -ld /boot

[root@1906 /]# ls -A /root  #显示目录的所有内容,包括隐藏数据
[root@1906 /]# ls -A /boot
[root@1906 /]# 

#################################################
使用通配符

• 针对不确定的文档名称,以特殊字符表示
– *:任意多个任意字符
– ?:单个字符

[root@1906 /]# ls /boot/vm*  #在/boot目录显示vm开头的数据
[root@1906 /]# ls /dev/tty*  #显示tty开头的数据

[root@1906 /]# ls /etc/*tab    #以tab作为结尾的数据
[root@1906 /]# ls /etc/*.conf  #以.conf作为结尾的数据

[root@1906 /]# ls /dev/tty?
[root@1906 /]# ls /dev/tty??
[root@1906 /]# ls /dev/tty???

[root@1906 /]# ls /etc/??tab

• 针对不确定的文档名称,以特殊字符表示
– [a-z]:多个字符或连续范围中的一个,若无则忽略,不能超过10

– {a,min,xy}:多组不同的字符串,全匹配
[root@1906 /]# ls /dev/tty[3-8]
[root@1906 /]# ls /dev/tty[4-7]

[root@1906 /]# ls /dev/tty{1,21,60}
[root@1906 /]# ls /dev/tty{1,3,5,7,9}

###################################################
别名的定义:简化复杂的命令

• 查看已设置的别名
– alias [别名名称]

• 定义新的别名
– alias 别名名称= '实际执行的命令行'

• 取消已设置的别名
– unalias [别名名称]

[root@1906 /]# hostname             
1906.tedu.cn
[root@1906 /]# hn
bash: hn: 未找到命令...
[root@1906 /]# alias hn='hostname'   #定义别名

[root@1906 /]# alias   #显示当前系统有效别名
[root@1906 /]# hn      #运行hn执行成功

[root@1906 /]# unalias hn   #删除别名
[root@1906 /]# hn
bash: hn: 未找到命令...

###################################################

• mkdir — Make Directory
– 格式:mkdir [-p] [/路径/]目录名...
[root@1906 /]# mkdir -p /vod/movie/cartoon
#-p表示连父目录一起创建

[root@1906 /]# ls -R /vod

[root@1906 /]# mkdir /opt/nsd01
[root@1906 /]# ls /opt/

[root@1906 /]# mkdir -p /opt/aa/bb/cc/dd
[root@1906 /]# ls /opt/
[root@1906 /]# ls -R /opt/aa    #-R表示递归显示

查找文本内容
• 根据字符串模式提取文本行
– grep [选项] '匹配模式' 文本文件...

• 常用命令选项
– -v,取反匹配
– -i,忽略大小写

[root@1906 /]# grep root /etc/passwd
[root@1906 /]# grep -v root /etc/passwd  #取反查找

[root@1906 /]# grep ROOT /etc/passwd
[root@1906 /]# grep -i ROOT /etc/passwd  #忽略大小写

– ^word 以字符串word开头
– word$ 以字符串word结尾

[root@1906 /]# grep ^root  /etc/passwd  #以root开头
[root@1906 /]# grep bash$  /etc/passwd  #以bash结尾

####################################################
rm 删除
• rm — Remove
– 格式:rm [选项]... 文件或目录...

• 常用命令选项
– -r、-f:递归删除(含目录)、强制删除

[root@1906 /]# mkdir /opt/nsdtest
[root@1906 /]# touch /opt/1.txt
[root@1906 /]# touch /opt/2.txt
[root@1906 /]# ls /opt/
1.txt  2.txt  nsdtest
[root@1906 /]# rm -rf /opt/1.txt    #强制删除所有
[root@1906 /]# rm -rf /opt/2.txt 
[root@1906 /]# ls /opt/

[root@1906 /]# rm -rf /opt/nsdtest
[root@1906 /]# ls /opt/

###################################################
mv 移动/改名
• mv — Move
– 格式:mv [选项]... 原文件...   目标路径

[root@1906 /]# mkdir /opt/nsd        
[root@1906 /]# touch /opt/a.txt
[root@1906 /]# ls /opt/

[root@1906 /]# mv /opt/a.txt  /opt/nsd
[root@1906 /]# ls /opt/nsd
[root@1906 /]# ls /opt/

重命名:路径不变的移动
[root@1906 /]# mv /opt/nsd/  /opt/haha
[root@1906 /]# ls /opt/

[root@1906 /]# mv /opt/haha/ /opt/student
[root@1906 /]# ls /opt/

###################################################
cp 复制
• cp — Copy
– 格式:cp [选项]... 原文件...    目标路径

• 常用命令选项
– -r:递归,复制目录时必须有此选项

 /etc:存放系统配置文件
 /opt:用户可选择目录

[root@1906 /]# cp /etc/passwd  /opt/
[root@1906 /]# ls /opt/

[root@1906 /]# cp -r /home  /opt/
[root@1906 /]# ls /opt/

[root@1906 /]# cp -r /etc/fstab   /opt/
[root@1906 /]# ls /opt/

复制可以支持多个参数:永远把最后一个参数作为目标,其他的所有参数都作为源
]# cp  -r    /boot/    /etc/shadow     /etc/resolv.conf   /etc/hosts   /opt/

]# ls /opt/
复制经常与点连用:   . 表示当前路径
[root@1906 /]# cd /opt/
[root@1906 opt]# pwd
[root@1906 opt]# ls
[root@1906 opt]# cp /etc/shells   .   
[root@1906 opt]# ls

[root@1906 /]# cd /etc/sysconfig/network-scripts/
[root@1906 network-scripts]# pwd
[root@1906 network-scripts]# cp /etc/passwd  . 
[root@1906 network-scripts]# ls

复制出现重名:在本次操作临时取消别名
[root@1906 /]# ls /opt/

[root@1906 /]# cp -r /boot/  /opt/

[root@1906 /]# \cp -r /boot/  /opt/  #本次操作临时取消别名


复制:可以重新命名,目标路径下数据
[root@1906 /]# cp /etc/passwd  /opt/pa.txt
[root@1906 /]# ls /opt/

[root@1906 /]# cp -r /boot/  /opt/abc
[root@1906 /]# ls /opt/

以下两次复制有何不同?
]# rm -rf /opt/*            #删除/opt目录下所有内容
]# cp -r /home/  /opt/test  
    #将/home目录复制到/opt目录下重命名为test
]# cp -r /home/  /opt/test
    #将/home目录复制到/opt/test目录下
[root@1906 /]# ls /opt/
[root@1906 /]# ls /opt/test/
##################################################### 4

重定向输出操作:将前面的命令的输出,写入到文本文件
  >:覆盖重定向
  >>:追加重定向
[root@1906 ~]# ls --help  > /opt/ls.txt
[root@1906 ~]# ls /opt/
[root@1906 ~]# less /opt/ls.txt 

[root@1906 ~]# hostname
[root@1906 ~]# hostname > /opt/ls.txt 
[root@1906 ~]# cat /opt/ls.txt

[root@1906 ~]# hostname >> /opt/ls.txt
[root@1906 ~]# cat /opt/ls.txt

[root@1906 ~]# hostname >> /opt/ls.txt 
[root@1906 ~]# cat /opt/ls.txt

[root@1906 ~]# head  -2 /etc/passwd       
[root@1906 ~]# head  -2 /etc/passwd  >  /opt/ls.txt

[root@1906 ~]# cat /opt/ls.txt 

[root@1906 ~]# echo 123456

[root@1906 ~]# echo 123456 >> /opt/ls.txt  #非交互式
[root@1906 ~]# cat /opt/ls.txt

[root@1906 ~]# echo hello >> /opt/ls.txt  #非交互式
[root@1906 ~]# cat /opt/ls.txt

##################################################
 管道操作  |  : 
      将前面命令的输出,交由后面命令处理,作为后面命令的参数

  显示/etc/passwd的8至12行内容
[root@1906 ~]# head -12 /etc/passwd
[root@1906 ~]# head -12 /etc/passwd | tail -5
 
[root@1906 ~]# cat -n /etc/passwd 
[root@1906 ~]# cat -n /etc/passwd  |  head -12
[root@1906 ~]# cat -n /etc/passwd |  head -12  | tail -5

[root@1906 ~]# ifconfig | less
[root@1906 ~]# ifconfig | head -2

####################################################

管理用户和组   
  
   用户帐号:  1.登录系统    2.确认身份,实现权限控制
   组:方便管理用户

   唯一标识:  UID   GID

   组分类: 基本组(私有组)     附加组(从属组)
   一个用户至少属于一个组

[root@1906 ~]# useradd nsd01
              组:nsd01

              组: cw  js  xs

添加用户
用户基本信息存放在 /etc/passwd文件(系统级配置文件)
[root@1906 ~]# head -1 /etc/passwd
root:x:0:0:root:/root:/bin/bash
用户名:密码占位符:UID:基本组GID:描述信息:家目录:解释器程序

• 使用 useradd 命令
– useradd [选项]... 用户名

• 常用命令选项
– -u 用户id、-d 家目录路径、-s 登录解释器、-G 附加组

[root@1906 ~]# useradd -u 1500 nsd01   #创建用户指定UID
[root@1906 ~]# id nsd01

[root@1906 ~]# useradd nsd02
[root@1906 ~]# id nsd02         #查询nsd02用户基本的信息

[root@1906 ~]# ls /home/

]# useradd -d /opt/abc  nsd05    #创建用户指定家目录
]# ls /opt/

]# useradd -u 2000 -d /opt/aa  nsd08    
]# ls /opt/                                 


用户名:密码占位符:UID:基本组GID:描述信息:家目录:解释器程序

-s:指定解释器程序

 /sbin/nologin:禁止用户登录系统
[root@1906 ~]# useradd  -s /sbin/nologin  nsd13
[root@1906 ~]# id nsd13

[root@1906 ~]# grep nsd13  /etc/passwd

[root@1906 ~]# useradd  -s /sbin/nologin  nsd14
[root@1906 ~]# id nsd14

[root@1906 ~]# grep  nsd14  /etc/passwd

-G:指定附加组(从属组)
[root@1906 ~]# groupadd tedu   #创建组tedu

[root@1906 ~]# useradd nsd15
[root@1906 ~]# id nsd15

[root@1906 ~]# useradd -G tedu nsd16  #创建用户指定附加组
[root@1906 ~]# id nsd16

##################################################
设置登录密码
  复杂密码:   3/4原则  字母  数字  大小写  特殊符号


• 使用 passwd 命令

[root@1906 ~]# useradd nsd17
[root@1906 ~]# passwd nsd17
更改用户 nsd17 的密码 。
新的 密码：                  #输入新的密码
重新输入新的 密码：     #重新输入新的密码
passwd：所有的身份验证令牌已经成功更新
[root@1906 ~]# su - nsd17   #命令行临时切换身份   
[nsd17@1906 ~]$ passwd 
更改用户 nsd17 的密码 。
为 nsd17 更改 STRESS 密码。
（当前）UNIX 密码：              #输入旧的密码
新的 密码：
重新输入新的 密码：
passwd：所有的身份验证令牌已经成功更新。
[nsd17@1906 ~]$ exit   #回到root用户
非交互式设置密码

[root@1906 ~]# echo 123 | passwd --stdin nsd17

[root@1906 ~]# echo redhat | passwd --stdin nsd17

[root@1906 ~]# echo 123456 | passwd --stdin nsd17

###################################################
用户密码信息存放在 /etc/shadow 文件
[root@1906 ~]# grep nsd17 /etc/shadow
nsd17:$6$UJ1UmCDO$uxsebJRVxjfOTUngX3nfI21mYCrEYiiPZs6Q4FD5Op7kzEtF7f8
u49XSm8AVGqm6X4Ny/pULXIKngkDIo7pSS1:18079:0:99999:7:::

用户名:密码加密字符串:上一次修改密码的时间

          上一次修改密码的时间:1970-1-1~2019-7-2  经历的天数

####################################################
修改用户属性
• 使用 usermod 命令
– usermod [选项]... 用户名

• 常用命令选项
– -u 用户id、-d 家目录路径、-s 登录解释器
– -G 附加组

[root@1906 ~]# useradd nsd19
[root@1906 ~]# grep nsd19 /etc/passwd

]# usermod -u 2500  -G tedu   -s /sbin/nologin          -d   /mnt/abc   nsd19

[root@1906 ~]# grep nsd19 /etc/passwd
[root@1906 ~]# id nsd19

###################################################
删除用户
• 使用 userdel 命令
– userdel [-r] 用户名

   -r:连同家目录一并删除



[root@1906 ~]# userdel nsd01
[root@1906 ~]# id nsd01
[root@1906 ~]# ls /home/

[root@1906 ~]# userdel -r nsd02
[root@1906 ~]# id nsd02
[root@1906 ~]# ls /home/

####################################################
管理组账号
添加组
组基本信息存放在 /etc/group文件

• 使用 groupadd 命令
– groupadd [-g 组ID] 组名

[root@1906 ~]# groupadd tarena
[root@1906 ~]# grep tarena /etc/group
tarena:x:2010:
组名:组的密码占位符:组GID:组成员列表

[root@1906 ~]# useradd natasha
[root@1906 ~]# useradd dc
[root@1906 ~]# useradd harry
[root@1906 ~]# useradd jack

管理组成员
• 使用 gpasswd 命令
– gpasswd -a  用户名   组名
– gpasswd -d  用户名   组名

[root@1906 ~]# gpasswd -a natasha tarena     
[root@1906 ~]# grep tarena /etc/group

[root@1906 ~]# gpasswd -a dc tarena
[root@1906 ~]# grep tarena /etc/group

[root@1906 ~]# gpasswd -a jack tarena
[root@1906 ~]# grep tarena /etc/group

[root@1906 ~]# gpasswd -d dc tarena
[root@1906 ~]# grep tarena /etc/group

[root@1906 ~]# gpasswd -d natasha tarena
[root@1906 ~]# grep tarena /etc/group

####################################################
删除组
• 使用 groupdel 命令
– groupdel 组名


####################################################
案例1:配置用户和组账号
• 新建用户 alex,其用户ID为3456,密码是flectrag
[root@1906 ~]# useradd -u 3456 alex
[root@1906 ~]# echo flectrag  |  passwd --stdin alex
• 一个名为 adminuser 的组
[root@1906 ~]# groupadd adminuser
• 为 natasha 的用户其属于adminuser组,这个组是该用户的从属组
[root@1906 ~]# gpasswd -a natasha adminuser
[root@1906 ~]# id natasha
• 为 harry 的用户,其属于adminuser组,这个组是该用户的从属组
[root@1906 ~]# gpasswd -a harry adminuser
[root@1906 ~]# id harry
• 为 sarah的用户,其在系统中没有可交互的Shell
[root@1906 ~]# useradd -s /sbin/nologin sarah
• natasha 、harry、sarah 的密码都要设置为 flectrag
####################################################

tar备份与恢复

       1.整合分散的数据   2.减小空间占用

归档和压缩
• 归档的含义
– 将许多零散的文件整理为一个文件
– 文件总的大小基本不变

• 压缩的含义
– 按某种算法减小文件所占用空间的大小
– 恢复时按对应的逆向算法解压

常见的压缩格式及命令工具:
	.gz ---> gzip
	.bz2 ---> bzip2
	.xz ---> xz

• tar 集成备份工具
– -c:创建归档
– -x:释放归档
– -f:指定归档文件名称
– -z、-j、-J:调用 .gz、.bz2、.xz格式的工具进行处理
– -t:显示归档中的文件清单
– -C(大写):指定释放路径

制作tar包格式:
 tar  选项     /路径/压缩包的名字      /路径/被压缩的源数据 .....
]# tar -zcf  /opt/file.tar.gz    /home/   /etc/passwd 
]# ls /opt/
]# tar -jcf  /opt/abc.tar.bz2     /home/  /etc/passwd
]# ls /opt/
]# tar -Jcf  /opt/nsd.tar.xz      /home/  /etc/passwd
]# ls /opt/

解包格式:                                                                 
 tar  选项     /路径/压缩包的名字       释放的路径

]# tar -xf /opt/file.tar.gz   -C  /mnt/
]# ls /mnt/
]# ls /mnt/etc/
]# ls /mnt/home/

]# mkdir /test
]# tar -xf /opt/abc.tar.bz2   -C  /test
]# ls /test/

###################################################
案例2:创建一个备份包
使用 tar 工具完成以下备份任务:
– 创建一个名为 /root/backup.tar.bz2 的归档文件
– 其中包含 /usr/local 目录中的内容
– tar 归档必须使用 bzip2 进行压缩

]# tar -jcf /root/backup.tar.bz2   /usr/local/
]# ls /root/

]# tar -tf  /root/backup.tar.bz2    #查看tar包内容

##################################################
cron计划任务

cron任务概述
• 用途:按照设置的时间间隔为用户反复执行某一项固定的系统任务
• 软件包:cronie、crontabs
• 系统服务:crond

• 日志文件:/var/log/cron


管理计划任务策略
• 使用 crontab 命令
– 编辑:crontab -e [-u 用户名]
– 查看:crontab -l [-u 用户名]
– 清除:crontab -r [-u 用户名]


如何编写任务记录
• 配置格式可参考 /etc/crontab 文件
   分    时    日    月   周     任务命令行(绝对路径)
   *      *    *    *     *      #每分钟都执行

   30  23   *     *    *      #每天晚上11:30

   30  23   *     *    5      #每周的周五晚上11:30

   30  23   *     *    1,3,5      #每周的周五,周一,周三 晚上11:30
   30  23   *     *    1-5         #每周的周一至周五 晚上11:30
   1    */2   *   *      *          #每两个小时
  分   时    日   月      周
   1    8     1     *       2           #每周的周二或每月的一号

	*:匹配范围内任意时间
	,:分隔多个不连续的时间点
	-:指定连续时间范围
	/n:指定时间频率,每n ...


 利用root用户,每分钟记录当前系统时间,写入到/opt/time.txt
[root@1906 ~]# date    #显示系统时间

[root@1906 ~]# date >> /opt/time.txt
[root@1906 ~]# cat /opt/time.txt

[root@1906 ~]# crontab -e 
*  *  *  *  *    date >> /opt/time.txt

[root@1906 ~]# crontab -l -u root
*  *  *  *  *    date >> /opt/time.txt

################################################### 

date 5

教学环境介绍
• 每个学员机上有三台预先配置好的虚拟机
– server —— 作为练习用服务器
– desktop —— 作为练习用客户机
– classroom —— 提供网关/DNS/软件素材等资源


 优先虚拟机classroom开机

真机上使用rht-vmctl辅助工具
]# rht-vmctl reset classroom  //先重置资源服务器
]# rht-vmctl reset server
]# rht-vmctl reset desktop    //再重置答题虚拟机

###################################################
虚拟机server:  root用户密码为redhat       
    1.查看系统版本:RHEL7
    2.查看主机名:server0.example.com
    3.查看eth0网卡IP地址:172.25.0.11/24

虚拟机desktop:  root用户密码为redhat
    1.查看系统版本:RHEL7
    2.查看主机名:desktop0.example.com
    3.查看eth0网卡IP地址:172.25.0.10/24

###################################################
利用真机进行远程管理虚拟机

1.真机能够与虚拟机通信
[student@room9pc01 ~]$ ping 172.25.0.11

[student@room9pc01 ~]$ ping 172.25.0.10

2.远程管理命令: ssh  用户名@对方的IP地址
[student@room9pc01 ~]$ ssh  root@172.25.0.11

[student@room9pc01 ~]$ ssh  root@172.25.0.10
   ctrl + shift  + t :在一个窗口中,新开一个终端

    -X(大写)：远程管理时，开启对方的图形程序

[root@server0 ~]# exit
[student@room9pc01 ~]$ ssh -X root@172.25.0.11

[root@server0 ~]#　firefox  #火狐浏览器
[root@server0 ~]#　firewall-config  #防火墙工具


常见提示:dconf桌面服务报错,与远程管理无关
(process:30405): dconf-WARNING **: failed to commit changes to dconf: 无法连接：拒绝连接


补充:为真机设置永久别名    配置文件: ~/.bashrc
配置文件: ~/.bashrc  #每开一个新的终端生效      

[student@room9pc01 ~]$ vim  /home/student/.bashrc 
# .bashrc
alias  gos='ssh  -X  root@172.25.0.11'
alias  god='ssh  -X  root@172.25.0.10'

真机:开启一个新的终端验证
[student@room9pc01 ~]$ gos
[student@room9pc01 ~]$ god

####################################################
权限和归属

基本权限

基本权限的类别
• 访问方式(权限)
– 读取:允许查看内容-read   r 
– 写入:允许修改内容-write    w
– 可执行:允许运行和切换-execute  x

  对文本文件:
       r: cat  less  head  tail
       w: vim  >  >>
       x: Shell脚本

• 权限适用对象(归属)
– 所有者:拥有此文件/目录的用户-user  u
– 所属组:拥有此文件/目录的组-group  g
– 其他用户:除所有者、所属组以外的用户-other  o

       lisi   lisi组     a.txt


查看权限
• 使用 ls -l 命令
– ls -ld 文件或目录...

 以 d 开头为目录
 以 - 开头为文本文件
 以 l 开头为快捷方式

[root@server0 ~]# ls -l /etc/passwd

[root@server0 ~]# ls -ld /etc/

[root@server0 ~]# ls -l /etc/shadow

[root@server0 ~]# ls -ld /tmp

[root@server0 ~]# ls -ld /home/student

###################################################
• 使用 chmod 命令
– chmod [-R] 归属关系+-=权限类别 文档...
   [-R]:递归设置权限

[root@server0 ~]# mkdir /nsd01    
[root@server0 ~]# ls -ld /nsd01
[root@server0 ~]# chmod u-w /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod o=--- /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod g+w /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod ugo=rwx /nsd01
[root@server0 ~]# ls -ld /nsd01
[root@server0 ~]# chmod u=rwx,g=rx,o=rx /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# mkdir -p /opt/aa/bb/cc
[root@server0 ~]# ls -ld /opt/aa
[root@server0 ~]# ls -ld /opt/aa/bb
[root@server0 ~]# ls -ld /opt/aa/bb/cc/

[root@server0 ~]# chmod -R o=--- /opt/aa  #递归设置

[root@server0 ~]# ls -ld /opt/aa
[root@server0 ~]# ls -ld /opt/aa/bb
[root@server0 ~]# ls -ld /opt/aa/bb/cc/
################################################
Linux判定一个用户拥有的权限         匹配及停止
1.判断用户的身份                       所有者>所属组>其他人
2.查看相应权限位的权限

 1.严老师可以进入              1.所有人不可以进入 
 2.所有人不可以进入           2. 严老师可以进入


 Permission denied :权限不足

目录的r权限:能够 ls 浏览此目录内容
目录的w权限:能够执行rm/mv/cp/mkdir/touch更改目录内容的操作
目录的x权限:能够 cd 切换到此目录

以root用户新建/nsddir目录，在此目录下新建readme.txt文件
并进一步完成下列操作
 1）使用户lisi能够在此目录下创建子目录     su  -  lisi
     chmod o+w  /nsddir/
 2）使用户lisi不能够在此目录下创建子目录            
     chmod o-w  /nsddir/
 3）使用户lisi能够修改readme.txt文件内容
     chmod o+w  /nsddir/readme.txt
 4）调整此目录的权限，使所有用户都不能cd进入此目录
     chmod u-x,g-x,o-x  /nsddir/
 5）为此目录及其下所有文档设置权限 rwxr-x---
     chmod -R  u=rwx,g=rx,o=---  /nsddir/
　　　-R：递归设置权限，目录下及目录下所有

#################################################
设置文档归属
• 使用 chown 命令
– chown [-R] 属主 文档...
– chown [-R] :属组 文档...
– chown [-R] 属主:属组 文档...
[root@server0 ~]# mkdir /nsd03
[root@server0 ~]# ls -ld /nsd03
[root@server0 ~]# groupadd tedu
[root@server0 ~]# chown lisi:tedu /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# chown root /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# chown :lisi /nsd03
[root@server0 ~]# ls -ld /nsd03
################################################
利用root用户新建/nsd06目录，并进一步完成下列操作
1）将属主设为gelin01，属组设为tarena组              
[root@server0 /]# useradd gelin01
[root@server0 /]# useradd gelin02
[root@server0 /]# groupadd tarena
[root@server0 /]# chown gelin01:tarena  /nsd06
2）使用户gelin01对此目录具有rwx权限
      除属主与属组之外的人，对此目录无任何权限
[root@server0 /]# chmod o=--- /nsd06
3）使用户gelin02能进入、查看此目录内容
[root@server0 /]# gpasswd -a  gelin02  tarena
4）将gelin01加入tarena组, 将nsd06目录的权限设为rw-r-x---
      再测试gelin01用户能否进入此目录
[root@server0 /]# gpasswd -a  gelin01  tarena
[root@server0 /]# chmod u=rw,g=rx /nsd06

#################################################
设置权限,让lisi用户可以读取/etc/shadow文件内容,有几种办法?
   1.利用其他人:
        chmod  o+r  /etc/shadow      
   2.利用所属组:
        chown  :lisi /etc/shadow
        chmod  g+r  /etc/shadow
   3.利用所有者:
        chown  lisi  /etc/shadow
        chmod  u+r  /etc/shadow
   4.利用ACL策略
        setfacl  -m u:lisi:r  /etc/shadow

#################################################
附加权限(特殊权限)

Set GID
• 附加在属组的 x 位上
– 属组的权限标识会变为 s
– 适用于目录,Set GID可以使目录下新增的文档自动设
置与父目录相同的属组
– 自动继承父目录所属组身份

[root@server0 ~]# mkdir /nsd08
[root@server0 ~]# chown :tedu /nsd08
[root@server0 ~]# ls -ld /nsd08

[root@server0 ~]# mkdir /nsd08/abc01
[root@server0 ~]# ls -ld /nsd08/abc01

[root@server0 ~]# chmod g+s /nsd08/   #设置Set GID
[root@server0 ~]# ls -ld /nsd08/

[root@server0 ~]# mkdir /nsd08/abc02
[root@server0 ~]# ls -ld /nsd08/abc02

[root@server0 ~]# ls -ld /nsd08/abc01


 财务: caiwu组  
     /nsd09/20190703.txt
     /nsd09/20190704.txt
     /nsd09/20190705.txt
     /nsd09/20190706.txt
     /nsd09/20190707.txt

[root@server0 ~]# chown  :caiwu  /nsd09
[root@server0 ~]# chmod  g+s  /nsd09

#################################################
Set UID
• 附加在属主的 x 位上
– 属主的权限标识会变为 s
– 适用于可执行文件,Set UID可以让使用者具有文件属主的身份及部分权限

[root@server0 ~]# cp /usr/bin/mkdir /usr/bin/hahadir

[root@server0 ~]# chmod u+s /usr/bin/hahadir 
[root@server0 ~]# ls -l /usr/bin/hahadir
[root@server0 ~]# ls -l /usr/bin/mkdir 

[root@server0 ~]# su - lisi
[lisi@server0 ~]$ /usr/bin/mkdir  test
[lisi@server0 ~]$ ls -l
[lisi@server0 ~]$ /usr/bin/hahadir nsd
[lisi@server0 ~]$ ls -l
[lisi@server0 ~]$ exit

################################################
Sticky Bit
• 附加在其他人的 x 位上                    
– 其他人的权限标识会变为 t
– 适用于开放 w 权限的目录,可以阻止用户滥用 w 写入
权限(禁止操作别人的文档)

[root@server0 ~]# mkdir /public
[root@server0 ~]# chmod ugo=rwx /public
[root@server0 ~]# ls -ld /public

[root@server0 ~]# chmod o+t /public
[root@server0 ~]# ls -ld /public

#################################################
acl访问控制列表

acl策略的作用
• 文档归属的局限性
– 任何人只属于三种角色:属主、属组、其他人
– 无法实现更精细的控制

• acl访问策略
– 能够对个别用户、个别组设置独立的权限
– 大多数挂载的EXT3/4、XFS文件系统默认已支持


[root@server0 ~]# mkdir /nsd11
[root@server0 ~]# chmod o=--- /nsd11
[root@server0 ~]# ls -ld /nsd11

[root@server0 ~]# su - lisi
[lisi@server0 ~]$ cd /nsd11
-bash: cd: /nsd11: Permission denied
[lisi@server0 ~]$ exit

[root@server0 ~]# setfacl -m u:lisi:rx /nsd11
[root@server0 ~]# getfacl /nsd11   #专用于查看ACL策略
[root@server0 ~]# su - lisi
[lisi@server0 ~]$ cd /nsd11
[lisi@server0 nsd11]$ pwd
[lisi@server0 nsd11]$ exit

###############################################
使用 getfacl、setfacl 命令
– getfacl 文档...
– setfacl [-R] -m u:用户名:权限类别 文档...
– setfacl [-R] -m g:组名:权限类别 文档...
– setfacl [-R] -x u:用户名     文档...      #删除指定ACL

– setfacl [-R] -b 文档...       #清除所有ACL


]# mkdir /nsd14
]# setfacl -m u:lisi:rwx /nsd14
]# setfacl -m u:dc:rx /nsd14
]# setfacl -m u:genlin01:rwx  /nsd14
]# setfacl -m u:genlin02:---  /nsd14  #设置无任何权限
]# getfacl /nsd14

]# setfacl -x u:genlin02 /nsd14   #删除指定ACL策略
]# getfacl /nsd14

]# setfacl -x u:genlin01 /nsd14  #删除指定ACL策略
]# getfacl /nsd14

]# setfacl -b  /nsd14         #清除所有的ACL策略
]# getfacl /nsd14

################################################## 

 
##################################################

date 6


软件包管理                                         

1.从虚拟机classroom上获得软件包

虚拟机classroom已经搭建Web服务,共享光盘RHEL7.0所有内容

Web服务:提供一个页面内容的服务

真机访问测试: firefox classroom.example.com

 classroom.example.com/content/rhel7.0/x86_64/dvd/


下载软件包
• 使用wget下载工具
– wget 软件包的URL网址
– wget 软件包的URL网址  -O(大写) /目录路径/新文件名

真机的浏览器:  Ctrl + f 当前页面查找 vsftpd
http://classroom.example.com/content/rhel7.0/x86_64/dvd/Packages/


[root@server0 /]# cd /root
[root@server0 /]# wget  http://classroom.example.com/content/rhel7.0/x86_64/dvd/Packages/vsftpd-3.0.2-9.el7.x86_64.rpm

[root@server0 /]#  ls


• RPM Package Manager,RPM包管理器
– rpm -q 软件名...   #查询软件
– rpm -ivh 软件名-版本信息.rpm...    #安装软件
– rpm -e 软件名...  # 卸载软件
– rpm -ql 软件名    # 查询软件所有文件
– rpm -qc 软件名   # 查询软件配置文件
– rpm -e --nodeps 软件名    #卸载软件--nodeps忽略依赖关系

[root@server0 ~]# rpm -q vsftpd    #查询软件是否安装
未安装软件包 vsftpd 
[root@server0 ~]# rpm -q firefox
firefox-24.5.0-1.el7.x86_64
]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 

[root@server0 ~]# rpm -q vsftpd
[root@server0 ~]# rpm -e vsftpd    #卸载软件
[root@server0 ~]# rpm -q vsftpd

]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 
]# rpm -ql vsftpd  #查询已安装的软件,安装了那些内容






#################################################
了解内容:导入红帽签名信息
[root@server0 ~]# wget http://classroom.example.com/content/rhel7.0/x86_64/dvd/RPM-GPG-KEY-redhat-release

[root@server0 ~]# rpm --import /root/RPM-GPG-KEY-redhat-release 
[root@server0 ~]# rpm -e vsftpd
[root@server0 ~]# rpm -q vsftpd
未安装软件包 vsftpd 
[root@server0 ~]# rpm -i /root/vsftpd-3.0.2-9.el7.x86_64.rpm 

##############################################
常见的提示:
]# rpm -ivh /root/bind-chroot-9.9.4-14.el7.x86_64.rpm 

错误：依赖检测失败：
	bind = 32:9.9.4-14.el7 被 bind-chroot-32:9.9.4-14.el7.x86_64 需要

##############################################
Yum配置及使用,自动解决依赖关系安装软件   

服务:自动解决依赖关系安装软件

服务端:  1.众多的软件包  2.仓库数据文件  3.构建Web服务或FTP服务
                       光盘内容中
             总结:构建Web服务或FTP服务,共享光盘所有内容

    虚拟机classroom构建Web服务,共享光盘所有内容

客户端: 虚拟机server 书写一个配置文件,指定服务端位置
      – /etc/yum.repos.d/*.repo
           错误的文件会影响正确配置文件
[root@server0 ~]# rm -rf /etc/yum.repos.d/*
[root@server0 ~]# vim /etc/yum.repos.d/dc.repo
[haha]                     #仓库标识,随意写不能有特殊字符
name=rhel7.0 xixi hehe     #仓库描述信息
baseurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd/                #指定服务端位置
enabled=1                  #是否启用本文件配置
gpgcheck=0                 #是否检测红帽签名信息
[root@server0 ~]# yum repolist        #显示仓库信息
[root@server0 ~]# yum -y install sssd
[root@server0 ~]# yum -y install httpd
[root@server0 ~]# yum -y install gcc
[root@server0 ~]# yum -y install mariadb-server
[root@server0 ~]# yum -y install xeyes
[root@server0 ~]# xeyes
      yum 软件仓库搭建另外一种方法:
yum-config-manager --add http://classroom.example.com/content/rhel7.0/x86_64/dvd/
vim /etc/yum.conf 
    gpgcheck=0
  :wq
[root@server0 ~]# ls /etc/yum.repos.d/
classroom.example.com_content_rhel7.0_x86_64_dvd_.repo   



#################################################
yum的使用
[root@server0 ~]# yum info 软件名

[root@server0 ~]# yum info vsftpd   #查询软件介绍信息
[root@server0 ~]# yum info httpd
[root@server0 ~]# yum info firefox

[root@server0 ~]# yum remove 软件名
[root@server0 ~]# yum remove httpd   #卸载软件
[root@server0 ~]# yum remove gcc
清空Yum的缓存
[root@server0 ~]# yum clean all
已加载插件：langpacks
正在清理软件源： haha
Cleaning up everything
[root@server0 ~]# yum repolist
]#yum list | grep httpd    //列出软件httpd
]# yum provides  pxelinux.0   //查找产生 pxelinux.0 的软件   

################################################
案例2:升级Linux内核
1.下载新的内核软件包
[root@server0 ~]# wget  http://classroom.example.com/content/rhel7.0/x86_64/errata/Packages/kernel-3.10.0-123.1.2.el7.x86_64.rpm

[root@server0 ~]# ls
[root@server0 ~]# uname -r
3.10.0-123.el7.x86_64

[root@server0 ~]# rpm -ivh /root/kernel-3.10.0-123.1.2.el7.x86_64.rpm 

[root@server0 ~]# reboot 
################################################

分区规划及使用

  扇区默认大小  512字节

  容量单位:  EB
  1EB=1024*1024TB

一块硬盘的“艺术”之旅
• 识别硬盘 => 分区规划 => 格式化 => 挂载使用
   毛坯楼层 => 打隔断 => 装修 =>入驻
                                                                
一 识别硬盘
  sd:SCSI设备  hd:IDE设备    vd:虚拟设备
 
[root@server0 ~]# lsblk      #查看当前系统所有的硬盘信息
NAME    SIZE  TYPE MOUNTPOINT
vda      10G   disk 
└─vda1   10G  part /
vdb      10G   disk 


二   分区规划 
• MBR/msdos 分区模式
– 1~4个主分区,或者  3个主分区+1个扩展分区(n个逻辑分区)
– 最大支持容量为 2.2TB 的磁盘
– 扩展分区不能格式化
 /dev/sda1:第一块SCSI硬盘,第一个主分区        
 /dev/sda5:第一块SCSI硬盘,第1个逻辑分区

• 修改硬盘的分区表,分出两个主分区,大小都为2G
[root@server0 ~]# fdisk /dev/vdb 
  n 创建新的分区--->回车--->回车-->回车--->在last结束时 +2G
  p 查看分区表
  n 创建新的分区--->回车---->回车--->回车--->在last结束时 +2G
  d 删除分区
  w 保存并退出 
[root@server0 ~]# lsblk  
[root@server0 ~]# ls /dev/vdb[1-2]

三 格式化 :赋予空间文件系统的过程

  文件系统:存储数据的规则
 
  Windows: NTFS   FAT

  Linux: ext4(RHEL6)  xfs(RHEL7)

[root@server0 ~]# mkfs.ext4 /dev/vdb1  #格式化为ext4  
[root@server0 ~]# blkid /dev/vdb1   #查看文件系统类型

[root@server0 ~]# mkfs.xfs /dev/vdb2 #格式化为xfs
[root@server0 ~]# blkid /dev/vdb2   #查看文件系统类型

四 挂载使用
[root@server0 ~]# mkdir /mypart1
[root@server0 ~]# mount /dev/vdb1 /mypart1
[root@server0 ~]# df -h  #正在挂载的设备使用情况

[root@server0 ~]# mkdir /mypart2
[root@server0 ~]# mount /dev/vdb2 /mypart2
[root@server0 ~]# df -h

五 开机自动挂载 /etc/fstab
     设备路径      挂载点      类型     参数       备份标记     检测顺序

 vim命令模式    按o键进入插入模式       
[root@server0 ~]# vim /etc/fstab 
 设备路径      挂载点      类型     参数       备份标记     检测顺序
/dev/vdb1  /mypart1  ext4  defaults  0  0
/dev/vdb2  /mypart2  xfs   defaults  0  0

[root@server0 ~]# umount /mypart1
[root@server0 ~]# umount /mypart2
[root@server0 ~]# df -h
[root@server0 ~]# mount -a
   检测/etc/fstab开机自动挂载配置文件,格式是否正确
   检测/etc/fstab中,书写完成,但当前没有挂载的设备,进行挂载
[root@server0 ~]# df -h

#################################################
综合分区:
最终实现3个主分区均为2G 划分扩展分区,划分2个逻辑分区均为1G
[root@server0 ~]# fdisk /dev/vdb
   p 查看分区表
   n 创建主分区---->回车---->回车---->回车---->在last结束时 +2G
   p 查看分区表
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车   将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+1G
   n 创建逻辑分区----->起始回车------>结束+1G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# partprobe   #刷新分区表
[root@server0 ~]# lsblk 

##################################################
综合分区
图形添加一块100G的硬盘
分区要求:最终可以使用 7 个分区,分别都是10G
[root@server0 ~]# fdisk /dev/vdc
   p 查看分区表
   n 创建主分区---->回车---->回车---->回车---->在last结束时 +10G
         连续划分3个主分区
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车   将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+10G
   n 创建逻辑分区----->起始回车------>结束+10G
   n 创建逻辑分区----->起始回车------>结束+10G
   n 创建逻辑分区----->起始回车------>结束+10G
   p 查看分区表
   w 保存并退出

#############################################
总结:
1.识别硬盘   lsblk
2.分区规划   fdisk
3.分区表刷新  partprobe
4.格式化    mkfs.ext4   mkfs.xfs   blkid
5.挂载使用   mount     df  -h
6.开机自动挂载  /etc/fstab  mount   -a

#############################################
使用LDAP认证,实现网络用户认证,达到用户的集中管理
  
     网络用户:用户信息会放在网络中LDAP服务器
     本地用户:用户信息会放在/etc/passwd

正确:只要在/etc/passwd文件内容有的用户信息,本地都能识别
错误:本地都能识别的用户,信息都在/etc/passwd

LDAP服务器:虚拟机classroom

客户端:虚拟机server
1.安装sssd软件,与LDAP服务器沟通
[root@server0 /]# yum -y install sssd
[root@server0 /]# rpm -q sssd

2.安装authconfig-gtk图形的工具,进行配置客户端sssd软件
[root@server0 /]# yum -y install authconfig-gtk
[root@server0 /]# authconfig-gtk

完全合格的主机名  www.baidu.com　　　www.qq.com    
               classroom.example.com

     选择LDAP
      dc=example,dc=com             #指定服务端域名
      classroom.example.com         #指定服务端主机名
     勾选TLS加密
      使用证书加密:
     http://classroom.example.com/pub/example-ca.crt

     选择LDAP密码 

3.重起服务
[root@server0 ~]# systemctl  restart  sssd   #重起服务
[root@server0 ~]# systemctl  enable  sssd    #设置开机自启动
[root@server0 ~]# grep ldapuser0 /etc/passwd
[root@server0 ~]# id ldapuser0     #验证LDAP用户信息
          
###################################################      
家目录漫游

    在LDAP服务器搭建共享,共享所有普通用户的家目录

  LDAP服务器:虚拟机classroom

  虚拟机classroom已经完成共享所有操作

 虚拟机server:访问共享数据
[root@server0 ~]# mkdir /haha
[root@server0 ~]# ls /haha
[root@server0 ~]# showmount -e classroom.example.com
Export list for classroom.example.com:
/home/guests 172.25.0.0/255.255.0.0

[root@server0 ~]# mount classroom.example.com:/home/guests  /haha
[root@server0 ~]# df -h

[root@server0 ~]# mkdir /home/guests
[root@server0 ~]# mount classroom.example.com:/home/guests/   /home/guests
[root@server0 ~]# ls /home/guests

[root@server0 ~]# su - ldapuser0
上一次登录：三 4月 10 19:21:04 CST 2019pts/0 上
[ldapuser0@server0 ~]$ 

################################################


###################################################

date 7


综合分区:利用图形新添加一块80G硬盘
   最终有3个主分区，分别为10G、10G、10G           
   创建扩展分区 --->  两个逻辑分区，分别为10G、10G
[root@server0 ~]# fdisk  /dev/vdc
   p 查看分区表
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +10G
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +10G
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +10G
   p 查看分区表
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车   将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+10G
   n 创建逻辑分区----->起始回车------>结束+10G
   p 查看分区表
   w 保存并退出
#####################################################
LVM逻辑卷管理

LVM工作方式
• 在“分区 --> 格式化”中间增加的一个逻辑层
– 零散空闲存储 ---- 整合的虚拟磁盘 ---- 虚拟的分区

将众多的物理卷(PV),组合成卷组(VG),在从卷组中划分出逻辑卷(LV)
    砖--------->房子------->房间

  物理卷
  Physical Volume
  
  卷组
  Volume Group

  逻辑卷
  Logical Volume

#############################################

LVM管理工具集
功能 		    物理卷管理		卷组管理 		逻辑卷管理
Scan扫描 	    pvscan 		vgscan 		lvscan
Create创建   pvcreate 		vgcreate 	lvcreate
Display显示 pvdisplay 		vgdisplay 	lvdisplay
Remove删除   pvremove 		vgremove 	lvremove
Extend扩展    / 			vgextend 	lvextend

###################################################
一  制作逻辑卷    successfully 成功     
物理卷: pvcreate /dev/vdb /dev/vdc1
1.创建卷组
   格式:vgcreate   卷组名     设备路径.......
[root@server0 ~]# vgcreate systemvg  /dev/vdb /dev/vdc1
[root@server0 ~]# vgs   #查看卷组基本信息
[root@server0 ~]# pvs   #查看物理卷基本信息

2.创建逻辑卷
格式:lvcreate -n 逻辑卷名   -L 大小G   基于的卷组名
[root@server0 ~]# lvcreate -n vo -L 16G systemvg 
[root@server0 ~]# vgs    #查看卷组基本信息
[root@server0 ~]# lvs   #查看逻辑卷基本信息

3.逻辑卷的使用
[root@server0 ~]# ls /dev/systemvg/vo    #逻辑卷设备文件
[root@server0 ~]# ls -l /dev/systemvg/vo

[root@server0 ~]# mkfs.xfs /dev/systemvg/vo #格式化
[root@server0 ~]# blkid  /dev/systemvg/vo #查看设备文件系统
[root@server0 ~]# vim /etc/fstab 
/dev/systemvg/vo  /mylv   xfs 	defaults  0  0

[root@server0 ~]# mkdir  /mylv
[root@server0 ~]# mount  -a  #检测/etc/fstab是否书写正确
[root@server0 ~]# df  -h     #查看正在挂载的设备

##################################################
二  逻辑卷的扩大
1.卷组有足够的剩余空间
  1)直接扩展逻辑卷的空间
[root@server0 ~]# vgs
[root@server0 ~]# lvs
[root@server0 ~]# lvextend -L 18G /dev/systemvg/vo 
[root@server0 ~]# lvs
  2)文件系统的扩大(刷新文件系统)
     resize2fs:专用于ext4文件系统的刷新
     xfs_growfs:专用于xfs文件系统的刷新

[root@server0 ~]# df -h
[root@server0 ~]# xfs_growfs /dev/systemvg/vo 
[root@server0 ~]# df -h

2.卷组没有足够的剩余空间                       
  1)首先扩展卷组空间
  [root@server0 ~]# vgextend systemvg /dev/vdc2
   Physical volume "/dev/vdc2" successfully created
   Volume group "systemvg" successfully extended
  [root@server0 ~]# vgs
  2)直接扩展逻辑卷的空间
  [root@server0 ~]# lvs
  [root@server0 ~]# lvextend -L 25G /dev/systemvg/vo 
  [root@server0 ~]# lvs
  3)文件系统的扩大(刷新文件系统)
  [root@server0 ~]# df -h
  [root@server0 ~]# xfs_growfs /dev/systemvg/vo 
  [root@server0 ~]# df -h

##################################################
了解:逻辑卷也可以变小
     ext4支持变小   xfs不支持变小


卷组划分空间单位:PE  默认大小为4M

查看卷组详细信息:
[root@server0 ~]# vgdisplay systemvg 
  PE Size               4.00 MiB

请划分一个逻辑卷大小为250M,名字为lvredhat
]# vgchange  -s  1M  systemvg   #修改PE的大小
]# vgdisplay  systemvg   #查看卷组详细信息
]# lvcreate  -n  lvredhat  -L  250M  systemvg 

请划分一个逻辑卷大小为987个PE组成的逻辑卷,名字为lvtest
]# lvcreate -l 987 -n lvtest  systemvg
]# lvs

]# lvcreate -l 50 -n lvtest01  systemvg
]# lvs
#################################################
删除逻辑卷: 首先删除逻辑卷,然后在删除卷组,最后删除物理卷

    删除卷组前提:基于此卷组创建的逻辑卷全部删除

[root@server0 ~]# lvremove /dev/systemvg/vo 
  Logical volume systemvg/vo contains a filesystem in use.
[root@server0 ~]# umount /mylv/
[root@server0 ~]# lvremove /dev/systemvg/vo 
Do you really want to remove active logical volume vo? [y/n]: y
  Logical volume "vo" successfully removed
[root@server0 ~]# lvs

###################################################
find高级使用,递归式查找

– find [目录] [条件1] [-a|-o] [条件2] ...

– 常用条件表示:
	-type 类型(f文本文件、d目录、l快捷方式)
	-name "文档名称"
	-size +|-文件大小(k、M、G)
	-user 用户名
	-mtime 根据文件修改时间
################################################
	-type 类型(f文本文件、d目录、l快捷方式)

[root@server0 ~]# find /boot/ -type d   #查找是目录
[root@server0 ~]# find /boot/ -type l   #查找是快捷方式
/boot/grub/menu.lst
[root@server0 ~]# ls /boot/grub/menu.lst 
/boot/grub/menu.lst
[root@server0 ~]# ls -l /boot/grub/menu.lst

[root@server0 ~]# find /boot/ -type f  #查找是文件

[root@server0 ~]# find /root -type d
[root@server0 ~]# find /root -type f
[root@server0 ~]# find /root -type l

	-name  "文档名称"
[root@server0 ~]# find /etc/ -name "passwd" 

[root@server0 ~]# find /etc/  -name "*tab"
[root@server0 ~]# find /etc/  -name "*tab*"

[root@server0 ~]# find /etc/  -name "*.conf"


]# mkdir /root/nsd1907
]# touch /root/nsd01.txt
]# touch /root/nsd02.txt
]# ls /root/
]# find /root/ -name "nsd*"
]# find /root/ -name "nsd*"  -type f  #nsd开头,并且是文件
]# find /root/ -name "nsd*"  -type d  #nsd开头,并且是目录

###################################################
	-size +或- 文件大小(k、M、G)
[root@server0 ~]# find /boot/ -size +300k
[root@server0 ~]# find /boot/ -size +10M
[root@server0 ~]# find /boot/ -size -10M

	-user 用户名       #按照所有者进行查找
[root@server0 ~]# find /home/  -user student
[root@server0 ~]# find /    -user student  #查找整个系统

    /proc:不占用硬盘空间，占用内存的空间

###################################################
	-mtime 根据文件修改时间,都是过去时间
                     +10 ：10天之前                               
                     -10 ：最近10天之内

[root@server0 ~]# find /root/  -mtime +1000
[root@server0 ~]# find /root/  -mtime -5

[root@server0 ~]# date   #查看当前的系统时间
  
  三个月之前的数据：+90


###################################################
处理find查找的数据                                
 -exec:额外操作的开始
    \;   ：额外操作的结束
   {} :find每一个查询结果

]# find /etc/  -name "*tab" 
]# find /etc/  -name "*tab"   -exec cp -r  {}  /opt \;
]# ls /opt/

]# find /boot/ -size +10M
]# find /boot/ -size +10M   -exec cp -r  {}  /opt/ \;
]# ls /opt/

####################################################
案例4:查找并处理文件
• 使用find命令完成以下任务
– 找出所有用户 student 拥有的文件
– 把它们拷贝到 /root/findfiles/ 文件夹中

]# mkdir /root/findfiles
]# find /  -user student  -type  f  #所有者student且为文件

]# find /  -user student -type  f  -exec cp {}  /root/findfiles/   \;

]# ls -A /root/findfiles/

##################################################
grep 在文本文件内容中，过滤指定字符串

[root@server0 ~]# grep root /etc/passwd
[root@server0 ~]# grep ^root  /etc/passwd  #以root开头
[root@server0 ~]# grep root$  /etc/passwd  #以root结尾
[root@server0 ~]# grep bash$ /etc/passwd   #以bash结尾

    -i：忽略大小写
    -v：取反查找
[root@server0 ~]# grep ROOT /etc/passwd
[root@server0 ~]# grep -i ROOT /etc/passwd
[root@server0 ~]# grep -v root /etc/passwd

       ^$:匹配空行
[root@server0 ~]# cat     /etc/default/useradd 
[root@server0 ~]# grep ^$  /etc/default/useradd 

[root@server0 ~]# grep -v ^$  /etc/default/useradd 

      在Linux中大多数配置文件中以#开头的行为注释行

显示/etc/login.defs配置文件有效信息（去掉以#开头的注释行和空行）
]# grep -v ^#  /etc/login.defs 

]# grep -v ^#  /etc/login.defs  |  grep -v ^$ 

]# grep -v ^#  /etc/login.defs |  grep -v ^$   >  /opt/l.txt

]# cat /opt/l.txt

####################################################

NTP网络时间协议
• Network Time Protocol
– NTP服务器为客户机提供标准时间
– NTP客户机需要与NTP服务器保持沟通


NTP服务器：虚拟机classroom
NTP客户机：虚拟机server
1.安装chrony软件，沟通时间服务器
[root@server0 ~]# rpm -q chrony
chrony-1.29.1-1.el7.x86_64

2.配置文件:/etc/chrony.conf
[root@server0 ~]# vim  /etc/chrony.conf
 #server 0.rhel.pool.ntp.org iburst   #开头加#变成注释
 #server 1.rhel.pool.ntp.org iburst   #开头加#变成注释
 #server 2.rhel.pool.ntp.org iburst   #开头加#变成注释
 server classroom.example.com iburst  #指定服务端位置

3.重起程序（重起服务）
   程序名(服务名)：chronyd
   daemon
     英 [ˈdiːmən] 美 [ˈdiːmən]
     (古希腊神话中的)半神半人精灵(守护神)
]# systemctl restart chronyd     #重起
]# systemctl enable chronyd      #开机自启动

4.测试
]# date  -s  "年-月-日   时：分：秒"
]# date 
]# date -s "2008-10-1  11:11:11"
]# date

]# systemctl restart chronyd     #重起程序
]# date
]# date
]# date
####################################################

 
         ENGINEER

date 1

Shell脚本基础

   脚本:一个可以执行的文件,运行可以实现某种功能

   创建用户dc  =  useradd  dc

绿色:可执行程序
案例1:编写hello.sh脚本
[root@server0 ~]# vim /root/hello.sh
echo Hello World

[root@server0 ~]# chmod +x /root/hello.sh
[root@server0 ~]# /root/hello.sh  #绝对路径运行脚本


##################################################
规范Shell脚本的一般组成
• #! 环境声明,以下代码由谁进行翻译执行
• # 注释文本
• 可执行代码

##################################################
1)输出当前红帽系统的版本信息                        
2)输出当前使用的内核版本
3)输出当前系统的主机名
[root@server0 ~]# vim  /root/hello.sh
  #!/bin/bash
  echo  Hello  World
  cat  /etc/redhat-release
  uname  -r
  hostname
  ifconfig  |  head -2

[root@server0 ~]# /root/hello.sh
 
#################################################
重定向输出
      > :只收集前面命令的正确输出
     2>:只收集前面命令的错误输出
     &>:正确与错误都收集
     >&2:将命令的输出变成错误输出
[root@server0 ~]# echo 123 > /opt/1.txt
[root@server0 ~]# cat /opt/1.txt
[root@server0 ~]# cat /opt/1.txt  /a

[root@server0 ~]# cat /opt/1.txt /a > /opt/2.txt 
[root@server0 ~]# cat /opt/2.txt 

[root@server0 ~]# cat /opt/1.txt /a 2> /opt/2.txt
[root@server0 ~]# cat /opt/2.txt 
[root@server0 ~]# cat /opt/1.txt /a &> /opt/2.txt
[root@server0 ~]# cat /opt/2.txt 
###############################################

    单引号 ' ' : 取消所有特殊字符的意义,原样输出

[root@server0 ~]# echo '* | & ^ % ***'
[root@server0 ~]# echo ', !'
  
    反撇号 ` `或$( ) :将命令的输出,直接参与下一次命令的运行
[root@server0 ~]# date +%F
2019-07-06
[root@server0 ~]# cd /opt/
[root@server0 opt]# mkdir  nsd-`date +%F`
[root@server0 opt]# mkdir  abc-$(date +%F)
[root@server0 opt]# mkdir  $(hostname)-$(date +%F)
##############################################
案例:创建用户并且设置密码的脚本
  黑洞设备:/dev/null
[root@server0 /]# vim /root/user.sh
#!/bin/bash
useradd nsd04 &> /dev/null
echo '用户nsd04创建成功'
echo 123  |  passwd --stdin nsd04 &> /dev/null
echo '用户nsd04密码设置成功'

[root@server0 /]# chmod +x /root/user.sh
[root@server0 /]# /root/user.sh

 为了增强脚本适应环境的变化以及需求的变化所有使用变量

 变量:会变化的量   以不变的名称,存储可以变化的值
      类似与容器
  格式:   变量名=存储的值
[root@server0 /]# vim  /root/user.sh     
 #!/bin/bash
 a=tc
 useradd  $a  &> /dev/null
 echo  用户$a创建成功
 echo  123  |  passwd --stdin  $a  &> /dev/null
 echo  用户$a密码设置成功

 交互式在命令行传递参数给脚本的代码

  read -p  '屏幕提示信息'
           1.直接产生交互
           2.记录用户在键盘上所有输入
           3.将记录的内容交由变量储存
[root@server0 /]# vim /root/user.sh
 #!/bin/bash
 read  -p  '请输入您要创建的用户名:'    a
 useradd $a  &> /dev/null
 echo 用户$a创建成功
 echo 123  |  passwd --stdin $a &> /dev/null
 echo 用户$a密码设置成功
#################################################
vim错误解决:产生交换文件(缓存文件)

]# vim /opt/4.txt 

]# rm -rf /opt/.4.txt.swp  #删除交换文件 

###############################################
定义/赋值变量
• 设置变量时的注意事项
– 等号两边不要有空格
– 变量名只能由字母/数字/下划线组成,区分大小写
– 变量名不能以数字开头,不要使用关键字和特殊字符
– 若指定的变量名已存在,相当于为此变量重新赋值

• 基本格式
– 引用变量值:$变量名
– 查看变量值:echo $变量名、echo ${变量名}
[root@server0 ~]# a=rhel
[root@server0 ~]# echo $a
rhel
[root@server0 ~]# echo ${a}
rhel
[root@server0 ~]# echo $a7

[root@server0 ~]# echo ${a}7
rhel7
[root@server0 ~]# b=7
[root@server0 ~]# echo ${a}${b}
                    # unset a
                    # unset b    删除变量
################################################
环境变量 :变量名大写   由系统定义并且赋值完成

   USER=当前登录的用户身份
[root@server0 ~]# echo $USER
root
[root@server0 ~]# su - student
[student@server0 ~]$ echo $USER
student
[student@server0 ~]$ exit
logout
[root@server0 ~]# su - dc
[dc@server0 ~]$ echo $USER
dc
[dc@server0 ~]$ exit
logout
[root@server0 ~]#
###############################################
位置变量:由系统定义并且赋值完成

 非交互式 在命令行传递参数给脚本的代码

[root@server0 ~]# vim /root/1.sh
#!/bin/bash
echo $1
echo $2
echo $3
[root@server0 ~]# /root/1.sh  haha  tom  dcc

[root@server0 ~]# vim /root/user.sh 
#!/bin/bash
useradd  $1  &> /dev/null
echo 用户$1创建成功
echo 123  |  passwd --stdin $1 &> /dev/null
echo 用户$1密码设置成功
[root@server0 ~]# /root/user.sh  jack

[root@server0 ~]# vim /root/2.sh
 #!/bin/bash
 cat  -n  $1  |  head  -$2

[root@server0 ~]# chmod +x /root/2.sh
[root@server0 ~]# /root/2.sh  /etc/passwd  3

###############################################
预定义变量:由系统定义并且赋值完成
 
    $# 已加载的位置变量的个数,判断用户是否输入命令行参数

[root@server0 ~]# vim /root/1.sh 
#!/bin/bash
echo $1
echo $2
echo $3
echo $#
                      
[root@server0 ~]# /root/1.sh haha  xixi  hehe  lele


    $? 程序退出后的状态值,0表示正常,其他值异常

##################################################
条件测试及选择

–  [   测试表达式   ]  　　　＃每一部分之间都要有空格


常用的测试选项
• 检查文件状态
  -e:存在及为真                                       
  -d:存在并且必须为目录  才为真
  -f:存在并且必须为文件  才为真
[root@server0 ~]# [ -e /aaa ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ -f /etc/passwd ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ -f /etc/ ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ -d /etc/ ]
[root@server0 ~]# echo $?
0

• 比较整数大小
  -gt:大于
  -ge:大于等于
  -eq:等于
  -ne:不等于
  -lt:小于
  -le:小于等于
[root@server0 ~]# [ 1 -eq 1 ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ 1 -ge  1 ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ 1 -gt  1 ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ 10 -le 12 ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# 

• 字符串比对
    ==:一致为真
    !=:不一致为真
[root@server0 ~]# [ student == redhat ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ $USER == root ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ student != redhat ]
[root@server0 ~]# echo $?
0

################################################
if双分支处理

	if  [条件测试];then
	   命令序列xx
	else
	   命令序列yy
	fi

[root@server0 ~]# vim  /root/if01.sh
#!/bin/bash
if  [  $1  -eq  1  ];then
  echo  hello
else
  echo  hi
fi
[root@server0 ~]#  /root/if01.sh  1
[root@server0 ~]#  /root/if01.sh  2

判断用户是否输入参数(位置变量)
[root@server0 ~]# vim  /root/if02.sh 
#!/bin/bash
if   [  $#  -eq  0  ];then
 echo 您没有输入参数
else
 echo 您输入了参数
fi
[root@server0 ~]# /root/if02.sh 
[root@server0 ~]# /root/if02.sh test

案例:利用read获取用户名进行判断   
  如果用户存在,则输出  用户已存在
  如果用户不存在,则输出  用户不存在
[root@server0 ~]# vim  /root/if03.sh
#!/bin/bash
read  -p  '请输入您要测试的用户名:'    a
id  $a  &> /dev/null
if  [  $?  -eq  0  ];then
  echo  用户$a已存在
else
  echo  用户$a不存在
fi
[root@server0 ~]# /root/if03.sh

#################################################
[root@server0 ~]# vim   /root/if04.sh   
#!/bin/bash
read -p  '请输入您要测试的IP地址:'     ip
ping  -c  2  $ip  &> /dev/null       #-c指定ping的次数
if  [  $?  -eq  0  ];then
 echo $ip可以通信
else
 echo $ip不可以通信
fi

[root@server0 ~]# /root/if04.sh 

##############################################
if多分支处理

	if [条件测试1];then
	   命令序列xx
	elif [条件测试2];then
	   命令序列yy
	else
	   命令序列zz
	fi

案例:利用read获取用户的成绩
  如果大于等于90,则输出  优秀
  如果大于等于80,则输出  良好
  如果大于等于70,则输出  一般
  如果大于等于60,则输出  合格
  以上均不满足,则输出  再牛的肖邦也弹不出哥的悲伤
[root@server0 ~]# vim  /root/if05.sh
#!/bin/bash
read  -p  '请输入您的成绩:'      num
if   [  $num  -ge  90  ];then
  echo  优秀
elif [  $num  -ge  80  ];then 
  echo  良好
elif [  $num  -ge  70  ];then
  echo  一般
elif [  $num  -ge  60  ];then
  echo  合格
else
  echo 再牛的肖邦也弹不出哥的悲伤
fi
##############################################
列表式循环,解决重复性的操作


    for  献血车   in  献血的队伍
	do
	    抽血
	done


[root@server0 ~]# vim  /root/for01.sh
#!/bin/bash
for  a  in zhangsan lisi  wangwu haha xixi
do
 echo $a
done

[root@server0 ~]# vim /root/for01.sh
#!/bin/bash
for  a  in zhangsan lisi  wangwu haha xixi
do
 useradd  $a  &> /dev/null
 echo  $a用户创建成功
done


#######################################
 列表值可以不参与,循环代码的执行
[root@server0 ~]# vim /root/for01.sh
#!/bin/bash
for  a  in zhangsan lisi  wangwu haha xixi
do
 echo I Love DC
done
 

造数工具:制造连续范围的数字   {起始值..结束值}
[root@server0 ~]# vim  /root/for01.sh
#!/bin/bash
for  a  in  {1..99}
do
 sleep 0.5           #暂停0.5秒
 echo I Love DC $a
done

[root@server0 ~]# /root/for01.sh

################################################
案例4:编写一个判断脚本
在 server0 上创建 /root/foo.sh 脚本
1)当运行/root/foo.sh redhat,输出为fedora
2)当运行/root/foo.sh fedora,输出为redhat
3)当没有任何参数或者参数不是 redhat 或者fedora时,
其错误输出产生以下信息: /root/foo.sh redhat|fedora

#######################################################

date 2
案例4:编写一个判断脚本
在 server0 上创建 /root/foo.sh 脚本
1)当运行/root/foo.sh redhat,输出为fedora
2)当运行/root/foo.sh fedora,输出为redhat
3)当没有任何参数或者参数不是 redhat 或者fedora时,
其错误输出产生以下信息: /root/foo.sh redhat|fedora

[root@server0 ~]# vim  /root/foo.sh
#!/bin/bash
# 判断$1参数的脚本
if [ $#  -eq  0 ];then       #判断用户是否输入参数
 echo '/root/foo.sh  redhat|fedora' >&2   #变成错误输出
 exit 3                     #脚本退出返回的状态值
elif [ $1 == redhat ];then  #判断是否为redhat
 echo fedora
elif [ $1 == fedora ];then  #判断是否为fedora
 echo redhat
else
 echo '/root/foo.sh  redhat|fedora' >&2  #变成错误输出
 exit 4   #脚本退出返回的状态值
fi

案例5:编写一个批量添加用户脚本
在 server0 上创建 /root/batchusers 脚本
1)此脚本要求提供用户名列表文件作为参数
2)如果没有提供参数,此脚本应该给出提示
 Usage: /root/batchusers,退出并返回相应值
3)如果提供一个不存在的文件,此脚本应该给出提
示 Input file not found,退出并返回相应值
4)新用户的登录Shell为 /bin/false,无需设置密码
5)用户列表测试文件:
 http://classroom/pub/materials/userlist

[root@server0 ~]# vim /root/userlist
duanwu
zhongqiu
zhsan
lisi
dc
[root@server0 ~]# vim  /root/batchusers 
#!/bin/bash
if  [ $# -eq 0 ];then                   #判断是否有参数
 echo  'Usage: /root/batchusers' >&2
 exit 2
elif [ -f  $1  ];then     #判断文件是否存在
 for  a  in $(cat $1)
 do
  useradd -s /bin/false  $a  &> /dev/null
  echo $a创建成功
 done
else
  echo 'Input file not found' >&2
  exit 3
fi
[root@server0 ~]# /root/batchusers  /root/userlist

###################################################
系统安全保护
SELinux安全机制
• Security-Enhanced Linux
– 美国NSA国家安全局主导开发,一套增强Linux系统安
全的强制访问控制体系
– 集成到Linux内核(2.6及以上)中运行
– RHEL7基于SELinux体系针对用户、进程、目录和文件
提供了预设的保护策略,以及管理工具

• SELinux的运行模式
– enforcing(强制)、permissive(宽松)
– disabled(彻底禁用)

 任何模式切换成disabled模式,都要经历重启

• 切换运行模式
– 临时切换:setenforce 1|0
– 固定配置:/etc/selinux/config 文件

虚拟机server0
[root@server0 ~]# getenforce      #查看当前的状态
[root@server0 ~]# setenforce  0   #临时修改为宽松模式 
[root@server0 ~]# getenforce 
[root@server0 ~]# vim /etc/selinux/config
SELinux=permissive

虚拟机desktop0
[root@desktop0 ~]# getenforce 
[root@desktop0 ~]# setenforce  0
[root@desktop0 ~]# getenforce 
[root@desktop0 ~]# vim /etc/selinux/config
SELinux=permissive

###############################################
配置用户环境  

alias别名设置
• 查看已设置的别名
– alias [别名名称]
• 定义新的别名
– alias 别名名称= '实际执行的命令行'
• 取消已设置的别名
– unalias [别名名称]


• 影响指定用户的 bash 解释环境
– ~/.bashrc,每次开启 bash 终端时生效
• 影响所有用户的 bash 解释环境
– /etc/bashrc,每次开启 bash 终端时生效

[root@server0 ~]# vim /root/.bashrc 
alias hello='echo hello'
[root@server0 ~]# vim  /home/student/.bashrc 
alias hi='echo hi'
[root@server0 ~]# vim /etc/bashrc 
alias dc='echo tc'

 新开一个终端验证
###############################################
虚拟机server0:搭建Web服务器

Web服务:提供网页内容

实现Web服务的软件:  httpd   Nginx   Tomcat
实现Web通信的协议: http(超文本传输协议)

1.安装httpd软件                                             
[root@server0 ~]# yum -y install httpd

2.重启程序(重启服务)
[root@server0 ~]# systemctl restart httpd

3.本机测试访问
[root@server0 ~]# firefox 172.25.0.11

4.书写自己的页面文件 
    默认存放路径:/var/www/html
    默认首页文件名称:index.html

[root@server0 ~]# vim /var/www/html/index.html
<marquee><font color=red><h1>NSD1906 haha
滚动            字体颜色            标题字体

[root@server0 ~]# firefox  172.25.0.11

##############################################
虚拟机server0:搭建FTP服务
FTP服务:传输数据
FTP协议:文件传输协议
实现FTP服务软件:vsftpd

 默认共享路径:/var/ftp

1.安装vsftpd软件
[root@server0 ~]# yum -y install vsftpd

2.重启程序(重启服务)
[root@server0 ~]# systemctl restart vsftpd
[root@server0 ~]# firefox ftp://172.25.0.11

#################################################
防火墙策略管理

    作用: 隔离  众多的策略,允许出站,严格控制入站

   硬件防火墙
   软件防火墙

firewalld服务基础
• 系统服务:firewalld
• 管理工具:firewall-cmd、firewall-config

[root@web100 ~]# yum -y install firewalld
[root@web100 ~]# systemctl start firewalld

##################################################
预设安全区域
• 根据所在的网络场所区分,预设保护规则集
– public:仅允许访问本机的ssh dhcp ping服务
– trusted:允许任何访问
– block:阻塞任何来访请求(明确拒绝,有回应客户端)
– drop:丢弃任何来访的数据包(没有回应,节省服务端资源)

根据数据包的源IP地址
  数据包: 源IP地址   目标IP地址  数据

防火墙判定原则:
1.查看数据包的源IP地址,然后查看自己所有的区域,那个区域中有该源IP地址的规则,则进入该区域

2.进入默认区域(public)
################################################
防火墙默认区域的修改
虚拟机server:
]# firewall-cmd --get-default-zone  #查看默认区域
虚拟机desktop:
]# ping 172.25.0.11  #可以通信,有回应
虚拟机server:
]# firewall-cmd --set-default-zone=block  #修改默认区域
]# firewall-cmd --get-default-zone 
虚拟机desktop:
]# ping 172.25.0.11  #不可以通信,有回应

虚拟机server:
]# firewall-cmd --set-default-zone=drop 
]# firewall-cmd --get-default-zone 
虚拟机desktop:
]# ping 172.25.0.11  #不可以通信,没有回应

################################################
互联网常见的协议:                                             
          http:超文本传输协议    默认端口:80
          https:安全的超文本传输协议     默认端口:443              
          DNS:域名解析协议  默认端口:53
          FTP:文件传输协议  默认端口:21
          tftp:简单的文件传输协议  默认端口:69
          telnet:远程管理协议(明文传输)  默认端口:23
          ssh:远程管理协议(加密传输)  默认端口:22
          SMTP:邮件协议(用户发邮件)  默认端口:25
          pop3:邮件协议(用户收邮件) 默认端口:110
          snmp:简单的网络管理协议 默认端口:161

防火墙区域添加允许的协议 
虚拟机server
]# firewall-cmd --set-default-zone=public  #修改默认区域 
]# firewall-cmd --zone=public --list-all  #查看区域规则
]# firewall-cmd --zone=public --add-service=ftp #添加协议
]# firewall-cmd --zone=public --add-service=http
]# firewall-cmd --zone=public --list-all

虚拟机desktop
[root@desktop0 ~]# firefox 172.25.0.11   #访问成功
[root@desktop0 ~]# firefox ftp://172.25.0.11  #访问成功
#####################################################
防火墙规则的永久设置
– 永久(permanent)
]# firewall-cmd  --reload    #重新加载防火墙所有配置
]# firewall-cmd --zone=public --list-all  #列出区域所有信息

]# firewall-cmd  --permanent  --zone=public --add-service=http
]# firewall-cmd  --permanent  --zone=public --add-service=ftp

]# firewall-cmd --zone=public --list-all   
]# firewall-cmd --reload 

]# firewall-cmd --zone=public --list-all 

###################################################
单独拒绝虚拟机desktop访问
虚拟机server:将虚拟机desktop的IP地址写入block
]# firewall-cmd --zone=block  --add-source=172.25.0.10
]# firewall-cmd --zone=block  --list-all

虚拟机desktop:
]# firefox 172.25.0.11        #访问失败
]# firefox ftp://172.25.0.11   #访问失败

真机:
]# firefox 172.25.0.11          #可以进行访问
]# firefox ftp://172.25.0.11   #可以进行访问
                                       
虚拟机server: 删除规则               
]# firewall-cmd --zone=block --remove-source=172.25.0.10

虚拟机desktop:
]# firefox 172.25.0.11        #可以进行访问
]# firefox ftp://172.25.0.11    #可以进行访问
#####################################################

 端口: 协议或程序或服务的编号
         利用root可以改变端口,而且一个程序可以具备多个端口

     监听端口    

实现本机的端口映射
• 本地应用的端口重定向(端口1 --> 端口2)

客户端访问: firefox  172.25.0.11:5423--->172.25.0.11:80

虚拟机server:
]# firewall-cmd --permanent  --zone=public  
--add-forward-port=port=5423:proto=tcp:toport=80

]# firewall-cmd --reload
]# firewall-cmd --zone=public --list-all 

虚拟机desktop:
[root@desktop0 ~]# firefox 172.25.0.11:5423





yum -y install iptables-services

iptables -L 列出所有规则
iptables -F 清除所有
iptables -D chain rulenum 清除某条
比如 INPUT 里有三条规则，那么
iptables -D INPUT 2
就会删掉第二条

iptable是一种网络防火墙，在LINUX下使用，RedHat9.0版本以上自带。它可以实现NAT转换，可以做上网代理。
停止防火墙 service iptables stop
启动防火墙 service iptables start
查看防火墙配置 iptables -L -n
修改的内容只是暂时保存在内存中，如果重启后还要生效，则要保存一下 service iptables save

iptables 选项
-A :指定链名
-p :指定协议类型
-d :指定目标地址
-dport :指定目标端口
-sport :指定源端口
-j :指定动作类型

添加input记录:  [root@web100 ~]# iptables -A INPUT -p tcp --dport 22 -j ACCEPT     //注意大写字母
执行完命令后 /etc/init.d/iptables save  -->这样这两条语句就保存到刚才那个/etc/sysconfig/iptables文件中了


###################################################


date 3
iSCSI网络磁盘

• Internet SCSI,网际SCSI接口    默认端口:3260
– 一种基于C/S架构的虚拟磁盘技术
– 服务器提供磁盘空间,客户机连接并当成本地磁盘使用

• backstore,后端存储
– 对应到服务端提供实际存储空间的设备,需要起一个管理名称
• target,磁盘组
– 是客户端的访问目标,作为一个框架,由多个lun组成
• lun,逻辑单元
– 每一个lun需要关联到某一个后端存储设备,在客户端
会视为一块虚拟硬盘

                  冰箱---->纸质包装       木质箱子

• ISCSI Qualified Name 名称规范(iqn)
– iqn.yyyy-mm.倒序域名:自定义标识
–  用来识别 target 磁盘组,也用来识别客户机身份
   


一  修改防火墙默认区域
虚拟机server
]# firewall-cmd --set-default-zone=trusted
虚拟机desktop
]# firewall-cmd --set-default-zone=trusted

二 划分一个5G的主分区
[root@server0 ~]# fdisk /dev/vdb
[root@server0 ~]# lsblk

虚拟机server服务端:
1.安装软件包targetcli
[root@server0 ~]# yum -y install targetcli

2.运行targetcli命令进行配置
[root@server0 ~]# targetcli
/> ls     #查看相关配置

    1)建立后端存储backstore,后端存储           
/> backstores/block create name=nsd dev=/dev/vdb1
/> ls

    2)建立target磁盘组
/> iscsi/ create  iqn.2019-07.com.example:server
/> ls

    3)进行lun关联
/> iscsi/iqn.2019-07.com.example:server/tpg1/luns      create /backstores/block/nsd 
/> ls
/> exit  #退出

    4)设置访问控制,客户端声称的名字,符合iqn名称规范
[root@server0 ~]# targetcli 
/> ls
/> iscsi/iqn.2019-07.com.example:server/tpg1/acls create iqn.2019-07.com.example:desktop

/> ls
   
    5)设置监听的IP地址
/> iscsi/iqn.2019-07.com.example:server/tpg1/portals  create ip_address=172.25.0.11 

/> ls
/> exit  #退出

三 重启服务(重启程序)
[root@server0 ~]# systemctl restart target
[root@server0 ~]# systemctl enable target  #设置为开机自启
ln -s '/usr/lib/systemd/system/target.service' '/etc/systemd/system/multi-user.target.wants/target.service'
####################################################

虚拟机desktop
1.安装软件包(客户端软件)
• 所需软件包:iscsi-initiator-utils
Yum仓库可以补全软件名:
    前提1:当前系统没有安装此软件
    前提2:必须具备Yum缓存  (yum repolist 可以直接生成缓存)

[root@desktop0 ~]# yum repolist
[root@desktop0 ~]# rpm -q  iscsi-initiator-utils
iscsi-initiator-utils-6.2.0.873-21.el7.x86_64

[root@desktop0 ~]# yum -y install iscsi(tab)
2.设置客户端生成的名字
[root@desktop0 ~]# vim /etc/iscsi/initiatorname.iscsi
InitiatorName=iqn.2019-07.com.example:desktop 

3.客户端刷新声称名字的服务
[root@desktop0 ~]# systemctl restart iscsid
  Warning: Unit file of iscsid.service changed on  
  disk, 'systemctl daemon-reload' recommended.
[root@desktop0 ~]# systemctl daemon-reload
[root@desktop0 ~]# systemctl restart iscsid

4.发现共享存储
  Linux查看命令帮助的方法 :  man  iscsiadm 
   全文查找/example   按n项下跳转匹配,看到EXAMPLES

   Ctrl    - ：减小字体
   Ctrl   Shift   + ：变大字体   

[root@desktop0 ~]# iscsiadm --mode discoverydb --type sendtargets --portal 172.25.0.11 --discover

方法二:发现iSCSI磁盘
– iscsiadm -m discovery -t st -p 服务器地址[:端口]

5.加载共享存储
[root@desktop0 ~]# systemctl restart iscsi
[root@desktop0 ~]# systemctl enable iscsi
[root@desktop0 ~]# lsblk 

6.永久挂载
 root@desktopX ~]# mkfs.ext4 /dev/sda1//按要求格式化分区
[root@desktopX ~]# mkdir /mnt/data//创建挂载点
[root@desktopX ~]# blkid /dev/sda1//找到分区 UUID
/dev/sda1: UUID="6ff20bb3-7543-4fa0-b4fa-bdc99a1e63ce" ..
[root@desktopX ~]# vim /etc/fstab
.. ..
UUID="6ff20bb3-7543-4fa0-b4fa-bdc99a1e63ce" /mnt/data ext4 _netdev 0 0


###################################################
数据库服务基础

什么是数据库: 存放数据的仓库

  数据库中有众多库,在每一个库中有众多的表格


• 常见的关系型 数据库管理系统
– 微软的 SQL Server
– IBM的 DB2
– 甲骨文的 Oracle、MySQL
– 社区开源版 MariaDB

 database:数据库

####################################################

虚拟机server:部署mariadb数据库服务器
• RHEL7 中的 MariaDB相关包
– mariadb-server :提供服务端有关的系统程序

[root@server0 ~]# systemctl restart mariadb
[root@server0 ~]# systemctl enable mariadb
ln -s '/usr/lib/systemd/system/mariadb.service' '/etc/systemd/system/multi-user.target.wants/mariadb.service'
[root@server0 ~]# 
####################################################
数据库的基本操作:
[root@server0 ~]# mysql    #进入数据库
MariaDB [(none)]> show databases;     #查看所有的库

MariaDB [(none)]> create database nsd;  #创建nsd库
MariaDB [(none)]> show databases;

MariaDB [(none)]> drop database nsd;  #删除nsd库
MariaDB [(none)]> show databases;

MariaDB [(none)]> create database nsd1906;  
MariaDB [(none)]> show databases;

MariaDB [(none)]> use mysql;    #切换到mysql库
MariaDB [mysql]> use nsd1906;
MariaDB [nsd1906]> use mysql;

MariaDB [mysql]> show tables;  #查看当前库中有哪些表格
MariaDB [mysql]> exit  #退出整个数据库
###################################################
在Linux命令行,为数据库管理员设置密码

数据库管理员为root,对数据库有最高权限用户,存放在mysql库user表
Linux系统管理员为root,对系统有最高权限用户,存放/etc/passwd

• 为数据库账号修改密码
– mysqladmin [-u用户名] [-p[旧密码]] password '新密码'

]# mysqladmin -u root   password  '123'  #首次设置密码

]# mysql -u root  -p    #交互式进入
Enter password: 

]# mysql -u root -p123  #非交互式进入
]# mysql -e "命令"    #-e 调用数据库里的命令

已知旧密码修改新密码
]# mysqladmin -u root -p123   password '456'
##################################################
MariaDB主配置文件:
[root@server0 ~]# ls /etc/my.cnf

##################################################
表格 : 增(insert)    删(delete)    改(update)     查(select)   

   表记录     表字段

           编号       姓名       联系方式          居住地址
        1      dc    138.....     东村
        2      tc    138.....     西村

• 导入/恢复到数据库

– mysql [-u用户名] [-p[密码]] 数据库名 < 备份文件.sql

[root@server0 ~]# wget http://classroom.example.com/pub/materials/users.sql
[root@server0 ~]# ls

]# mysql -u root -p123 nsd1906 < /root/users.sql 

]# mysql -u root -p123          #进入到数据库
MariaDB [(none)]> use nsd1906;  #切换到nsd1906库
MariaDB [nsd1906]> show tables; #显示所有表格
+-------------------+
| Tables_in_nsd1906 |
+-------------------+
| base              |
| location          |
+-------------------+
################################################
查(select)   
格式: select  表字段    from  库名.表名  where 条件 ;
]# mysql -u root -p123          #进入到数据库
> use nsd1906;   #切换到nsd1906库
> show tables;   #显示所有表格
> select * from  base;      #查看表所有字段及所有记录内容
> select * from  location;  #查看表所有字段及所有记录内容

> use mysql;
> select * from nsd1906.base;         

> use nsd1906;
> select id,name from base;
> select  *  from base where name='tom';
> select  *  from base where password='456';
> select  *  from base where id='3';

###################################################
查询表结构: desc 表名;
MariaDB [(none)]> use nsd1906;
MariaDB [nsd1906]> desc base;
+----------+--------
| Field    |
+----------+---------
| id       |     
| name     |    
| password |      
+----------+----------
MariaDB [nsd1906]> use mysql;
MariaDB [mysql]> desc user;
MariaDB [mysql]> select user,host,password from user;
####################################################
数据库授权
用户授权设置
• MariaDB [(none)]> 交互指令

– GRANT 权限列表  ON  数据库名.表名 TO 用户名@
客户机地址 IDENTIFIED BY '密码';

– 除了 root 用户,此nsd1906数据库只能被用户 lisi 查询,
此用户的密码为123

> grant select  on  nsd1906.*  to  lisi@localhost identified by '123';

当lisi从localhost本地登录,输入密码123,将会获得nsd1906库中所有表格的查询权限;

> select user,host,password from user;

####################################################

案例4:使用数据库查询
2. 在系统 server0 上使用数据库 nsd1906,并使用相
应的 SQL 查询以回答下列问题:
1)密码是 solicitous 的人的名字?
[root@server0 ~]# mysql -u root -p123
> use nsd1906;
> select * from base;
> select * from base where  password='solicitous';
> select name from base where  password='solicitous';

2)有多少人的姓名是 Barbara 同时居住在 Sunnyvale?   
> select * from  base,location
  where base.name='Barbara'  and  
  location.city='Sunnyvale'  and  base.id=location.id;

> select count(*) from  base,location
  where base.name='Barbara'  and  
  location.city='Sunnyvale'  and  base.id=location.id;

> insert base  values('6','Barbara','xixi');  #插入记录
> select * from  base;
> insert location  values('6','Sunnyvale');  #插入记录
> select * from  location;

##################################################
1. 禁止空密码root用户访问 mariadb 数据库
> use mysql;
> select user,host,password from user;
> select user,host,password from user where password='';

> delete from user  where  password='';   #删除记录
> select user,host,password  from  user;

> flush  privileges;    #刷新user表记录

验证登录失败:
[root@server0 ~]# mysql -u root -h server0.example.com 

###################################################

date 4
环境准备:防火墙设置
虚拟机server
]# firewall-cmd --set-default-zone=trusted 
虚拟机desktop
]# firewall-cmd --set-default-zone=trusted 
###################################################
配置NFS共享

NFS共享概述
• Network File System,网络文件系统
– 用途:为客户机提供共享使用的文件夹
– 协议:NFS(TCP/UDP 2049)、RPC(TCP/UDP 111)

• 所需软件包:nfs-utils
• 系统服务:nfs-server

虚拟机server:构建NFS服务
1.安装nfs-utils软件包
[root@server0 ~]# rpm -q nfs-utils
nfs-utils-1.3.0-0.el7.x86_64

2.配置共享
[root@server0 ~]# mkdir /nsd
[root@server0 ~]# echo 123 > /nsd/1.txt
[root@server0 ~]# ls /nsd/
[root@server0 ~]# vim /etc/exports
– 文件夹路径   客户机地址(权限) 客户机地址(权限) .. ..
   /nsd      *(ro)
   /opt      *(ro)

3.重启服务(重启程序)
[root@server0 ~]# systemctl restart rpcbind
[root@server0 ~]# systemctl eanble rpcbind
NFS使用的是随机端口，每次启动NFS都需要将自己的随机端口注册到rpcbind服务(rpcbind端口111)，这样客户端访问NFS时先到rpcbind查询端口信息，得到端口信息后再访问NFS服务。

[root@server0 ~]# systemctl restart nfs-server

虚拟机desktop:访问共享文件夹
1.挂载共享目录
]# mkdir /mnt/a  /mnt/b
]# showmount -e 172.25.0.11     #查看服务端共享内容
]# mount 172.25.0.11:/nsd /mnt/a/
]# df -h
]# ls  /mnt/a

]# mount 172.25.0.11:/opt/  /mnt/b
]# ls  /mnt/b
]# df -ah            #显示当前全部的挂载

2.开机自动挂载/etc/fstab              
    _netdev:声明网络设备
                     指明挂载本设备需要有网络参数再进行挂载

[root@desktop0 ~]# vim /etc/fstab 
 172.25.0.11:/nsd  /mnt/a  nfs defaults,_netdev 0 0
 172.25.0.11:/opt  /mnt/b  nfs defaults,_netdev 0 0

[root@desktop0 ~]# umount /mnt/a
[root@desktop0 ~]# umount /mnt/b
[root@desktop0 ~]# df -ah
[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -ah

rw 可读写的权限 
ro 只读的权限 
no_root_squash 登入NFS主机，使用该共享目录时相当于该目录的拥有者，如果是root的话，那么对于这个共享的目录来说，他就具有root的权 
               限，这个参数『极不安全』，不建议使用

root_squash 登入NFS主机，使用该共享目录时相当于该目录的拥有者。但是如果是以root身份使用这个共享目录的时候，那么这个使用者（root）
             的权限将被压缩成为匿名使用者，即通常他的UID与GID都会变成nobody那个身份

all_squash 不论登入NFS的使用者身份为何，他的身份都会被压缩成为匿名使用者，通常也就是nobody
anonuid 可以自行设定这个UID的值，这个UID必需要存在于你的/etc/passwd当中
anongid 同anonuid，但是变成groupID就是了 
sync 资料同步写入到内存与硬盘当中 
async 资料会先暂存于内存当中，而非直接写入硬盘 
insecure 允许从这台机器过来的非授权访问

/etc/exports 部分实例
1./tmp *(rw,no_root_squash) //*号表示所有的IP都可以访问

2./tmp *(rw)

   /home/public 192.168.0.*(rw) *(ro) //下面两行作用一样

   /home/public 192.168.0.0/24(rw) *(ro)

3./home/test 192.168.0.100(rw) //只对某部机器设置权限

4./home/linux *.linux.org(rw,all_squash,anonuid=40,anongid=40)当*.linux.org 登陆此NFS主机，并且在/home/linux下面写入文件时，该文件的所有人与所有组，就会变 
 成/etc/passwd里面对应的UID为40的那个身份的使用者了。

注意：修改了/etc/exports后，并不需要重启nfs服务，只要用exportfs重新扫描一次/etc/exports，并且重新加载即可
exportfs[-aruv] 
参数 含义 
a 全部挂载(或卸载)/etc/exports档案内的设定 
r 重新挂载/etc/exports 里面的设定，也同步的更新/etc/exports和/var/lib/nfs/xtab里面的内容 
u 卸载某一目录 
v 在export的时候，将分享的目录显示到荧屏上 
#exportfs -rv//重新export一次 
#exportfs -au//全部卸载 
举例
node1:~ # df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda2             9.6G  2.4G  7.2G  25% /
tmpfs                 126M  8.0K  126M   1% /dev/shm
172.16.12.89:/home/test
                      9.6G  2.4G  7.2G  26% /home/nfs
node2:~ # exportfs -av
exporting *:/home/test
node1:~ # umount /home/nfs/
node1:~ # df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda2             9.6G  2.4G  7.2G  25% /
tmpfs                 126M  8.0K  126M   1% /dev/shm

showmount命令 
语法:showmount [-aed] [hostname] 
-a:显示目前以及连上主机的client机器的使用目录的状态 
-e:显示hostname的/etc/exports里面共享的目录 
-d:只显示被client机器挂载的目录

NFS故障解决 
1、can't contactportmapper: RPC:Remotesystem error-Connection refused： 
   出现这个错误信息是由于SEVER端的PORTMAP没有启动。

2、mountclntudp_create: RPC: Programnotregistered：NFS没有启动起来，可以 
   用showmout-ehost命令来检查NFSSERVER是否正常启动起来。

3、mount: localhost:/home/test failed, reason given by server: Permission denied：
   这个提示是当client要mountnfsserver时可能出现的提示，意思是说本机没有权限去mount nfsserver上的目录。解决方法当然是去修改NFSSERVER咯。

4、被防火墙搞掉 
   这个原因很多人都忽视了，在有严格要求的网络环境中，我们一般会关闭linux上的所有端口，当需要使用哪个端口的时候才会去打开。而NFS默认是使用111端口，所以我们先 
   要检测是否打开了这个端口，另外也要检查TCP_Wrappers的设定。

   重新设置防火墙,包括iptables与TCP_Wrappers,因为激活了portmap，所以端口111必须提供出去.因此在iptablesrules中，要增加: 
   iptables-AINPUT-pTCP --dport111-jACCEPT 
   iptables-AINPUT-pUDP --dport111-jACCEPT 
   如果还不行，那就是TCP_Wrappers的问题，检查/etc/hosts.deny，如果有一行是: 
   ALL:ALL: deny 
   那就必须在/etc/hosts.allow中增加: 
   portmap:ALL:allow

注意：由于NFS使用的这个RPC在client端连上主机时，那么你的主机想要关机，那可就会成为『不可能的任务』。即如果你的Server上面还有Client在联机，那么你要关机，可能 
      得要等到数个钟头才能够正常的关机成功！所以，建议在NFSServer要关机之前，要先『关掉portmap与nfs』这两个东西。如果无法正确的将这两个daemons关掉，那么先以    
      netstat -utlp找出PID，然后kill掉。

NFS客户端设置
为了担心会不小心将NFS端挂进来的具有SUID权限档案的程序执行，root可以将NFS所分享的目录以较为安全的情况挂载进来，可以 
#mount-t nfs -o nosuid,ro hostname:/directory/mountponit

mountnfs的其它可选参数：
HARD:在后台，NFSCLIENT会不断的尝试与SERVER的连接，直到mount上
SOFT:会在前台尝试与SERVER的连接，是默认的连接方式。当收到错误信息后终止mount尝试，并给出相关信息。 
例如：mount-F nfs -o hard192.168.0.10:/nfs /nfs

timeo=n:设置超时时间，当数据传输遇到问题时，会根据这个参数尝试进行重新传输
intr 允许通知中断一个NFS调用。当服务器没有应答需要放弃的时候有用处。
retry=n：设定当网络传输出现故障的时候，尝试重新连接多少时间后不再尝试。默认的数值是10000minutes 
同时使用多个参数的方法：mount -t nfs -o timeo=3,udp,hard 192.168.0.30:/tmp/nfs

注意:NFS客户机和服务器的选项并不一定完全相同，而且有的时候会有冲突。比如说服务器以只读的方式导出，客户端却以可写的方式mount,虽然可以成功mount上，但尝 
     试写入的时候就会发生错误。一般服务器和客户端配置冲突的时候，会以服务器的配置为准。


 
###################################################
HTTP服务基础

Web服务:提供网页内容

• 基于 B/S (Browser/Server)架构的网页服务
– 服务端提供网页
– 浏览器下载并显示网页

• Hyper Text Markup Language(html),超文本标记语言
• Hyper Text Transfer Protocol(http),超文本传输协议

• 软件包:httpd(Apache组织)  #专门实现Web服务的软件

虚拟机server:
1.安装httpd软件
[root@server0 ~]# yum -y install httpd

2.重启服务
[root@server0 ~]# systemctl restart httpd

3.访问测试
[root@server0 ~]# firefox  172.25.0.11

4.书写页面文件
]# echo '<h1>NSD1906 Web' >  /var/www/html/index.html
]# cat  /var/www/html/index.html

]# firefox  172.25.0.11
#####################################################

主配置文件配置字段:
– Listen:监听地址:端口(80)
– ServerName:本站点注册的DNS名称(空缺)
– DocumentRoot:网页根目录(/var/www/html)
– DirectoryIndex:起始页/首页文件名(index.html)

   虚拟机classroom:
   DNS服务器的解析:将域名解析为IP地址
      server0.example.com----->172.25.0.11
      www0.example.com----->172.25.0.11
      webapp0.example.com----->172.25.0.11
 
[root@desktop0 ~]# nslookup webapp0.example.com
[root@desktop0 ~]# nslookup server0.example.com
[root@desktop0 ~]# nslookup www0.example.com
##################################################
– DocumentRoot:网页文件的根目录(/var/www/html)   
虚拟机server
]# mkdir /var/www/myweb
]# echo '<h1>wo shi myweb'  > /var/www/myweb/index.html
]# cat /var/www/myweb/index.html

]# vim /etc/httpd/conf/httpd.conf
 DocumentRoot "/var/www/myweb"  

]# systemctl restart httpd

虚拟机desktop:测试
[root@desktop0 ~]# firefox 172.25.0.11

#####################################################
网络路径与实际服务器路径    网页文件的根目录

客户端:firefox http://172.25.0.11:80---->服务端172.25.0.11
----->httpd 80----->DocumentRoot /var/www/myweb--->index.html

客户端: firefox 172.25.0.11
服务端: /var/www/myweb

客户端: firefox 172.25.0.11/abc
服务端: /var/www/myweb/abc/index.html

DocmentRoot  /var/www/myweb
客户端: firefox 172.25.0.11/var/www/myweb/abc
服务端: /var/www/myweb/var/www/myweb/abc


虚拟机server:
]# mkdir /var/www/myweb/abc
]# echo '<h1>wo shi abc' >    /var/www/myweb/abc/index.html

]# firefox  172.25.0.11/abc

  vsftpd----->/var/ftp
  httpd------>/var/www/html

####################################################
虚拟Web主机

• 虚拟Web主机
– 由同一台服务器提供多个不同的Web站点

• 区分方式
– 基于域名的虚拟主机
– 基于端口的虚拟主机
– 基于IP地址的虚拟主机

• 配置文件路径
– /etc/httpd/conf/httpd.conf   #主配置文件
– /etc/httpd/conf.d/*.conf     #调用配置文件

#####################################################

• 为每个虚拟站点添加配置
	<VirtualHost IP地址:端口>
	 ServerName  此站点的DNS名称
	 DocumentRoot  此站点的网页根目录
	</VirtualHost>


虚拟机server: vim命令模式下 u 可以撤销
]# vim /etc/httpd/conf.d/nsd01.conf   #建立调用配置文件
<VirtualHost *:80>               #启用虚拟Web主机功能
 ServerName server0.example.com  #指定网站DNS名称
 DocumentRoot /var/www/qq        #指定网页文件根目录
</VirtualHost>

<VirtualHost *:80>
 ServerName www0.example.com
 DocumentRoot /var/www/baidu
]# echo '<h1>baidu 百度'  >  /var/www/baidu/index.html
]# systemctl restart httpd

####################################################
虚拟Web主机优先级,由上到下依次匹配,匹配即停止

一旦使用虚拟Web主机功能,所有的网站都必须利用虚拟Web主机实现
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
 ServerName www0.example.com           
 DocumentRoot /var/www/baidu
</VirtualHost>
<VirtualHost *:80>
 ServerName server0.example.com
 DocumentRoot /var/www/qq
</VirtualHost>
<VirtualHost *:80>
 ServerName webapp0.example.com
 DocumentRoot /var/www/myweb
</VirtualHost>
[root@server0 ~]# systemctl restart httpd

##################################################
Web访问控制,针对存放网页文件的目录
   子目录默认继承父目录的Web访问控制   

<Directory />
    Require all denied   #拒绝所有人访问
</Directory>

<Directory "/var/www">
    Require all granted    #允许所有人访问
</Directory>

案例:自定义Web的网页文件根目录            
1.实现server0.example.com访问网页文件根目录修改为/webroot
]# vim /etc/httpd/conf.d/nsd01.conf 
<VirtualHost *:80>
 ServerName server0.example.com
 DocumentRoot /webroot
</VirtualHost>
]# mkdir /webroot
]# echo '<h1>wo shi webroot' > /webroot/index.html
2.修改访问控制
[root@server0 ~]# vim /etc/httpd/conf/httpd.conf 
[root@server0 ~]# vim /etc/httpd/conf.d/nsd02.conf
<Directory   "/webroot">    #针对/webroot路径
    Require all granted   #允许所有人访问
</Directory>
[root@server0 ~]# systemctl restart httpd

3.SELinux策略
[root@server0 ~]# setenforce 0
[root@server0 ~]# getenforce 
Permissive
[root@server0 ~]# vim /etc/selinux/config
SELINUX=permissive

[root@server0 ~]# firefox server0.example.com
###############################################


date 5
环境准备:防火墙设置
虚拟机server
]# firewall-cmd --set-default-zone=trusted 
虚拟机desktop
]# firewall-cmd --set-default-zone=trusted 
###################################################
案例:为虚拟机server配置以下虚拟Web主机
- 实现三个网站的部署
- 实现客户端访问server0.example.com网页内容为 卖女孩的小火柴
- 实现server0.example.com网页根目录为/var/www/abc01

- 实现客户端访问www0.example.com网页内容为  奔跑吧骆驼
- 实现www0.example.com网页根目录为/var/www/abc02

- 实现客户端访问webapp0.example.com网页内容为 20里春风不如你
- 实现webapp0.example.com网页根目录为/var/www/abc03

###################################################
文件夹权限
• 针对 DocumentRoot 网页目录的权限控制
– httpd 运行身份(用户/组):apache

客户机地址限制
• 使用 <Directory> 配置区段
– 每个文件夹自动继承其父目录的ACL访问权限
– 除非针对子目录有明确设置
<Directory 目录的绝对路径>
.. ..
Require all denied|granted
Require ip IP或网段地址 .. ..
</Directory>

案例1:配置网页内容访问
在 Web 网站 http://server0.example.com 的            
DocumentRoot 目录下创建一个名为 private 的子目录,要求如下:
1.创建目录
]# cat /etc/httpd/conf.d/nsd01.conf  #查看DocumentRoot
]# mkdir /var/www/abc01/private

2.从 http://classroom.example.com/pub/materials/private.html下载一个文件副本到这个目录,重命名为 index.html
不要对文件 index.html 的内容作任何修改
]# cd /var/www/abc01/private
]# wget http://classroom.example.com/pub/materials/private.html
]# mv private.html index.html
]# firefox server0.example.com/private

3)从虚拟机server0 上,任何人都可以浏览 private 的内容,
但是从其他系统不能访问这个目录的内容
[root@server0 /]# vim /etc/httpd/conf/httpd.conf
[root@server0 /]# vim /etc/httpd/conf.d/nsd02.conf
<Directory  "/var/www/abc01/private">
    Require ip 172.25.0.11    #仅允许172.25.0.11访问
</Directory>
[root@server0 /]# systemctl restart httpd

虚拟机desktop:
[root@desktop0 ~]# firefox server0.example.com/private
Forbidden

You don't have permission to access /private on this server.
####################################################
案例2:使用自定Web根目录
调整 Web 站点 http://server0.example.com 的网页目录,要求如下:
1)新建目录 /webroot,作为此站点新的网页目录
]# mkdir /webroot
]# echo '<h1> wo shi webroot' > /webroot/index.html
[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf
<VirtUalHost *:80>
  ServerName server0.example.com
  DocumentRoot /webroot
</VirtUalHost>

2)修改访问控制
[root@server0 /]# vim /etc/httpd/conf.d/nsd02.conf
<Directory  "/webroot">
    Require all granted   #允许所有人可以访问
</Directory>
[root@server0 /]# systemctl restart httpd

3)修改SELinux策略:安全上下文值(打标签) 布尔值策略 非默认端口开放
  神州旅游: 红色帽子                               
  达内旅游: 绿色帽子
]# semanage --help
]# semanage fcontext -l  |  less   #查看所有上下文值
]# ls -Zd /var/www/    #专查看目录上下文值
]# ls -Zd /webroot/
• 方式1:参照标准目录,重设新目录的属性
– chcon [-R] --reference=模板目录   新目录

]# chcon -R  --reference=/var/www  /webroot/
]# ls -Zd /webroot/
测试:
[root@desktop0 ~]# firefox server0.example.com
###################################################
部署动态网站

静态网站的运行
• 服务端的原始网页 = 浏览器访问到的网页
– 由Web服务软件处理所有请求
– 文本(txt/html)、图片(jpg/png)等静态资源


动态网站的运行
• 服务端的原始网页 ≠ 浏览器访问到的网页
– 由Web服务软件接受请求,动态程序转后端模块处理
– PHP网页、Python网页、JSP网页......

################################################
为站点 webapp0.example.com 配置提供动态Web内容,要求如下:
1.部署Python页面文件
]# cat /etc/httpd/conf.d/nsd01.conf  #查看DocumentRoot
]# cd /var/www/abc03
]# wget http://classroom.example.com/pub/materials/webinfo.wsgi

]#  ls

2.页面跳转(页面别名  地址重写)方便用户的访问

当用户访问 webapp0.example.com将webinfo.wsgi页面进行呈现

格式:  Alias  网络路径     实际路径 

     Alias   /     /var/www/abc03/webinfo.wsgi
当用户访问的时网页文件根目录时,跳转到/var/www/abc03/webinfo.wsgi

[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf 
<VirtUalHost *:80>
  ServerName webapp0.example.com
  DocumentRoot /var/www/abc03
  Alias  /   /var/www/abc03/webinfo.wsgi
当用户访问的是网页文件根目录时,跳转到/var/www/abc03/webinfo.wsgi
</VirtUalHost>
[root@server0 /]# systemctl restart httpd

[root@desktop0 ~]# firefox webapp0.example.com

3.翻译Python页面代码                          
[root@server0 /]# yum -y install mod_wsgi
[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf
<VirtUalHost *:80>
  ServerName webapp0.example.com
  DocumentRoot /var/www/abc03
  WsgiScriptAlias /  /var/www/abc03/webinfo.wsgi
</VirtUalHost>
[root@server0 /]# systemctl restart httpd

页面内容显示:
  UNIX时间戳:从1970-1-1 0:0:0到达现在时间,所经历的秒数
[root@desktop0 ~]# firefox webapp0.example.com

4.此虚拟Web主机侦听在端口8909
[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf
Listen 8909             #设置httpd程序监听8909端口
<VirtUalHost *:8909>     #设置虚拟Web主机监听8909端口
  ServerName webapp0.example.com
  DocumentRoot /var/www/abc03
  WsgiScriptAlias /  /var/www/abc03/webinfo.wsgi
</VirtUalHost>

]# semanage port -l  | grep http  #查看关于http开放的端口
]# semanage port -a -t http_port_t  -p tcp 8909
此命令会占用较多内存, -a 添加  -t 类型  -p 协议

]# systemctl restart httpd
测试验证: firefox webapp0.example.com:8909
总结:访问时端口优先级最高
####################################################
安全Web服务

PKI公钥基础设施
• Public Key Infrastructure,公钥基础设施
– 公钥:主要用来加密数据
– 私钥:主要用来解密数据(与相应的公钥匹配)
– 数字证书:证明拥有者的合法性/权威性(单位名称、
有效期、公钥、颁发机构及签名、......)
– Certificate Authority,数字证书授权中心:负责证书
的申请/审核/颁发/鉴定/撤销等管理工作


 数据证书授权中心:虚拟机classroom
#################################################
虚拟机server:
为站点 www0.example.com 配置安全加密的Web内容
1.部署网站证书(营业执照)
]# cd /etc/pki/tls/certs/
]# wget http://classroom.example.com/pub/tls/certs/server0.crt
]# ls

2.部署网站的根证书(工商局的信息)
]# cd /etc/pki/tls/certs/
]# wget http://classroom.example.com/pub/example-ca.crt
]# ls

3.部署解密数据的私钥
]# cd /etc/pki/tls/private/
]# wget http://classroom.example.com/pub/tls/private/server0.key
]# ls

4.安装可以进行加密支持的软件mod_ssl
[root@server0 /]# yum -y install mod_ssl
[root@server0 /]# vim /etc/httpd/conf.d/ssl.conf 
 补充:vim末行模式  输入set  nu 可以开启行号

 59 DocumentRoot "/var/www/abc02"
 60 ServerName www0.example.com:443
指定网站证书
100 SSLCertificateFile /etc/pki/tls/certs/server0.crt
指定解密的私钥
107 SSLCertificateKeyFile /etc/pki/tls/private/server0.key
指定网站的根证书
122 SSLCACertificateFile /etc/pki/tls/certs/example-ca.crt
[root@server0 /]# systemctl restart httpd
[root@server0 /]# firefox https://www0.example.com
    我已了解可能的风险--->添加例外---->确认安全例外
###################################################
补充:Samba共享服务(Windows与Linux跨平台的共享)

     smb(用户验证通信协议)  cifs(Samba独有文件系统) 

 程序名(服务名):smb

虚拟机server:
1.安装软件包
[root@server0 /]# yum -y install samba   

2.创建Samba共享帐号 
       1.建立在本地用户的基础上
       2.采用独立的密码,与用户登录系统的密码不同
[root@server0 /]# useradd harry
[root@server0 /]# pdbedit -a harry  #添加为samba帐号
new password:
retype new password:  
[root@server0 /]# pdbedit -L        #查看所有的samba帐号
[root@server0 /]# pdbedit -x harry  #删除samba帐号harry
[root@server0 /]# pdbedit -a harry

3.创建共享目录及配置共享
[root@server0 /]# mkdir /public
[root@server0 /]# echo haha > /public/1.txt
[root@server0 /]# vim /etc/samba/smb.conf 
 命令模式: G(大写) 到全文的末行
[nsd]              #设置共享名
path = /public     #设置实际共享的路径

[root@server0 /]# systemctl restart smb

4.修改SELinux策略: 布尔值策略(服务功能的开关)
[root@server0 /]# getsebool -a | grep samba
[root@server0 /]# setsebool samba_export_all_ro on
[root@server0 /]# getsebool -a | grep samba

客户端:虚拟机desktop0
1.安装软件包,支持cifs文件系统
[root@desktop0 ~]# yum -y install cifs-utils
2.进行挂载访问
]# mkdir /mnt/smb
格式:mount -o user=用户名,pass=密码  //服务器IP地址/共享名  挂载点目录
]# mount -o user=harry,pass=123  //172.25.0.11/nsd  /mnt/smb/
]# df -h
]# ls /mnt/smb/

3.开机自动挂载/etc/fstab

//172.25.0.11/nsd  /mnt/smb  cifs defaults,user=harry,pass=123,_netdev 0 0

[root@desktop0 ~]# umount /mnt/smb/
[root@desktop0 ~]# df -h
[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -h

###################################################

date 6
设置网络参数
一 设置永久的主机名,配置文件为/etc/hostname
[root@server0 ~]# echo 'nsd.tedu.cn' > /etc/hostname
[root@server0 ~]# cat /etc/hostname
nsd.tedu.cn
[root@server0 ~]# hostname
nsd.tedu.cn
[root@server0 ~]# exit
登出
Connection to 172.25.0.11 closed.
[student@room9pc01 ~]$ gos
Last login: Sat Jul 13 08:35:21 2019 from 172.25.0.250
[root@nsd ~]# 

二 永久设置设置IP地址 子网掩码  网关地址
1.查看识别的网卡名
[root@nsd ~]# nmcli connection show
名称                        
System eth0  

2.设置永久的IP地址 子网掩码  网关地址
]# nmcli connection modify 'System eth0' 
 ipv4.method manual 
 ipv4.addresses '172.25.0.110/24   172.25.0.254' 
 connection.autoconnect  yes

]# nmcli connection 修改  '网卡名' 
   ipv4.方法  手工设置
   ipv4.地址  'IP地址/子网掩码   网关地址'
     每次开机自动启用配置
   (ipv4.dns  地址)
   (ipv4.gateway 地址)  
3.激活配置
[root@nsd ~]# nmcli connection up 'System eth0'
[root@nsd ~]# ifconfig | head -2
[root@nsd ~]# route     #查看网关地址
   Gateway      
   172.25.0.254    

设置网关:
1. route  add default gw 192.168.4.254

2. ]#setip    // 交互式设置ip地址 和网关(Gateway)
Network name(eth0/eth1/eth2/eth3):eth1	
Set IP(IP/24):192.168.2.100/24
Set Gateway(default none):192.168.2.5
]# route -n      // 查看网关信息

3. ]# nmcli connection modify eth1 ipv4.method manual ipv4.gateway 192.168.2.254 connection.autoconnect yes
   ]# nmcli connection up eth1

删除 主机的网关:
[root@hosta ~]# route del default gw 192.168.2.10

三  DNS服务器的地址                               

     永久配置文件:/etc/resolv.conf

]# echo 'nameserver 172.25.254.254' > /etc/resolv.conf
 
]# cat /etc/resolv.conf
nameserver 172.25.254.254

]# nslookup  server0.example.com

##################################################
IPv6地址的组成
• IPv4 地址表示
– 32个二进制位,点分隔的十进制数
– 例如:172.25.0.11、127.0.0.1

• IPv6 地址表示
– 128个二进制位,冒号分隔的十六进制数
– 每段内连续的前置 0 可省略、连续的多个 : 可简化为 ::
– 例如:
       2003:ac18:0000:0000:0000:0000:0000:0305
       2003:ac18::305

[root@nsd ~]# nmcli connection modify 'System eth0' ipv6.method manual ipv6.addresses  2003:ac18::305/64 connection.autoconnect   yes

[root@nsd ~]# nmcli connection up 'System eth0'
successfully(成功)

[root@nsd ~]# ifconfig | head -4
[root@nsd ~]# ping6 2003:ac18::305

###################################################
聚合连接(链路聚合  网卡绑定)

   作用:实现网卡的高可用

                  eth1     eth2   
                        
                                  虚拟网卡:team0  192.168.1.1

1.生成虚拟的网卡team0     参考:man teamd.conf  
                                             全文搜索/example  按 n跳转匹配

]# nmcli connection add type team 
  con-name team0 ifname team0 autoconnect yes 
  config '{"runner": {"name": "activebackup"}}'

]# nmcli connection 添加  类型   组队
     配置文件名 team0  网卡名  team0 开机自动启用
     配置运行方式为  活跃备份方式

]# ifconfig  team0
]#nmcli device       #查看网卡的状态


2 .添加成员
]# nmcli connection add type team-slave 
con-name team0-1 ifname eth1 master team0

]# nmcli connection add type team-slave 
con-name team0-2 ifname eth2 master team0

]# nmcli connection 添加  类型  team-成员  
 配置文件名 team0-2  网卡名为  eth2  主设备  team0

3.team0配置IP地址
]# nmcli connection modify team0 
  ipv4.method manual ipv4.addresses 192.168.1.1/24  
  connection.autoconnect  yes

]# nmcli connection up team0 

]# teamdctl team0 state   #专用于查看team0信息
]# ifconfig eth2 down
]# teamdctl team0 state

如果有敲错,删除所有重新开始
]# nmcli connection delete team0    #删除配置文件
]# nmcli connection delete team0-1  #删除配置文件
]# nmcli connection delete team0-2  #删除配置文件

  man named.conf----->Team1
  man teamd.conf----->"runner"


##################################################
基础邮件服务
前提:修改IP地址,符合DNS解析结果
[root@nsd ~]# nmcli connection modify 'System eth0'  
  ipv4.method manual 
  ipv4.addresses  '172.25.0.11/24  172.25.0.254'  
  connection.autoconnect  yes

[root@nsd ~]# nmcli connection up 'System eth0'

查看DNS服务器地址:
[root@nsd ~]# cat /etc/resolv.conf 
nameserver 172.25.254.254
[root@nsd ~]# nslookup server0.example.com #测试解析

##################################################
电子邮件通信
• 电子邮件服务器的基本功能
– 为用户提供电子邮箱存储空间(用户名@邮件域名)
– 处理用户发出的邮件 —— 传递给收件服务器
– 处理用户收到的邮件 —— 投递到邮箱

DNS服务器:虚拟机classroom
     yg@qq.com
  
     yg@server0.example.com

###############################################
虚拟机server:构建邮件服务器
1.安装postfix软件,实现邮件服务
[root@nsd ~]# rpm -q postfix
postfix-2.10.1-6.el7.x86_64

2.修改配置文件
[root@nsd ~]# vim /etc/postfix/main.cf
 vim末行模式: set  nu 开启行号

 99 myorigin = server0.example.com  #默认补全的域名后缀
116 inet_interfaces = all  #在本机所有网卡启用邮件功能
164 mydestination = server0.example.com 
                                                     #判断为本域邮件的依据
3.重启邮件服务
[root@nsd ~]# systemctl restart postfix

使用mail命令发信/收信
• mail 发信操作
– mail  -s   '邮件标题'     -r   发件人     收件人
[root@nsd ~]# useradd yg
[root@nsd ~]# useradd xln
[root@nsd ~]# mail -s 'test01' -r  yg   xln
hahaxixihehelele
.
EOT
[root@nsd ~]# mail -u xln  #查看xln的邮件
>N  1 yg@server0.example.c  Sat Jul 13 14:2118/569   
& 1     #输入邮件编号1查看邮件内容

[root@nsd ~]# echo '123'  | mail -s 'abc' -r  yg  xln
[root@nsd ~]# mail -u xln 
##################################################
parted分区工具,进行GPT分区模式

  MBR分区模式: fdisk分区工具
       最多有4个主分区,划分3个主分区,1个扩展分区,n个逻辑分区
       最大的空间支持:2.2TB

  GPT分区模式:parted分区工具
        最多有128个主分区
        最大的空间支持:18EB
        1EB=1024PB
        1PB=1024TB

[root@nsd ~]# lsblk 
[root@nsd ~]# parted  /dev/vdb               
(parted) mktable  gpt      #指定分区模式gpt
(parted) print            #输出分区表信息
(parted) mkpart           #划分新的分区
 分区名称？  []? nsd           #随意起名字
 文件系统类型？  [ext2]? xfs    #随意写不起决定性作用
 起始点？ 0                             
 结束点？ 2G  
忽略/Ignore/放弃/Cancel? Ignore   #输入  i 忽略
(parted) unit GB      #使用GB作为单位显示
(parted) print  
(parted) mkpart 
 分区名称？  []? nsd  
 文件系统类型？  [ext2]? xfs
 起始点？ 2G          
 结束点？ 4G          
(parted) print 
                                                 
   parted /dev/vdb mklabel gpt"                 //指定用gpt模式划分磁盘
   parted /dev/vdb mkpart primary(范围) 1 50%    //第1个分区从第1M开始分到整个磁盘的50%
   parted /dev/vdb mkpart primary 50% 100%       //第2个分区从整个磁盘的50% 到100%
                  
###################################################



date 7
准备交换空间(虚拟内存)

缓解真实物理内存的压力
• 相当于虚拟内存,
– 当物理内存不够用时,使用磁盘空间来模拟内存
– 在一定程度上缓解内存不足的问题

一  利用fdisk进行分区,划分两个主分区分别为2G
[root@server0 ~]# fdisk /dev/vdb
[root@server0 ~]# lsblk 

二 格式化为交换文件系统
[root@server0 ~]# mkswap /dev/vdb1  #专业格式化交换文件系统
[root@server0 ~]# blkid /dev/vdb1   #查看文件系统类型

[root@server0 ~]# mkswap /dev/vdb2
[root@server0 ~]# blkid /dev/vdb2

三  启用交换分区
[root@server0 ~]# swapon /dev/vdb1  #启用交换分区
[root@server0 ~]# swapon /dev/vdb2
[root@server0 ~]# swapon  -s        #查看交换空间的成员信息

[root@server0 ~]# swapoff /dev/vdb1  #停用交换分区
[root@server0 ~]# swapon -s

[root@server0 ~]# swapoff /dev/vdb2
[root@server0 ~]# swapon -s

四 开机自动启用交换分区                            
[root@server0 ~]# vim /etc/fstab
/dev/vdb1  swap  swap defaults 0 0
/dev/vdb2  swap  swap defaults 0 0

[root@server0 ~]# swapoff /dev/vdb1
[root@server0 ~]# swapoff /dev/vdb2
[root@server0 ~]# swapon -s

[root@server0 ~]# swapon -a  #专门检测/etc/fstab交换分区
[root@server0 ~]# swapon -s

#################################################
补充内容:触发挂载(autofs)
准备工作:在划分一个2G的主分区
[root@server0 ~]# fdisk /dev/vdb

[root@server0 ~]# partprobe    #刷新分区表
[root@server0 ~]# lsblk
[root@server0 ~]# mkfs.xfs  /dev/vdb3   #格式化文件系统
[root@server0 ~]# blkid  /dev/vdb3

1.安装触发挂载的软件包
[root@server0 ~]# yum -y install autofs
2.重启autofs程序
[root@server0 ~]# systemctl restart autofs
[root@server0 ~]# systemctl enable autofs
ln -s '/usr/lib/systemd/system/autofs.service' '/etc/systemd/system/multi-user.target.wants/autofs.service'

3.完成对/dev/vdb3触发挂载的配置
  最终实现:访问路径/nsd/dc  挂载设备/dev/vdb3 到/nsd/dc
   
  主配置文件:定义监控目录/etc/auto.master
   格式:监控目录路径    挂载配置文件路径

  挂载配置文件:定义挂载点目录与设备  
 cd      -fstype=iso9660,ro,nosuid,nodev :/dev/cdrom
  挂载点目录    -fstype=文件系统    :挂载设备

[root@server0 /]# mkdir /nsd     #必须手动创建监控目录
[root@server0 /]# vim /etc/auto.master
       /nsd              /etc/test
        格式:监控目录路径       挂载配置文件路径

[root@server0 /]# cp /etc/auto.misc /etc/test 
[root@server0 /]# vim /etc/test    #修改挂载配置文件
  dc            -fstype=xfs      :/dev/vdb3
  格式: 挂载点目录    -fstype=文件系统    :挂载设备

[root@server0 /]# systemctl restart autofs
[root@server0 /]# systemctl status autofs #查看服务状态
[root@server0 /]# ls /nsd/dc
[root@server0 /]# df -h
#################################################
         

                Services

date 1
构建新的教学环境
1.构建两台虚拟机,操作系统为CentOS7.5
[student@room9pc01 ~]$ clone-vm7 
Enter VM number: 8
Creating Virtual Machine disk image......	[OK]
Defining new virtual machine......	[OK]
[student@room9pc01 ~]$ clone-vm7 
Enter VM number: 9
Creating Virtual Machine disk image......	[OK]
Defining new virtual machine......	[OK]

#修改两台虚拟机名为A与B

2.利用root进入两台虚拟机,密码为:123456

3.配置永久主机名                                         
    虚拟机A:svr7.tedu.cn
    虚拟机B:pc207.tedu.cn

4.配置IP地址
    虚拟机A:为eth0配置 192.168.4.7/24
    虚拟机B:为eth0配置 192.168.4.207/24

5.利用真机进行远程管理两台虚拟机
[student@room9pc01 ~]$ ping 192.168.4.7
[student@room9pc01 ~]$ ping 192.168.4.207

[student@room9pc01 ~]$ ssh -X root@192.168.4.7
[student@room9pc01 ~]$ ssh -X root@192.168.4.207

6.为真机上设置永久别名
[student@room9pc01 ~]$ vim /home/student/.bashrc 
 alias goa='ssh  -X  root@192.168.4.7'
 alias gob='ssh  -X  root@192.168.4.207'

 新开一个终端验证

7.构建Yum仓库

服务端:真机构建FTP服务器,共享光盘所有内容
 1)真机检测软件包vsftpd的安装
 [student@room9pc01 ~]$ rpm -q vsftpd
 vsftpd-3.0.2-22.el7.x86_64
 [student@room9pc01 ~]$ systemctl status vsftpd
 2)共享光盘所有内容
    默认共享的路径:/var/ftp
 ]$ mkdir /var/ftp/centos-1804/
 ]$ mount /iso/CentOS7-1804.iso   /var/ftp/centos-1804/
 ]$ ls /var/ftp/centos-1804/
 ]$ vim /etc/fstab 
/var/lib/libvirt/images/iso/CentOS7-1804.iso  /var/ftp/centos-1804 iso9660 defaults 0 0
 ]$ firefox ftp://192.168.4.254/centos-1804

客户端:两台虚拟机
[root@svr7 ~]# vim /etc/yum.repos.d/local.repo
[local_repo]
name=CentOS-$releasever - Base
baseurl="ftp://192.168.4.254/centos-1804"
enabled=1
gpgcheck=0
[root@svr7 ~]# yum -y install httpd

#####################################################
虚拟机C
 1.配置主机名为:svr10.tedu.cn
 2.配置eth0的IP地址:192.168.4.10/24
 3.配置Yum仓库,指向服务端为真机的FTP服务

虚拟机D
 1.配置主机名为:pc20.tedu.cn
 2.配置eth0的IP地址:192.168.4.20/24
 3.配置Yum仓库,指向服务端为真机的FTP服务

##################################################
扩展的几个应用
目录结构
• 认识Linux的目录层次:               
– man hier

• 常见一级目录的用途
	/boot 存放系统引导必需的文件,包括内核、启动配置
	/bin、/sbin 存放各种命令程序
	/dev 存放硬盘、键盘、鼠标、光驱等各种设备文件
	/etc 存放Linux系统及各种程序的配置文件
	/root、/home/用户名 分别是管理员root、普通用户的默认家目录
	/var 存放日志文件、邮箱目录等经常变化的文件
	/proc 存放内存中的映射数据,不占用磁盘
	/tmp 存放系统运行过程中使用的一些临时文件
[root@svr7 ~]# ls -ld /tmp
drwxrwxrwt. 8 root root 172 7月  15 10:34 /tmp

权限的数值表示
• 权限的数值化
– 基本权限:r = 4,w = 2,x = 1
– 附加权限:SUID = 4,SGID = 2,Sticky Bit = 1 

[root@svr7 ~]# mkdir /nsd01
[root@svr7 ~]# ls -ld /nsd01
[root@svr7 ~]# chmod 750 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 700 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 007 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 755 /nsd01
[root@svr7 ~]# ls -ld /nsd01


历史命令
• 管理/调用曾经执行过的命令
– history:查看历史命令列表
– history -c:清空历史命令
– !n:执行命令历史中的第n条命令
– !str:执行最近一次以str开头的历史命令

• 调整历史命令的数量
[root@svr7 ~]# vim /etc/profile
HISTSIZE=1000  //默认记录1000条

[root@svr7 ~]# history        #显示历史命令列表
[root@svr7 ~]# history -c     #清空所有的历史命令
[root@svr7 ~]# history 
    1  history 
[root@svr7 ~]# cat -n /etc/redhat-release  
[root@svr7 ~]# ls /root/
[root@svr7 ~]# cat /etc/hosts

[root@svr7 ~]# history 
[root@svr7 ~]# !cat    #执行临时命令中最近以cat开头的命令
[root@svr7 ~]# !ls


实用小命令工具
• du,统计文件的占用空间
– du [选项]... [目录或文件]...
– -s:只统计每个参数所占用的总空间大小
– -h:提供易读容量单位(K、M等)

[root@svr7 ~]# du   -sh  /root
[root@svr7 ~]# du   -sh  /root/  /etc/  /boot/
[root@svr7 ~]# du   -sh  /

[root@svr7 ~]# du   -sh  /var

[root@svr7 ~]# du   -sh  /home
[root@svr7 ~]# du   -sh  /tmp


• date,查看/调整系统日期时间
– date +%F、date +%R
– date +"%Y-%m-%d %H:%M:%S"
– date -s "yyyy-mm-dd HH:MM:SS"

[root@svr7 ~]# date +%F   #显示  年-月-日
2019-07-15
[root@svr7 ~]# date +%Y   #显示 年
2019
[root@svr7 ~]# date +%m   #显示 月
07
[root@svr7 ~]# date +%d   #显示 日期
15
[root@svr7 ~]# date +%H   #显示 时
11
[root@svr7 ~]# date +%M   #显示 分
42
[root@svr7 ~]# date +%S   #显示 秒
####################################################

制作快捷方式    制作连接(链接)文件

制作软连接
格式: ln  -s  /路径/源文件   /路径/快捷方式名     #必须时绝对路径

]# cat /etc/sysconfig/network-scripts/ifcfg-eth0
]# ln -s /etc/sysconfig/network-scripts/ifcfg-eth0   /etc/net0

]# ls /etc/net0 
]# cat /etc/net0
]# ls -l /etc/net0

]# ln -s /etc/passwd  /opt/
]# ls /opt/
]# ls -l /opt/passwd 

软连接特点:
若原始文件或目录被删除,连接文件将失效
软连接可存放在不同分区/文件系统

硬连接特点:
若原始文件被删除,连接文件仍可用
硬连接与原始文件必须在同一分区/文件系统

[root@svr7 ~]# rm -rf /opt/*
[root@svr7 ~]# echo 123456 > /opt/A
[root@svr7 ~]# cat /opt/A

[root@svr7 ~]# ln -s  /opt/A  /opt/B   #制作软连接
[root@svr7 ~]# ls /opt/
[root@svr7 ~]# cat /opt/B

[root@svr7 ~]# ln  /opt/A   /opt/C  #制作硬连接
[root@svr7 ~]# ls  /opt/

[root@svr7 ~]# rm -rf /opt/A
[root@svr7 ~]# ls /opt/
[root@svr7 ~]# cat /opt/B   #软连接不可用
[root@svr7 ~]# cat /opt/C   #硬连接可以使用


rm -rf /opt/C   //删除连接


##################################################
获取命令帮助

[root@svr7 ~]# man 5 passwd  #5代表配置文件类型帮助信息

#################################################
zip归档工具,跨平台的压缩格式
• 归档+压缩操作
– zip [-r] 备份文件.zip 被归档的文档...
[root@svr7 ~]# yum -y install zip
[root@svr7 ~]# zip -r /opt/file.zip  /root/ /etc/passwd
[root@svr7 ~]# ls /opt

[root@svr7 ~]# zip -r /opt/nsd.zip  /boot/
[root@svr7 ~]# ls /opt
• 释放归档+解压操作
– unzip 备份文件.zip [-d 目标文件夹]
[root@svr7 ~]# yum -y install unzip 
[root@svr7 ~]# unzip /opt/nsd.zip -d /mnt/
[root@svr7 ~]# ls /mnt/
[root@svr7 ~]# ls /mnt/boot/

###################################################
自定义Yum源

1.具备从互联网下载一些软件包
[student@room9pc01 ~]$ ls /linux-soft/01/

2.将tools.tar.gz传递到虚拟机A 
[student@room9pc01 ~]$ scp /linux-soft/01/tools.tar.gz  root@192.168.4.7:/root/

3.在虚拟机A查看                                             
]# ls  /root
]# tar -xf /root/tools.tar.gz  -C  /
]# ls /
]# ls /tools/
]# ls /tools/other/

4.在虚拟机A生成仓库数据文件
[root@svr7 ~]# yum -y install createrepo
[root@svr7 ~]# createrepo /tools/other/

[root@svr7 ~]# ls /tools/other/
[root@svr7 ~]# ls /tools/other/repodata

5.书写客户端配置文件
[root@svr7 ~]# vim /etc/yum.repos.d/local.repo 
[local_repo]
name=CentOS-$releasever - Base
baseurl="ftp://192.168.4.254/centos-1804"
enabled=1
gpgcheck=0
[myrpm]
name=other rpm
baseurl=file:///tools/other  #指定为本机为Yum服务端
enabled=1
gpgcheck=0
[root@svr7 ~]# yum repolist 

[root@svr7 ~]# yum -y install cmatrix
[root@svr7 ~]# cmatrix
[root@svr7 ~]# cmatrix -C red

[root@svr7 ~]# yum -y install sl
[root@svr7 ~]# sl

[root@svr7 ~]# yum -y install oneko
[root@svr7 ~]# oneko
[root@svr7 ~]# oneko &   #将程序放入后台

################################################
vim编辑技巧
命令模式操作
[root@svr7 ~]# cp /etc/passwd  /opt/a.txt  
[root@svr7 ~]# vim /opt/a.txt 
               vim +n /opt/a.txt  //光标定位在第n行
                   在末行模式下输入:n 光标定义在第n行 
光标跳转
	Home 键 或 ^、数字 0 	跳转到行首
	End 键 或“$”键 			跳转到行尾
	PgUp 键、PgDn 键 		向上翻页、向下翻页
	1G 或 gg 				跳转到文件的首行
	G 					跳转到文件的末尾行
复制/粘贴/删除
	复制 yy、3yy 			复制光标处的一行、3行
	粘贴 p、P 			粘贴到光标处之后、之前
	x 或 Delete键                  删除光标处后的单个字符
      X                         删除光标处前的单个字符
	dd、#dd 				删除光标处的一行、#行
	d^ 					从光标处之前删除至行首
	d$或D(大写) 			从光标处删除到行尾
	C(大写) 				从光标处删除到行尾,进入插入模式

查找/撤销/保存
	/word 		向后查找字符串“word”
	n、N 		跳至后/前一个结果
	u 			撤销最近的一次操作
	U(大写) 		撤销对当前行的所有修改
	Ctrl + r 	取消前一次撤销操作
	ZZ(大写) 		保存修改并退出
##################################################
末行模式操作

    :r /etc/filesystems 读入其他文件内容

[root@svr7 ~]# echo 123456 > /opt/2.txt
[root@svr7 ~]# echo hahaxixi > /opt/3.txt
[root@svr7 ~]# vim /opt/3.txt
         :r  /opt/2.txt    #读入/opt/2.txt到当前文件
         :r  /etc/passwd   #读入/etc/passwd到当前文件


字符串替换
	:s/root/admin	替换当前行第一个“root”
	:s/root/admin/g 	替换当前行所有的“root”
	:1,10 s/root/admin/g 	替换第1-10行所有的“root”
	:% s/root/admin/g 	替换文件内所有的“root
[root@svr7 ~]# cat /etc/passwd > /opt/a.txt 
[root@svr7 ~]# vim /opt/a.txt


开关参数的控制

	:set nu或nonu  显示/不显示行号
	:set ai或noai  启用/关闭自动缩进
#################################################
源码编译安装

RPM包: rpm -ivh  yum -y install

源码包----gcc make---->可以执行的程序-------->运行安装

• 主要优点
– 获得软件的最新版,及时修复bug
– 软件功能可按需选择/定制,有更多软件可供选择     
– 源码包适用各种平台

                                                          
步骤一:安装gcc与make开发工具
[root@svr7 ~]# yum -y install gcc
[root@svr7 ~]# yum -y install make
步骤二:进行tar解包
]# tar -xf /tools/inotify-tools-3.13.tar.gz -C /
]# ls /
]# cd /inotify-tools-3.13/
]# ls
步骤三:运行configure脚本
           作用1:检测是否安装gcc
           作用2:可以选择软件的功能,也可以指定软件安装的路径
      --prefix=指定安装的位置
]# cd /inotify-tools-3.13/
]# ./configure   --prefix=/opt/myrpm


常见提示:没有安装gcc
checking for gcc... no
checking for cc... no
checking for cl.exe... no
configure: error: no acceptable C compiler found in $PATH
See `config.log' for more details.

步骤四:make编译生成可以执行的程序
]# cd /inotify-tools-3.13/
]# make

步骤五:make install将可以执行的程序运行安装
]# cd /inotify-tools-3.13/
]# make  install
]# ls /opt/
]# ls /opt/myrpm/
]# ls /opt/myrpm/bin/

##################################################

date 2

一 手动图形安装虚拟机名为nsd01
    利用光盘镜像安装
    内存2048M 
    虚拟机名为:nsd01
    网络类型选择为:private1
    
    软件包:带GUI的服务器
    分区:自动分区
    设置root的密码为1,建立lisi用户设置密码1


虚拟化概述
• virtualization 资源管理
– x个物理资源 --> y个逻辑资源
– 实现程度:完全、部分、硬件辅助(CPU)

CPU支持虚拟化所有的指令集(vmx)
[student@room9pc01 ~]$ lscpu  | grep vmx


• 虚拟化主要厂商及产品
  VMware  VMware Workstation、vSphere
  Microsoft VirtualPC、Hyper-V
  RedHat  KVM、RHEV
  Citrix  Xen
  Oracle  Oracle VM VirtualBox

###################################################
二 虚拟机nsd01进行配置                                
1.配置永久主机名:kvm.tedu.cn
[root@localhost ~]# echo kvm.tedu.cn > /etc/hostname
[root@localhost ~]# hostname kvm.tedu.cn

2.配置永久IP地址:192.168.4.30/24
[root@localhost ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.30/24 connection.autoconnect yes

[root@localhost ~]# nmcli connection up eth0 
[root@localhost ~]# ifconfig

3.修改防火墙默认区域与SELinux
[root@kvm ~]# firewall-cmd --set-default-zone=trusted 

[root@kvm ~]# setenforce 0
[root@kvm ~]# getenforce 
Permissive
[root@kvm ~]# vim /etc/selinux/config
SELINUX=permissive

4.构建Yum仓库
]# cd /etc/yum.repos.d/
]# mkdir repo
]# ls
]# mv *.repo  repo
]# ls
]# vim dvd.repo
 [dvd]
 name=centos7
 baseurl=ftp://192.168.4.254/centos-1804
 enabled=1
 gpgcheck=0
]#  yum  repolist
]#  yum -y install xeyes

##################################################
安装虚拟化服务器平台
• 主要软件包
– qemu-kvm :为 kvm 提供底层仿真支持
– libvirt-daemon :libvirtd 守护进程,管理虚拟机
– libvirt-client :用户端软件,提供客户端管理命令
– libvirt-daemon-driver-qemu :libvirtd 连接 qemu 的驱动
– virt-manager :图形管理工具

]#  yum -y install qemu-kvm
]#  yum -y install libvirt-daemon
]#  yum -y install libvirt-client
]#  yum -y install libvirt-daemon-driver-qemu
]#  yum -y install virt-manager

虚拟化服务: libvirtd
[root@kvm /]# systemctl status libvirtd  #查看服务的状态
####################################################
三 通过命令管理虚拟机
virsh命令工具介绍
• 提供管理各虚拟机的命令接口
– 支持交互模式,查看/创建/停止/关闭 .. ..
– 格式:virsh 控制指令 [虚拟机名称] [参数]

• 查看KVM节点(服务器)信息
]$ virsh nodeinfo
• 列出虚拟机
]$ virsh list [--all]    #重点
• 列出虚拟网络
]$ virsh net-list [--all]
• 查看指定虚拟机的信息
]$ virsh dominfo 虚拟机名称     #重点
]$ virsh autostart nsd01    #设置虚拟机开机自启动
]$ virsh dominfo  nsd01
]$ virsh autostart --disable nsd01  #禁止虚拟机开机自启动
]$ virsh dominfo  nsd01
• 开关机操作
]$ virsh start或reboot或shutdown 虚拟机名称    #重点
• 强制关闭指定的虚拟机
]$ virsh destroy 虚拟机名称    #重点
]$ virt-manager  列出虚拟机图形管理器
#################################################
• 一台KVM虚拟机的组成               

– xml配置文件(虚拟机描述文件):定义虚拟机的名称、UUID、CPU、内
存、虚拟磁盘、网卡等各种参数设置
[student@room9pc01 ~]$ ls /etc/libvirt/qemu/

– 磁盘镜像文件:保存虚拟机的操作系统及文档数据,
镜像路径取决于xml配置文件中的定义
[student@room9pc01 ~]$ ls /var/lib/libvirt/images/


##################################################
查看虚拟机xml文件内容
[student@room9pc01 /]$ virsh dumpxml nsd01   
  虚拟机名称 
  虚拟机的UUID唯一标识
  虚拟机磁盘文件路径
      <source file='/var/lib/libvirt/images/nsd01.qcow2'/>
  虚拟机网卡信息
<interface type='network'>
      <mac address='52:54:00:d4:fe:59'/>

[student@room9pc01 /]$ virsh dumpxml nsd01 | less
##################################################
在命令行手动制作一台虚拟机
1.磁盘镜像文件
]$ cd /var/lib/libvirt/images/
]$ du -sh .node_base.qcow2

]$ cp  .node_base.qcow2      nsd02.qcow2
]$ du -sh nsd02.qcow2 

2.建立新的xml配置文件, uuidgen可以生成随机的UUID值
]$ cd /etc/libvirt/qemu/
]$ virsh dumpxml nsd01 > /etc/libvirt/qemu/nsd02.xml

]$ vim  /etc/libvirt/qemu/nsd02.xml
  1)虚拟机名称   <name>nsd02</name>
  2)虚拟机的UUID唯一标识   删除整行内容  UUID
  3)虚拟机磁盘文件路径   <source file='/var/lib/libvirt/images/nsd02.qcow2'/>
  4)虚拟机网卡信息
      <mac address='52:54:00:d4:fe:59'/> 删除整行内容
3.导入虚拟机配置信息
]$ virsh  define /etc/libvirt/qemu/nsd02.xml 
]$ virsh  list --all
]$ virsh  start  nsd02
#################################################
命令行删除虚拟机
]$ virsh list --all
]$ virsh destroy nsd02    #强制关闭虚拟机
域 nsd02 被删除

]$ virsh list --all
]$ virsh undefine nsd02   #删除虚拟机xml配置文件
域 nsd02 已经被取消定义

]$ virsh list --all
]$ rm -rf /var/lib/libvirt/images/nsd02.qcow2  #手动删除

##################################################
在命令行手动创建虚拟机
1.建立新的磁盘文件
]$ cp  /var/lib/libvirt/images/.node_base.qcow2  /tmp/nsd03.qcow2

]$ du -sh /tmp/nsd03.qcow2

2.建立xml配置文件
]$ virsh dumpxml nsd01 > /home/student/nsd03.xml
]$ ls /home/student/nsd03.xml 

]$ vim  /home/student/nsd03.xml
  1)虚拟机名称   <name>nsd03</name>
  2)虚拟机的UUID唯一标识   删除整行内容  UUID
  3)虚拟机磁盘文件路径  <source file='/tmp/nsd03.qcow2'/>
  4)虚拟机网卡信息
      <mac address='52:54:00:d4:fe:59'/> 删除整行内容
3.导入虚拟机配置信息
]$ ls /etc/libvirt/qemu
]$ virsh  define /home/student/nsd03.xml  #导入虚拟机信息
]$ ls /etc/libvirt/qemu
]$ virsh  start  nsd03
]$ virsh  list
#####################################################
三合一:导出 修改 导入
• 对虚拟机的配置进行调整
– 编辑:virsh edit 虚拟机名
1.建立磁盘文件
]$ cp /var/lib/libvirt/images/.node_base.qcow2  /var/lib/libvirt/images/nsd04.qcow2
                                                                                                                                                                                                                       
]$ du -sh /var/lib/libvirt/images/nsd04.qcow2
      
2.建立xml配置文件
[student@room9pc01 /]$ virsh edit nsd01
  1)虚拟机名称   <name>nsd04</name>
  2)虚拟机的UUID唯一标识   删除整行内容  UUID
  3)虚拟机磁盘文件路径  <source file='/var/libvirt/images/nsd04.qcow2'/>
  4)虚拟机网卡信息
      <mac address='52:54:00:d4:fe:59'/> 删除整行内容

[student@room9pc01 /]$ virsh list --all
#################################################
常用镜像盘类型                                              
• 虚拟机的磁盘镜像文件格式                             
	特点\类型		 RAW 	QCOW2
	KVM默认 		 否 		是
	I/O效率 		 高 		较高
	占用空间 		 大 		小
	压缩		 	 不支持 	支持
	后端盘复用 	         不支持 	支持
	快照 			 不支持 	支持

查看磁盘镜像文件信息
]$ qemu-img info /var/lib/libvirt/images/nsd04.qcow2 
 virtual size: 2.0G (2147483648 bytes)  #虚拟大小
 disk size: 633M   #实际占用空间

#################################################
COW技术原理
• Copy On Write,写时复制
– 直接映射原始盘的数据内容
– 当原始盘的旧数据有修改时,在修改之前自动将旧数据存入前端盘
– 对前端盘的修改不回写到原始盘
– 原始盘的数据不能做修改

快速创建qcow前端盘
• qemu-img 通过 -b  选项复用指定原始盘
– qemu-img create -f  qcow2  -b 原始盘   前端盘   大小

1.命令手动创建虚拟机磁盘文件                   
]$ cd /var/lib/libvirt/images/
]$ qemu-img create  -f  qcow2  -b .node_base.qcow2  nsd05.qcow2 5G    #通过原始盘产生前端盘

]$ qemu-img info nsd05.qcow2      #查看虚拟磁盘文件信息
virtual size: 5.0G (5368709120 bytes) #虚拟大小
disk size: 196K                       #实际占用空间大小
backing file: .node_base.qcow2   #原始盘

2.建立xml文件
]$ virsh dumpxml nsd01 > /tmp/nsd05.xml #导出虚拟机信息
]$ vim /tmp/nsd05.xml #修改 虚拟机名  UUID  磁盘路径   网卡MAC
]$ virsh define  /tmp/nsd05.xml

##################################################
离线访问虚拟机
• 使用 guestmount 工具
– 支持离线挂载 raw、qcow2 格式虚拟机磁盘
– 可以在虚拟机关机的情况下,直接修改磁盘中的文档
– 方便对虚拟机定制、修复、脚本维护
  
]$ virsh destroy nsd01
]$ guestmount -a /var/lib/libvirt/images/nsd01.qcow2 -i   /mnt/

##################################################
   date 03

• DNS服务器的功能
– 正向解析:根据注册的域名查找其对应的IP地址
– 反向解析:根据IP地址查找对应的注册域名,不常用


域名结构:  树型结构
   所有的域名都必须以点结尾
    www.qq.com.   www.baidu.com.

根域名:                    .


一级域名:    .cn    .us    .kr   .tw   .hk  .jp  .......


二级域名:  .com.cn    .tedu.cn   .net.cn  .org.cn ......


三级域名:  nb.com.cn   dc.com.cn   tc.com.cn ........


完全合格的域名(FQDN)=主机头部+注册的域名
Full Qualified Domain Name,完全合格主机名
###################################################
– 系统服务:named
– 默认端口:TCP/UDP 53
– 运行时的虚拟根环境:/var/named/chroot/

• 主配置文件:/etc/named.conf      #本机负责解析的域名 
• 地址库文件存放路径:/var/named/   #域名的解析结果
 
构建基本DNS服务
虚拟机A:
1.安装软件包
[root@svr7 ~]# yum -y install  bind-chroot   bind
 bind-9.9.4-29.el7.x86_64  //域名服务包
 bind-chroot-9.9.4-29.el7.x86_64  //提供虚拟根支持,牢笼
 
2.修改主配置文件      
[root@svr7 ~]# cp  /etc/named.conf  /etc/named.bak
[root@svr7 ~]# vim  /etc/named.conf
 options {
        directory       "/var/named";  #指定地址库文件位置
 };
 zone "tedu.cn" IN {      #设置本机负责的域名
	type master;          #设置本机为权威主DNS服务器
	file "tedu.cn.zone";  #设置地址库文件名称
 };
3.建立地址库文件tedu.cn.zone
]# cd /var/named/
]# cp -p named.localhost tedu.cn.zone  #-p保持权限不变
]# ls -l tedu.cn.zone
]# vim tedu.cn.zone                    
 所有的域名在地址库文件必须以点结尾
 当没有以点结尾时,自动补全地址库负责的域名

 tedu.cn.        NS      svr7        #声明区域DNS服务器
 svr7            A       192.168.4.7 #声明DNS服务器IP地址
 www             A       1.1.1.1    #常规DNS正向解析
 ftp             A       2.2.2.2
[root@svr7 /]# systemctl restart named
虚拟机B:客户端验证
]# echo nameserver 192.168.4.7  >  /etc/resolv.conf 
]# cat /etc/resolv.conf

]# nslookup  www.tedu.cn
]# nslookup  ftp.tedu.cn
0###################################################
多域名的DNS服务器,负责解析qq.com域名
虚拟机A:
1.修改主配置文件
[root@svr7 /]# vim  /etc/named.conf 
options {
        directory       "/var/named";
};
zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
};
zone "qq.com" IN {
        type master;
        file "qq.com.zone";
};
[root@svr7 /]# cd /var/named/
[root@svr7 named]# cp -p tedu.cn.zone qq.com.zone
[root@svr7 named]# vim qq.com.zone
 qq.com. 	NS	 svr7
 svr7     	A    192.168.4.7
 www         A    3.3.3.3
[root@svr7 named]# systemctl  restart  named

###############################################
特殊解析记录
1.基于DNS解析记录负载均衡
[root@svr7 /]# vim /var/named/tedu.cn.zone  
tedu.cn.        NS      svr7
svr7            A       192.168.4.7
www             A       192.168.4.10
www             A       192.168.4.20
www             A       192.168.4.30
ftp             A       2.2.2.2
[root@svr7 /]# systemctl restart named

2.泛域名解析
虚拟机A
[root@svr7 /]# vim /var/named/tedu.cn.zone 
tedu.cn.        NS      svr7
svr7            A       192.168.4.7
www             A       192.168.4.10
ftp             A       2.2.2.2
*               A       1.2.3.4
[root@svr7 /]# systemctl  restart  named

虚拟机B:测试  nslookup  haha.tedu.cn

3.解析记录的别名
虚拟机A:
[root@svr7 /]# vim /var/named/tedu.cn.zone
tedu.cn.        NS      svr7
svr7            A       192.168.4.7
www             A       192.168.4.10
ftp             A       2.2.2.2
*               A       1.2.3.4
mail            CNAME   ftp

[root@svr7 /]# systemctl restart named

虚拟机B测试:
[root@pc207 ~]# nslookup mail.tedu.cn

4.有规律的泛域名解析

      pc1.tedu.cn -----> 192.168.10.1
      pc2.tedu.cn -----> 192.168.10.2
      pc3.tedu.cn -----> 192.168.10.3
      pc4.tedu.cn -----> 192.168.10.4
          .......
      pc50.tedu.cn -----> 192.168.10.50

 内置函数:$GENERATE  制造连续范围的数字
虚拟机A
[root@svr7 ~]# vim /var/named/tedu.cn.zone  

 $GENERATE 1-50   pc$   A   192.168.10.$
[root@svr7 ~]# !sys
systemctl restart named
[root@svr7 ~]# 

虚拟机B测试:
[root@pc207 ~]# nslookup pc1.tedu.cn
[root@pc207 ~]# nslookup pc2.tedu.cn
[root@pc207 ~]# nslookup pc3.tedu.cn

##################################################
DNS资源解析记录有哪些?
  正向解析记录(A记录)
 DNS声明记录(NS记录)
  解析记录的别名(CNAME记录)
###################################################
DNS子域授权
 
     父域:qq.com 由虚拟机A进行解析
     子域:bj.qq.com 由虚拟机B进行解析

虚拟机B,构建DNS服务器,负责解析bj.qq.com
[root@pc207 ~]# yum -y install bind bind-chroot
[root@pc207 ~]# cp /etc/named.conf /etc/named.bak
[root@pc207 ~]# vim /etc/named.conf 
options {
        directory       "/var/named";
};
zone "bj.qq.com" IN {
        type master;
        file "bj.qq.com.zone";
};
[root@pc207 ~]# cd /var/named/
[root@pc207 named]# cp -p named.localhost bj.qq.com.zone
[root@pc207 named]# vim bj.qq.com.zone
bj.qq.com. NS   pc207
pc207      A    192.168.4.207
www        A    50.60.70.80
[root@pc207 /]# systemctl restart named
[root@pc207 /]# nslookup www.bj.qq.com 192.168.4.207
[root@pc207 /]# nslookup www.qq.com 192.168.4.7

################################################
子域授权: 让父域的DNS服务器知晓子域DNS服务器
              让父域的DNS服务器可以解析子域的域名

虚拟机A:                                   
[root@svr7 ~]# vim /var/named/qq.com.zone 
qq.com.         NS      svr7
bj.qq.com.      NS      pc207
svr7            A       192.168.4.7
pc207           A       192.168.4.207
www             A       3.3.3.3
[root@svr7 ~]# systemctl restart named

[root@pc207 /]# nslookup www.bj.qq.com 192.168.4.7
Server:		192.168.4.7
Address:	     192.168.4.7#53

Non-authoritative answer:   #非权威解答
Name:	www.bj.qq.com
Address: 50.60.70.80

##################################################
递归解析: 
   由客户端发出请求,首选DNS服务器接受请求,将解析结果带回过程
[root@svr7 ~]# vim /etc/named.conf 
options {
        directory       "/var/named";
        recursion no;    #禁止递归解析:
};

迭代解析:首选DNS服务器与其他DNS服务器交互过程
专业测试DNS工具
[root@pc207 /]# dig www.bj.qq.com 192.168.4.7

#################################################
 主机名映射文件:/etc/hosts                            
      没有DNS服务器前提下,解析域名,只能为本机做域名解析
        
[root@svr7 ~]# vim  /etc/hosts
192.168.4.110   www.nb.com

[root@svr7 ~]# ping www.nb.com

域名解析过程中最高优先级为/etc/hosts   匹配即停止
然后在读取/etc/resolv.conf
#################################################
缓存DNS,缓存解析结果,加快解析过程         

三个角色:客户端    缓存DNS服务    真DNS服务器

虚拟机A:真DNS服务器
虚拟机B:缓存DNS服务
虚拟机C:客户端 
1.建立虚拟机C
   配置IP地址192.168.4.10/24,主机名为svr10.tedu.cn
虚拟机B:缓存DNS服务
[root@pc207 /]# vim /etc/named.conf 
options {
      directory       "/var/named";
      forwarders { 192.168.4.7; }; #转发给虚拟机A的IP地址
};
[root@pc207 /]# systemctl restart named
虚拟机C上验证:
[root@svr10 ~]# nslookup www.tedu.cn 192.168.4.207
  
DNS主/从结构: 备份 解决单点故障
                首选DNS服务器
                备用DNS服务器
虚拟机A :构建主DNS服务器
1 修改主配置文件,允许虚拟机B进行同步数据
DNS主/从结构:备份  解决单点故障

以qq.com域名为例
  虚拟机A为主DNS服务器（首选DNS服务器）
  虚拟机B为从DNS服务器（备用DNS服务器）

虚拟机A：构建主DNS服务器
1.修改主配置文件，允许虚拟机B进行同步数据
[root@svr7 /]# man named.conf      #查看man帮助信息
[root@svr7 /]# vim /etc/named.conf 
options {
   directory       "/var/named";
   allow-transfer { 192.168.4.207; }; #允许从服务器同步数据
};
zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
};
zone "qq.com" IN {
        type master;
        file "qq.com.zone";
};

2.在地址库文件中，声明从服务器的IP地址
[root@svr7 /]# vim /var/named/qq.com.zone 

 qq.com.      NS  svr7         #声明DNS服务器
 qq.com.      NS  pc207        #声明DNS服务器
 svr7         A   192.168.4.7
 pc207        A   192.168.4.207
 www          A   3.3.3.10
 ftp          A   4.4.4.4

3.重起named服务
[root@svr7 /]# systemctl restart named


虚拟机B构建为从DNS服务器（备用DNS服务器）
  地址库文件不需要自己创建，地址库文件是从主DNS服务器进行同步
1.安装软件包bind bind-chroot
[root@pc207 /]# yum -y install bind bind-chroot

2.修改主配置文件
[root@pc207 /]# vim /etc/named.conf 
 options {
        directory       "/var/named";
  };
  zone "qq.com" IN {
        type slave;                  #类型为从服务器
        file "slaves/qq.com.slave";
        masters  {  192.168.4.7;  };  #指定主服务器位置
  };
  #将备份数据起名为qq.com.slave，存放在/var/named/slaves
 #slaves目录默认named用户对其拥有rwx权限

[root@pc207 /]# ls /var/named/slaves/
[root@pc207 /]# systemctl restart named
[root@pc207 /]# ls /var/named/slaves/  #验证同步数据
qq.com.slave
[root@pc207 /]# 

虚拟机C：客户端验证
]# echo nameserver 192.168.4.7 > /etc/resolv.conf 
]# echo nameserver 192.168.4.207 >> /etc/resolv.conf 
]# cat /etc/resolv.conf
nameserver 192.168.4.7      #首选DNS服务器
nameserver 192.168.4.207    #备用DNS服务器

]#  nslookup www.qq.com

###################################################
数据更新,一定要在主DNS服务器完成
虚拟机A：
[root@svr7 /]# vim /var/named/qq.com.zone
                                         
  2019082001 ; serial  #数据的版本号格式：年月日次数  10位组成
     1D      ; refresh #主与从同步数据时间
     1H      ; retry   #失连后同步数据的时间
     1W      ; expire  #完全失效时间
     3H )    ; minimum #无效记录  记忆时间


 每次数据更新，数据的版本号必须要变大
 数据的版本号：主与从数据同步时，唯一标准

##############################################

##################################################


        date 04


虚拟机A:构建DNS服务器,实现www.sina.com的解析结果为10.20.30.40
1.修改主配置文件
[root@svr7 named]# vim /etc/named.conf 
options {
        directory       "/var/named";
        recursion no;
};
zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
};
zone "qq.com" IN {
        type master;
        file "qq.com.zone";
};
zone "sina.com" IN {
        type master;
        file "sina.com.zone";
};
2.建立地址库文件
[root@svr7 named]# cd /var/named/
[root@svr7 named]# cp -p qq.com.zone sina.com.zone
[root@svr7 named]# vim /var/named/sina.com.zone 
sina.com.       NS      svr7
svr7            A       192.168.4.7
www             A       10.20.30.40

[root@svr7 named]# systemclt  restart named

####################################################
Split分离解析(视图解析)
什么是分离解析
• 当收到客户机的DNS查询请求的时候
– 能够区分客户机的来源地址
– 为不同类别的客户机提供不同的解析结果
– 不同客户端解析同一个域名,解析结果不同
– 作用:为客户端就近提供服务器

BIND的view视图
• 根据源地址集合将客户机分类
    由上到下匹配及停止,所有的客户端都要找到自己的分类   
    所有的zone都必须在view中

  view  "nsd"  {
  match-clients  { 192.168.1.1; };  #匹配客户机来源地址	  
  zone "12306.cn" IN {
    ...... 地址库文件12306.zone;
    }; };                                                         
  view  "abc"  {
  match-clients { 192.168.2.1; };
  zone "12306.cn" IN {
    ...... 地址库文件12306.abc;
    }; };
  view  "other"  {
  match-clients { any; };
  zone "12306.cn" IN {
    ...... 地址库文件12306.other;
    }; };
###################################################
案例需求及要点
• 环境及需求
– 权威DNS:svr7.tedu.cn 192.168.4.7
– 负责区域:tedu.cn
– A记录分离解析 —— 以 www.tedu.cn 为例
客户机来自 解析结果
	192.168.4.207-----> 192.168.4.100
	其他地址 -----> 1.2.3.4

[root@svr7 /]# vim /etc/named.conf 
options {
        directory       "/var/named";
};
view "nsd" {                            #分类名称
  match-clients  {  192.168.4.207;  };  #匹配客户机来源地址
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";---->解析结果写192.168.4.100
  };
};
view "other" {
  match-clients  {  any;  };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other";---->解析结果写1.2.3.4
  };
};
 建立地址库文件tedu.cn.zone与tedu.cn.other写入不同的解析结果

#############################################################
多个域名的分离解析,每一个view中zone个数保持一致
– A记录分离解析 —— 以 www.tedu.cn 为例
– A记录分离解析 —— 以 www.sina.com 为例
客户机来自 解析结果
	192.168.4.207-----> 192.168.4.100
	其他地址 -----> 1.2.3.4

view "nsd" {
  match-clients  { 192.168.4.207;  };                  
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone"; -------> 解析结果为192.168.4.100
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.zone"; -------> 解析结果为192.168.4.100
  };
};
view "other" {
  match-clients  { any;  };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other"; -------> 解析结果为1.2.3.4
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.other"; -------> 解析结果为1.2.3.4
  };
};
#####################################################
扩展:
– A记录分离解析 —— 以 www.tedu.cn 为例
– A记录分离解析 —— 以 www.sina.com 为例
客户机来自 解析结果
	192.168.4.207---www.tedu.cn--> 192.168.4.100
	192.168.4.7---www.sina.com--> 192.168.4.200

	其他地址 --www.tedu.cn---> 1.2.3.4
	其他地址 --www.sina.com---> 1.2.3.4

view "nsd" {
  match-clients  { 192.168.4.207;  };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.other";
  };
};
view "abc" {
  match-clients  { 192.168.4.7;  };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other";
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.zone";
  };
};
view "other" {
  match-clients  {  any;  };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other";
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.other";
  };
};
#####################################################
acl地址列表,类似于变量作用

acl "test" {  192.168.4.207; 192.168.1.1; 192.168.2.1; 192.168.3.1; 192.168.7.0/24; };

view "nsd" {
  match-clients  {  test; };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.other";
  };
};

view "abc" {
  match-clients  {  test; };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.other";
  };
};

####################################################
RAID磁盘阵列

• 廉价冗余磁盘阵列
– 通过硬件/软件技术,将多个较小/低速的磁盘整合成一个大磁盘
– 阵列的价值:提升I/O效率、硬件级别的数据冗余
– 不同RAID级别的功能、特性各不相同
 

  主板—>阵列卡—>磁盘—>操作系统—>数据



• RAID 0,条带模式
– 同一个文档分散存放在不同磁盘
– 并行写入以提高效率
– 至少需要两块磁盘组成

• RAID 1,镜像模式
– 一个文档复制成多份,分别写入不同磁盘
– 多份拷贝提高可靠性,效率无提升
– 至少需要两块磁盘组成

• RAID5,高性价比模式
– 相当于RAID0和RAID1的折中方案
– 需要至少一块磁盘的容量来存放校验数据
– 至少需要三块磁盘组成

• RAID6,高性价比/可靠模式
– 相当于扩展的RAID5阵列,提供2份独立校验方案
– 需要至少两块磁盘的容量来存放校验数据
– 至少需要四块磁盘组成

• RAID 0+1/RAID 1+0
– 整合RAID 0、RAID 1的优势
– 并行存取提高效率、镜像写入提高可靠性
– 至少需要四块磁盘组成
######################################################
进程管理

    程序: 静态的代码   占用磁盘空间
 
    进程: 动态执行的代码   占用CPU 内存
   
     父进程/子进程   树型结构    僵尸进程   孤儿进程
     进程唯一标识: PID 进程的编号

   systemd:上帝进程,所有进程的父进程

查看进程树
• pstree — Processes Tree             15:15上课
– 格式:pstree [选项] [PID或用户名]
• 常用命令选项
– -a:显示完整的命令行
– -p:列出对应PID编号

[root@svr7 /]# pstree
[root@svr7 /]# useradd lisi
[root@svr7 /]# pstree  lisi
bash───vim
[root@svr7 /]# pstree -a lisi
bash
  └─vim a.txt
[root@svr7 /]# pstree -ap lisi


• ps aux 操作,信息全面
– 列出正在运行的所有进程
用户 进程ID %CPU %内存 虚拟内存 固定内存 终端 状态 起始时间 CPU时间 程序指令

• ps -elf 操作,有进程的父进程的PID值
– 列出正在运行的所有进程
   PPID:父进程的PID号

统计正在运行的进程有多少?
[root@svr7 /]# ps aux

[root@svr7 /]# ps aux | wc -l
[root@svr7 /]# ps -elf | wc -l


进程动态排名
• top 交互式工具
– 格式:top [-d 刷新秒数] [-U 用户名]
[root@svr7 /]# top -d 1
  按P(大写)可以进行CPU的排序
  按M(大写)可以进行内存的排序
 load average: 0.00, 0.01, 0.05  #CPU负载量   1分  5分钟  15 分钟

检索进程
• pgrep — Process Grep
– 用途:pgrep [选项]... 查询条件
• 常用命令选项
– -l:输出进程名,而不仅仅是 PID
– -U:检索指定用户的进程
– -x:精确匹配完整的进程名
[root@svr7 /]# pgrep -l a       #检索所有进程名带a的
[root@svr7 /]# pgrep -lU lisi   #检索lisi的所有进程
[root@svr7 /]# pstree -ap lisi  #检索lisi的所有进程

进程的前后台调度

• 后台启动,正在运行放入后台
– 在命令行末尾添加“&”符号,不占用当前终端
• Ctrl + z 组合键
– 挂起当前进程(暂停并转入后台)
• jobs 命令
– 查看后台任务列表
• fg 命令
– 将后台任务恢复到前台运行
• bg 命令
– 激活后台被挂起的任务
[root@svr7 /]# sleep 9000 &   #正在运行放入后台    
[root@svr7 /]# jobs          #查看后台运行的进程
[root@svr7 /]# sleep 8000
^Z            #输入Ctrl+z 暂停放入后台
[2]+  已停止               sleep 8000
[root@svr7 /]# jobs
[root@svr7 /]# bg 2    #将后台编号为2的进程继续运行

[root@svr7 /]# jobs 
[root@svr7 /]# fg 1  #将后台编号为1的进程恢复到前台
sleep 9000 
^C                      #输入Ctrl+C 结束
[root@svr7 /]# jobs
[root@svr7 /]# fg 2   #将后台编号为2的进程恢复到前台
sleep 8000 
^C                       #输入Ctrl+C 结束
[root@svr7 /]# jobs

###################################################
杀死进程
• 干掉进程的不同方法
– Ctrl+c 组合键,中断当前命令程序
– kill [-9] PID... 、kill [-9] %后台任务编号
– killall [-9] 进程名...
– pkill 查找条件
kill 不仅仅是杀死进程的 是给进程发送信号的
kill -l   //查看选项
kill -15(或TERM)  PID号
kill -9(或KILL)  PID号
kill PID   nginx(PID)   //KILL 发信号给nginx你可以去死了
kill -9 PID   nginx(PID)   //KILL 再次发信号给nginx你必须去死了
kill -10(或USR1) PID     //我把你的日志拿走了,你再建个新的日志
kill -19  PID   //暂停进程
kill -18 PID    //恢复进程


[root@svr7 /]# sleep 1000 &
[root@svr7 /]# jobs -l
[root@svr7 /]# kill 4013    #按照PID进行杀死

[root@svr7 /]# sleep 1000 &
[root@svr7 /]# jobs -l
[root@svr7 /]# kill -9 4015  #按照PID强制杀死
[root@svr7 /]# jobs -l

[root@svr7 /]# sleep 1000 &
[root@svr7 /]# sleep 1000 &
[root@svr7 /]# sleep 1000 &
[root@svr7 /]# jobs 

[root@svr7 /]# killall sleep   #杀死所有sleep进程  

杀死一个用户开启的所有进程(强制踢出一个用户)
[root@svr7 /]# killall  -9  -u  用户名

#################################################
日志管理
日志的功能
• 系统和程序的“日记本”
– 记录系统、程序运行中发生的各种事件
– 通过查看日志,了解及排除故障
– 信息安全控制的  依据

• 由系统服务rsyslog统一记录/管理
– 日志消息采用文本格式
– 主要记录事件发生的时间、主机、进程、内容

• 常见的日志文件
 	/var/log/messages 记录内核消息、各种服务的公共消息
	/var/log/dmesg 记录系统启动过程的各种消息
	/var/log/cron 记录与cron计划任务相关的消息
	/var/log/maillog 记录邮件收发相关的消息
	/var/log/secure 记录与访问限制相关的安全消息

日志分析
• 通用分析工具
– tail、tailf、less、grep等文本浏览/检索命令
– awk、sed等格式化过滤工具

tailf:实时跟踪日志消息
[root@svr7 /]# echo 123 > /opt/1.txt
[root@svr7 /]# cat /opt/1.txt
123
[root@svr7 /]# tailf /opt/1.txt
123
################################################
用户登录分析                                               
• users、who、w 命令
– 查看已登录的用户信息,详细度不同

 pts:图形命令行终端

• last、lastb 命令
– 查看最近登录成功/失败的用户信息
[root@svr7 /]# last  -2  #最近登录的2条成功信息
[root@svr7 /]# lastb -2  #最近登录的2条失败信息

[root@svr7 /]# users  #查看已登录的用户信息
[root@svr7 /]# who   #查看已登录的用户信息
[root@svr7 /]# w   #查看已登录的用户信息
###################################################
日志消息的优先级
• Linux内核定义的事件紧急程度
– 分为 0~7 共8种优先级别
– 其数值越小,表示对应事件越紧急/重要

  0  EMERG（紧急）          会导致主机系统不可用的情况
  1  ALERT（警告）          必须马上采取措施解决的问题
  2  CRIT（严重）	        比较严重的情况
  3  ERR（错误）	       运行出现错误
  4  WARNING（提醒）      可能会影响系统功能的事件
  5  NOTICE（注意）        不会影响系统但值得注意
  6  INFO（信息）	       一般信息
  7  DEBUG（调试）          程序或系统调试信息等

使用journalctl工具
• 提取由 systemd-journal 服务搜集的日志
– 主要包括内核/系统日志、服务日志

• 常见用法
– journalctl | grep 关键词
– journalctl -u 服务名   [-p 优先级]
– journalctl -n 消息条数
– journalctl --since="yyyy-mm-dd HH:MM:SS" --
until="yyyy-mm-dd HH:MM:SS"

##################################################
systemctl控制

• Linux系统和服务管理器
– systemd是内核引导之后加载的第一个初始化进程(PID=1)
– 负责掌控整个Linux的运行/服务资源组合

systemd
• 一个更高效的系统&服务管理器
– 开机服务并行启动,各系统服务间的精确依赖
– 配置目录:/etc/systemd/system/
– 服务目录:/lib/systemd/system/
– 主要管理工具:systemctl

对于服务的管理
 systemctl restart  服务名    #重起服务
 systemctl start    服务名    #开启服务
 systemctl stop     服务名    #停止服务
 systemctl status   服务名    #查看服务当前的状态
 
 systemctl enable   服务名      #设置服务开机自启动
 systemctl disable  服务名      #设置服务不开机自启动
 systemctl is-enabled  服务名   #查看是否为开机自启



RHEL6 运行级别    不同级别,开启的服务不同
  
         0：关机    
         1：单用户模式（基本功能的实现，破解Linux密码）
	 2：多用户字符界面（不支持网络）    
	 3：多用户字符界面（支持网络）服务器默认的运行级别   
	 4：未定义
	 5：图形界面   
	 6：重起 
   
    切换运行级别：init  5  



RHEL7 运行模式 

   字符模式：multi-user.target
   图形模式：graphical.target

[student@room9pc01 ~]$ rht-vmctl reset classroom
classroom [OK]
域 classroom 已开始

[student@room9pc01 ~]$ rht-vmctl reset server
server [OK]
域 server 已开始

[root@svr7 /]# ls -l /lib/systemd/system/

当前直接切换到字符模式
]# systemctl isolate multi-user.target   = init 3
当前直接切换到图形模式
]# systemctl isolate graphical.target   = init 5

查看每次开机默认进入模式
[root@svr7 /]# systemctl get-default
multi-user.target

设置永久策略，每次开机自动进入graphical.target
# systemctl set-default graphical.target
# reboot 

#################################################



###################################################
     date5 


DNS分离解析与Web结合
虚拟机C:构建Web服务
[root@svr10 ~]# yum -y install httpd
[root@svr10 ~]# cat /etc/httpd/conf.d/nsd01.conf 
<VirtualHost *:80>
  ServerName www.qq.com
  DocumentRoot /var/www/qq
</VirtualHost>
<VirtualHost *:80>
  ServerName www.163.com
  DocumentRoot /var/www/163
</VirtualHost>
[root@svr10 ~]#
[root@svr10 ~]# mkdir /var/www/qq /var/www/163
[root@svr10 ~]# echo '<h1>Web1 QQ' > /var/www/qq/index.html
[root@svr10 ~]# echo '<h1>Web1 163' > /var/www/163/index.html

[root@svr10 ~]# systemctl restart httpd
##################################################
虚拟机D构建Web服务
[root@pc20 ~]# yum -y install httpd
[root@pc20 ~]# cat /etc/httpd/conf.d/nsd01.conf 
<VirtualHost *:80>
  ServerName www.qq.com
  DocumentRoot /var/www/qq
</VirtualHost>
<VirtualHost *:80>
  ServerName www.163.com
  DocumentRoot /var/www/163
</VirtualHost>
[root@pc20 ~]# mkdir /var/www/qq /var/www/163
[root@pc20 ~]# echo '<h1>Web2 QQ' > /var/www/qq/index.html
[root@pc20 ~]# echo '<h1>Web2 163' > /var/www/163/index.html
[root@pc20 ~]# systemctl restart httpd
[root@pc20 ~]# 
#############################################
虚拟机A实现DNS分离解析
[root@svr7 /]# yum -y install bind bind-chroot
 [root@svr7 /]# cat /etc/named.conf 
options {
	directory 	"/var/named";
};
view "nsd" {
  match-clients  { 192.168.4.7;  };
  zone "qq.com" IN {
	type master;
	file "qq.com.zone";
  };
  zone "163.com" IN {
	type master;
	file "163.com.zone";
  };
};
view "other" {
  match-clients  { any;  };
  zone "qq.com" IN {
	type master;
	file "qq.com.other";
  };
  zone "163.com" IN {
	type master;
	file "163.com.other";
  };
};
[root@svr7 /]# cat /var/named/qq.com.zone 
	qq.com. 		NS		svr7
	svr7     	A       192.168.4.7
	www 		A       192.168.4.10
[root@svr7 /]# cat /var/named/163.com.zone 
	163.com. 	NS		svr7
	svr7     	A       192.168.4.7
	www			A       192.168.4.10
[root@svr7 /]# cat /var/named/qq.com.other
	qq.com. 		NS		svr7
	svr7     	A       192.168.4.7
	www			A       192.168.4.20
[root@svr7 /]# cat /var/named/163.com.other
	163.com. 	NS		svr7
	svr7     	A       192.168.4.7
	www			A       192.168.4.20
[root@svr7 /]# systemctl restart named

为四台虚拟机指定DNS服务器地址
[root@svr7 /]# echo nameserver 192.168.4.7 > /etc/resolv.conf 

[root@pc207 ~]#  echo nameserver 192.168.4.7 > /etc/resolv.conf

[root@svr10 ~]#  echo nameserver 192.168.4.7 > /etc/resolv.conf

[root@pc20 ~]#  echo nameserver 192.168.4.7 > /etc/resolv.conf

####################################################
部署DHCP服务器
• Dynamic Host Configuration Protocol
– 动态主机配置协议,由 IETF(Internet 网络工程师任
务小组)组织制定,用来简化主机地址分配管理

• 主要分配以下入网参数
– IP地址/子网掩码/广播地址
– 默认网关地址、DNS服务器地址

• DHCP地址分配的四次会话,以广播进行,先到先得
– DISCOVERY --> OFFER --> REQUEST -->ACK

  一个网络中,只能有一台DHCP服务器

• 服务端基本概念
– 租期:允许客户机租用IP地址的时间期限,单位为秒
– 作用域:分配给客户机的IP地址所在的网段
– 地址池:用来动态分配的IP地址的范围

虚拟机A:
1.安装软件包dhcp
[root@svr7 /]# yum -y install dhcp
2.修改配置文件
[root@svr7 /]# vim /etc/dhcp/dhcpd.conf 
   :r  /usr/share/doc/dhcp*/dhcpd.conf.example

 subnet 192.168.4.0 netmask 255.255.255.0 { #分配网段
  range 192.168.4.100 192.168.4.200;     #分配IP地址范围
  option domain-name-servers 192.168.4.7;  #分配DNS地址
  option routers 192.168.4.254;    #网关地址
  default-lease-time 600;
  max-lease-time 7200;
 }
3.重启服务
[root@svr7 /]# systemctl restart dhcpd

#################################################
网络装机概述

网络装机的优势
• 规模化:同时装配多台主机
• 自动化:装系统、配置各种服务
• 远程实现:不需要光盘、U盘等物理安装介质

什么是PXE网络
• PXE,Pre-boot eXecution Environment
– 预启动执行环境,在操作系统之前运行
– 可用于远程安装

• 工作模式
– PXE client 集成在网卡的启动芯片中
– 当计算机引导时,从网卡芯片中把PXE client调入内存
执行,获取PXE server配置、显示菜单,根据用户选
择将远程引导程序下载到本机运行


PXE组件及过程分析
• 需要哪些服务组件?
– DHCP服务,分配IP地址、定位引导程序
– TFTP服务,提供引导程序下载
– HTTP服务(或FTP/NFS),提供yum安装源

• 客户机应具备的条件
– 网卡芯片必须支持PXE协议
– 主板支持从网卡启动
##################################################
一 构建DHCP服务,指定tftp服务器地址以及网卡引导文件名称
[root@svr7 /]# vim /etc/dhcp/dhcpd.conf 
subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.100 192.168.4.200;
  option domain-name-servers 192.168.4.7;
  option routers 192.168.4.254;
  default-lease-time 600;
  max-lease-time 7200;
  next-server  192.168.4.7;  #指定下一个服务器tftp服务器地址
  filename  "pxelinux.0";    #指定网卡引导文件名称
}
[root@svr7 /]# systemctl restart dhcpd

 pxelinux.0:网卡引导文件(网络装机说明书) 二进制文件
                     安装一个软件即可获得该文件
#####################################################
二  构建tftp服务,提供众多的引导文件                 
    
     tftp:简单的文件传输协议   默认端口 69
         默认共享路径:/var/lib/tftpboot/

1.安装软件tftp-server
[root@svr7 /]# yum -y install tftp-server
[root@svr7 /]# systemctl restart tftp

2.部署pxelinux.0文件
]# yum provides */pxelinux.0  #查询那个软件包产生该文件
]# yum -y install syslinux
]# rpm -ql syslinux | grep pxelinux.0  #查询软件安装清单

]# cp /usr/share/syslinux/pxelinux.0  /var/lib/tftpboot/  #默认共享路径:/var/lib/tftpboot/
]# ls /var/lib/tftpboot/
 

 pxelinux.0-->读取菜单文件 
              /var/lib/tftpboot/pxelinux.cfg/default

3.部署菜单文件
]# poweroff   #关闭机器,图形添加光驱设备,放入光盘文件
]# mount /dev/cdrom  /mnt/
]# ls /mnt/

]# mkdir /var/lib/tftpboot/pxelinux.cfg
]# cp /mnt/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default

]# ls /var/lib/tftpboot/

]# ls /var/lib/tftpboot/pxelinux.cfg/

4.部署图形模块与背景图片
  vesamenu.c32(图形模块)
  splash.png(背景图片)

[root@svr7 ~]# cp /mnt/isolinux/vesamenu.c32 /mnt/isolinux/splash.png /var/lib/tftpboot/

[root@svr7 ~]# ls /var/lib/tftpboot/
pxelinux.0  pxelinux.cfg  splash.png  vesamenu.c32

5.部署启动内核与驱动程序
  vmlinuz(启动内核)
  initrd.img(驱动程序)

[root@svr7 ~]# cp /mnt/isolinux/vmlinuz /mnt/isolinux/initrd.img /var/lib/tftpboot/

[root@svr7 ~]# ls /var/lib/tftpboot/
initrd.img  pxelinux.cfg  vesamenu.c32
pxelinux.0  splash.png    vmlinuz

6.修改菜单文件
]# vim  /var/lib/tftpboot/pxelinux.cfg/default
     末行模式 开启行号  :set nu

  1 default vesamenu.c32   #默认加载图形的模块
  2 timeout 600            #读秒时间   1/10秒

  10 menu background splash.png  #背景图片
  11 menu title NSD1906 PXE Server   #标题

 61 label linux
 62   menu label ^Install CentOS 7   #菜单的显示内容
 63   menu default         #读秒结束后默认选择
 64   kernel vmlinuz       #加载启动内核
 65   append initrd=initrd.img   #加载驱动程序
##################################################
总结:
   1.DHCP---> IP地址  next-server filename   
   2.tftp---> pxelinux.0
   3.pxelinux.0---> 访问菜单文件
                 /var/lib/tftpboot/pxelinux.cfg/default
   4.default--->图形的模块  背景图片  启动内核  驱动程序

测试验证:
[root@svr7 ~]# systemctl restart dhcpd
[root@svr7 ~]# systemctl restart tftp

创建一台新的虚拟机进行测试验证
  1.安装方式: 网络引导安装(PXE)
  2.内存需要: 2048M
  3.网络类型:  private1
####################################################
构建Web服务器,共享众多的软件包

1.安装软件包
[root@svr7 ~]# yum -y install httpd
2.重启httpd服务
[root@svr7 ~]# systemctl  restart httpd
3.挂载光驱设备
[root@svr7 ~]# mkdir /var/www/html/centos
[root@svr7 ~]# mount /dev/cdrom  /var/www/html/centos
mount: /dev/sr0 写保护，将以只读方式挂载
[root@svr7 ~]# ls /var/www/html/centos
[root@svr7 ~]# systemctl restart httpd

[root@svr7 ~]# firefox 192.168.4.7/centos
###################################################
实现无人值守安装,生成应答文件

1.安装可以生成应答文件的软件包
[root@svr7 ~]# yum -y install system-config-kickstart 

2.运行system-config-kickstart          
]# LANG=en  system-config-kickstart  #英文进行运行
点击 "软件包选择(Package Selection)" 查看是否可以进行选择
需要Yum仓库的支持:指向光盘的内容仓库,标识必须为[development]

[root@svr7 ~]# vim /etc/yum.repos.d/local.repo 
[development]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804
enabled=1
gpgcheck=0

[root@svr7 ~]# LANG=en  system-config-kickstart
 点击 "软件包选择(Package Selection)" 查看是否可以进行选择

[root@svr7 ~]# ls /root/ks.cfg 
/root/ks.cfg
[root@svr7 ~]# vim /root/ks.cfg 

3.利用Web服务器将ks.cfg进行共享
[root@svr7 ~]# cp /root/ks.cfg  /var/www/html/
[root@svr7 ~]# ls /var/www/html/

4.修改菜单文件,指定应答文件位置
]# vim /var/lib/tftpboot/pxelinux.cfg/default 
label linux
  menu label ^Install CentOS 7
  menu default
  kernel vmlinuz
  append 
initrd=initrd.img ks=http://192.168.4.7/ks.cfg

###################################################

             date 6


客户端:开机启动,引导项
  1.本机磁盘  2.光驱设备  3.U盘   4.网卡进行网络安装
##################################################
rsync同步操作

rsync同步操作
• 命令用法
– rsync [选项...] 源目录 目标目录
• 同步与复制的差异
– 复制:完全拷贝源到目标
– 同步:增量拷贝,只传输变化过的数据


同步控制
• rsync操作选项
– -n:测试同步过程,不做实际修改
– --delete:删除目标文件夹内多余的文档
– -a:归档模式,相当于-rlptgoD
– -v:显示详细操作信息
– -z:传输过程中启用压缩/解压

[root@svr7 ~]# rsync -a /boot /todir  //同步整个文件夹
[root@svr7 ~]# rsync -a /boot/ /todir/ //只同步目录下的数据


[root@svr7 ~]# mkdir /nsd19
[root@svr7 ~]# mkdir /todir
[root@svr7 ~]# cp /etc/passwd /nsd19
[root@svr7 ~]# touch /nsd19/1.txt
[root@svr7 ~]# ls /nsd19/
[root@svr7 ~]# rsync -av  /nsd19   /todir/  #同步目录本身
[root@svr7 ~]# ls /todir/
[root@svr7 ~]# rsync -av  /nsd19/   /todir/ #同步目录内容
[root@svr7 ~]# ls /todir/

[root@svr7 ~]# echo haha >> /nsd19/1.txt 
[root@svr7 ~]# cat /nsd19/1.txt
[root@svr7 ~]# rsync -av /nsd19/   /todir/
[root@svr7 ~]# cat /todir/1.txt 


                                                             

[root@svr7 ~]# rsync -av --delete  /nsd19/  /todir/   #清空目标目录/todir/其它内容并同步目录/nsd19/内容
[root@svr7 ~]# ls /todir/

[root@svr7 ~]# touch	 /todir/{1..5}.txt
[root@svr7 ~]# ls /todir/
[root@svr7 ~]# rsync -av --delete  /nsd19/  /todir/
[root@svr7 ~]# ls /todir/

[root@svr7 ~]# touch	 /todir/nsd{1..5}.txt
[root@svr7 ~]# ls /todir/
[root@svr7 ~]# touch	 /nsd19/abc{1..5}.txt
[root@svr7 ~]# ls /nsd19/
[root@svr7 ~]# rsync -av --delete  /nsd19/  /todir/   
[root@svr7 ~]# ls /todir/
####################################################
远程同步(rsync+SSH同步)

• 与远程的 SSH目录保持同步
– 下行:rsync [...] user@host:远程目录      本地目录
– 上行:rsync [...] 本地目录      user@host:远程目录

虚拟机A的/nsd19/目录与虚拟机B的/opt/进行同步

虚拟机A:
]# rsync -av --delete /nsd19/  root@192.168.4.207:/opt/

虚拟机B:
]# ls  /opt
###################################################
实时远程同步

一 虚拟机A通过公钥(id_rsa.pub) 私钥(id_rsa) ,实现ssh无密码验证
[root@svr7 ~]# ssh-keygen  #一路回车       //交互式不适于脚本
或
]# ssh-keygen -f /root/.ssh/id_rsa -N ''  //非交互式传秘钥,-f 秘钥文件路径,-N 密码

[root@svr7 ~]# ls /root/.ssh/

[root@svr7 ~]# ssh-copy-id root@192.168.4.207

]# rsync -av --delete /nsd19/  root@192.168.4.207:/opt/

 拥有私钥的机器,可以无密码登录拥有公钥的机器


二  监控/nsd19目录变化

• Linux内核的 inotify 机制
– 提供事件响应式的文件系统通知机制
– 安装 inotify-tools 控制工具可调用此机制实现监控

真机上:
[student@room9pc01 ~]$ scp /linux-soft/01/tools.tar.gz  root@192.168.4.7:/root/

1.虚拟机A找到该软件
[root@svr7 ~]# tar -xf  /root/tools.ta
步骤四:maker.gz -C  /
[root@svr7 ~]# ls /tools/
inotify-tools-3.13.tar.gz  other

2.安装gcc与make
[root@svr7 ~]# yum -y install gcc  make 

3.解包
[root@svr7 ~]# tar -xf /tools/inotify-tools-3.13.tar.gz    -C  /opt

4.运行configure脚本进行配置检测
]# cd /opt/inotify-tools-3.13/
]# ./configure 
5.运行make进行编译
]# make
6,进行make  install 进行安装
]# make install
]# ls /usr/local/bin/inotifywait   #验证是否有运行程序
/usr/local/bin/inotifywait



• 基本用法
– inotifywait [选项] 目标文件夹
• 常用命令选项
– -m,持续监控(捕获一个事件后不退出)
– -r,递归监控、包括子目录及文件
– -q,减少屏幕输出信息
– -e,指定监视的modify、move、create、delete、attrib等事件类别




书写同步的脚本rsync.sh
     循环:for循环适合写有次数的循环 
     死循环:while循环适合无限次数的循环 

 格式:     
       while [条件]
	   do
               重复的代码
	   done


虚拟机A:
[root@svr7 /]# vim /root/rsync.sh
 #!/bin/bash
 while  inotifywait -rqq /nsd19/
 do
  rsync -a --delete /nsd19/  root@192.168.4.207:/opt/
 done
[root@svr7 /]# chmod  +x  /root/rsync.sh
[root@svr7 /]# /root/rsync.sh &
[1] 8297
[root@svr7 /]# jobs -l
[root@svr7 /]# 

################################################

Cobbler装机平台,不同版本的多系统的安装

手动安装有图形环境的虚拟机cobbler
  		1.操作系统为:CentOS 7.5
  		2.内存大小:2G  
  		3.磁盘空间:20G
  		4.虚拟机网络类型为:private1
		5.软件包选择 "带GUI的服务器"
		6.分区选择 "自动分区"
		7.管理员root密码为 1
		8.创建普通用户lisi



####################################################
一  具备一个CentOS虚拟机  
[root@svr7 ~]# cat /etc/redhat-release 
CentOS Linux release 7.5.1804 (Core) 
                                     
二、虚拟机设置                                       
   1.设置防火墙为trusted                           
  ]# firewall-cmd  --set-default-zone=trusted 
   2.当前及永久设置SELinux状态为permissive
  ]# setenforce 0     #当前为宽松模式
  ]# getenforce       #查看当前SELinux的状态
  ]# vim  /etc/selinux/config 
  SELINUX=permissive
  3.配置IP地址为:192.168.4.123/24
  4.配置主机名:cobbler.tedu.cn
  5.构建Yum仓库:以真机FTP服务器作为Yum源
 ]# cd /etc/yum.repos.d/
 ]# mkdir repo
 ]# mv *.repo  repo
 ]# ls
 ]# vim dvd.repo
 [dvd]
 name=dvd
 baseurl=ftp://192.168.4.254/centos-1804
 enabled=1
 gpgcheck=0

##################################################

三、利用scp真机传递cobbler.zip包到虚拟机192.168.4.123中
 # scp /home/student/桌面/cobbler.zip   root@192.168.4.123:/root/
 
##################################################

四、搭建Cobbler装机平台

  Cobbler概述软件，管理dhcp、tftp、Web服务
    自由的导入镜像与ks应答文件

1.解压cobbler.zip包
]# yum -y install unzip 

]# unzip /root/cobbler.zip -d /
]# ls /cobbler/
cobbler_boot.tar.gz  cobbler_web.png
cobbler_rpm.zip

]# unzip /cobbler/cobbler_rpm.zip -d /opt/
]# ls /opt/cobbler/


#####################################################
五、安装cobbler主程序、工具包等
]# yum -y install  dhcp  httpd  mod_ssl 
]# yum -y install  /opt/cobbler/*.rpm  
]# rpm -q cobbler
cobbler-2.8.2-1.el7.x86_64


################################################################
cobbler网络装机部署
1.安装软件 cobbler cobbler-web dhcp tftp-server pykickstart httpd  

 cobbler         #cobbler程序包
 cobbler-web     #cobbler的web服务包
 pykickstart     #cobbler检查kickstart语法错误
 httpd           #Apache web服务
 dhcp            #dhcp服务
 tftp-server     #tftp服务

2.配置cobbler
[root@svr7 /]# vim  /etc/cobbler/settings

 next_server:   192.168.4.123   #设置下一个服务器还为本机
 server:   192.168.4.123        #设置本机为cobbler服务器
 manage_dhcp:   1               #设置cobbler管理dhcp服务
 pxe_just_once:   1             #防止客户端重复安装操作系统

 开机启动项： 匹配及停止  
     1.硬盘启动     2.光驱设备     3.U盘     4.网络引导  

3.配置cobbler的dhcp
[root@svr7 /]# vim  /etc/cobbler/dhcp.template 

  :%s  /旧/新/g      #全文替换
  :%s  /192.168.1/192.168.4/g    #全文替换

    5 次替换，共 4 行   


4.绝对路径解压cobbler_boot.tar.gz    #众多的引导文件
# tar -tf  /cobbler/cobbler_boot.tar.gz   #查看包里面内容
# tar -xPf  /cobbler/cobbler_boot.tar.gz  #绝对路径释放

# ls  /var/lib/cobbler/loaders/
COPYING.elilo     grub-x86_64.efi  README
COPYING.syslinux  grub-x86.efi     yaboot
COPYING.yaboot    menu.c32
elilo-ia64.efi    pxelinux.0


5.启动相关服务
  ]# systemctl restart cobblerd     
  ]# systemctl enable cobblerd

  ]# systemctl restart httpd
  ]# systemctl enable httpd

  ]# systemctl restart tftp
  ]# systemctl enable tftp

  ]# systemctl restart rsyncd   #同步服务
  ]# systemctl enable rsyncd


6.同步刷新cobbler配置
[root@svr7 /]# cobbler sync    #检测所有配置是否正确
......
*** TASK COMPLETE ***


]# firefox https://192.168.4.123/cobbler_web   #了解

   用户名：cobbler
   密码：cobbler                                         



##########################################################################################################
cobbler应用                 

cobbler import  --path=挂载点   --name=导入系统命名（随意起）

导入安装镜像数据
# mkdir /dvd
# mount /dev/cdrom  /dvd
# ls /dvd/

# cobbler import --path=/dvd  --name=CentOS7

cobbler导入的镜像放在：/var/www/cobbler/ks_mirror

##################################################



[root@cobbler /]# cobbler list    #查看有哪些系统
distros:
   CentOS7-x86_64        #安装客户端至少2G内存

profiles:
   CentOS7-x86_64

##############################################
删除
# cobbler list 
# cobbler profile remove --name=CentOS7-x86_64  #删除菜单信息
# cobbler distro remove --name=CentOS7-x86_64  #删除镜像信息


###########################################

# umount /dvd/
# mount /dev/cdrom  /dvd   #将光盘换成RHEL7
# ls /dvd/

  安装完成机器 默认root  密码  cobbler

############################################################################################################
自定义应答文件：开头注释行删除

[root@cobbler ~]# system-config-kickstart  #生成ks文件

必须默认kickstart文件存放位置：/var/lib/cobbler/kickstarts/

[root@cobbler ~]# cobbler list

修改kickstart文件：
[root@cobbler ~]# cobbler profile edit --name=CentOS7  --kickstart=/var/lib/cobbler/kickstarts/自定义.cfg

[root@cobbler ~]# cobbler profile report
[root@cobbler ~]# cobbler sync  #同步配置

############################################################################################################
环境变量PATH

   PATH:存放执行命令程序的搜寻路径
[root@cobbler /]# echo $PATH
[root@cobbler /]# vim /opt/hello.sh
#!/bin/bash
echo hello
[root@cobbler /]# chmod +x /opt/hello.sh
[root@cobbler /]# /opt/hello.sh
[root@cobbler /]# hello.sh #允许失败

[root@cobbler /]# cp /opt/hello.sh /usr/bin
[root@cobbler /]# hello.sh 

[root@cobbler /]# cd /root/
[root@cobbler ~]# hello.sh 

[root@cobbler ~]# cd /tmp/
[root@cobbler tmp]# hello.sh 
#################################################
权限的掩码 umask值 与目录默认权限有关

[root@cobbler /]# umask 
0022
[root@cobbler /]# umask 077
[root@cobbler /]# umask 
0077
[root@cobbler /]# mkdir /opt/nsd02
[root@cobbler /]# ls -ld /opt/nsd02

[root@cobbler /]# umask 022
[root@cobbler /]# mkdir /opt/nsd05
[root@cobbler /]# ls -ld /opt/nsd05

#############################################
#############################################
       network

date 1
  
DOD：国防部

ARPA：高级研究项目署  -> ARPAnet



Modem：猫 调制解调器   56kbps   => 7kB/s  ＝》 拨号上网

描述速率的时候，用的都是bit，电脑上描述文件大小都是字节byte

1byte = 8 bit

ISDN：超级一线通，综合业务数字网

## 网络分类

### 按地域范围分类

- 局域网：LAN
- 广域网：WAN
- 城域网：MAN

### 按技术划分

- 对等网：网络中主机具有相同角色
- C/S：客户机/服务器
- B/S：浏览器/服务器

### 按安全划分

- intranet：内部网络
- extranet：外部网络
- Internet：国际互联网



巨大中华：巨龙集团、大唐电讯、中兴、华为

中华酷联：中兴、华为、酷派、联想

## 网络拓扑结构

- 星型：重要、常用的结构
- 点到点：互联网上有应用，LAN几乎没有
- 总线型：几乎没有
- 网状：几乎没有

## OSI参考模型 

- OSI：开放系统互联 参考模型。ISO制定
  - 自下向上是第一至第七层
  - 物理层：一层
  - 数据链路层：MAC地址、交换机
  - 网络层：IP地址、路由器
  - 传输层：TCP、UDP协议、端口号
  - 会话层
  - 表示层
  - 应用层：七层

印表会传往树屋

## TCP/IP参考模型 

- 共五层（四层）：前四层与OSI参考模型一样，OSI高三层合并为一个应用层

点到点：IP到IP

端到端：应用到应用

## 数据通信过程

1. 应用层程序准备好数据
2. 表示层负责将数据转换格式
3. 会话层负责建立会话连接，不是所有应用都有此步骤
4. 传输层负责把数据切分成一个个的片段，称作数据段segment。每个数据段加上编号，称作序列号。还需要指定使用的是TCP或UDP协议，以及端口号。
5. 网络层负责给数据加上IP地址，打成数据包package。
6. 数据链路层负责给数据加上MAC地址，打成数据帧frame。
7. 物理层将数据转换成二制的0和1，称作比特（流），在物理介质上传输。
8. 发送方，数据自上向下总是增加头部内容，称作封装过程。
9. 接收方，数据自下向上将发送方加入的头部移除，称作解封装过程。

## 华为设备

- 接口
  - console：控制台接口，连接控制线缆到PC机。相当于是为设备提供键盘、鼠标、显示器。
  - FastEthernet：快速以太网接口，速率100Mbps
  - GigabitEthernet：吉比特接口，速度1000Mbps

- 交换机配置
  - 命令需要在不同的模式下执行，不同模式有不同的指令
    - 用户视图：只能执行一些基本的查询指令：<主机名>
    - 系统视图：可以执行管理命令：[主机名]
    - 接口视图：只对某一接口生效的指令在这里执行：[主机名-接口]
    - 协议视图：配置相关协议时使用的视图：[主机名-协议]

```shell
<Huawei>?    # 显示该模式下所有的命令
<Huawei>l?   # 显示所有的以l开头的命令
<Huawei>la<tab>    # 因为以la开头的命令只有一条，所以此时按tab可补全
<Huawei>language-mode Chinese   # 改变为中文提示
<Huawei>system-view  # 进入系统视图
[Huawei]sysname sw1   # 修改主机名为sw1
# 在华为设备上，任何与显示相关的命令，都以display开头
[sw1]display interface brief  # 显示所有端口的简要信息
[sw1]int g0/0/1   # 进入接口
[sw1-GigabitEthernet0/0/1]quit   # 返回一步
[sw1-GigabitEthernet0/0/1]return  # 直接返回到用户视图
[sw1-GigabitEthernet0/0/1]ctrl+z  # 按组合键也会返回到用户视图
```

翻译软件：搜狗搜译。

## 交换机常用命令

```shell
# 华为操作系统名为VRP，即多样化路由平台
<sw1>display version   # 查看设备的软件版本号和运行时间
<sw1>display current-configuration  # 查看设备当前的生效配置

# 配置密码
# AAA模式，认证模式
# Athentication：认证，你是谁
# Athorization：授权，你能干什么
# Audit：审计，你干了什么
<sw1>system-view
[sw1]aaa
[sw1-aaa]local-user 用户名 password cipher 密码   # 设置加密密码
[sw1-aaa]quit
[sw1]user-interface console 0     # 进入控制台接口模式
[sw1-ui-console0]authentication-mode aaa   # 配置使用AAA认证
# 退出到最外面，再次回车，进入用户视图就需要用户名和密码了

<sw1>save   # 系统提示将会把系统原有配置覆盖，是否要继续，选择y，系统再次提示文件名，直接回车，采用默认的名字即可
<sw>reboot  # 重启


<sw1>reset saved-configuration   # 擦除保存的配置，系统提示，是否真的擦除，回答y。注意，擦除的是已保存的配置，不是当前内存中生效的配置。重启后，才会恢复到最初状态。
<sw1>reboot  # 系统首先比较内存中配置与保存的配置是否一致，发现不一致，提示是否要把当前配置保存，此时回答：n。系统再次提示，是否要继续重启，回答y
```

## 其他命令行小技巧

```shell
# 配置设备没有控制台超时时间，相当于配置主机、手机锁屏前的等待时间
[sw1]user-interface console 0
[sw1-ui-console0]idle-timeout 分钟数

```

## 交换机工作原理

- MAC地址：MAC是介质访问控制。
  - MAC地址也叫物理地址，因为设备在生产的时候，MAC地址已经烧到印制电路版中了
  - 网卡有MAC地址，交换机、路由器每个端口也有MAC地址
  - MAC地址共48位（48个2进制数）、6字节。
  - 表示的时候，往往是把2进制转换成16进制进行表示，每两个16进制数之间用冒号或减号分隔。一共是5个冒号或分号隔开6段。
  - MAC地址前24位是厂商的组织唯一标识符，即OUI；后24位厂商自行决定

```shell
# 2进制与16进制的转换：4位2进制转换成一个16进制数
0000 -> 0
0001 -> 1
0010 -> 2
0011 -> 3
0100 -> 4
0101 -> 5
0110 -> 6
0111 -> 7
1000 -> 8
1001 -> 9
1010 -> A
1011 -> B
1100 -> C
1101 -> D
1110 -> E
1111 -> F
```

- 交换机的工作原理
  - 交换机内部有一张MAC地址表，记录了每个端口连接设备的MAC地址
  - MAC地址表在开机的时候是空的，它要动态学习每个端口所连设备的MAC地址
  - 当某一终端发送数据帧到交换机时，交换机根据数据帧的源MAC地址构建MAC地址表
  - 交换机根据数据帧的目标MAC地址发送数据到指定端口
  - 如果交换机在MAC地址表中找不到目标MAC地址连在自己的哪个端口上，将会把数据帧向除接收端口以外的所有端口发出







应用层
表示层
会话层
传输层          数据段
网络层	    数据包
数据链路层   数据帧
物理层 	    比特流

  应表会传往树屋

视图
用户视图 保存
系统视图 
接口视图
协议视图

ctrl+z 等于 return


[Huawei]sysname SW1     //修改主机名
[Huawei]display version     //查看软硬件版本
[Huawei]display current-configuration    //查看正在运行的配置,按空格翻页

aaa模式,负责授权认证审计,可以在此模式创建账户和密码
  [HuaWei-aaa]local-user admin01 password cipher 123 //创建账户和密码 cipher/simple(加密/不加密)
  [HuaWei-aaa]quit
  [HuaWei]user-interface console 0           //进入控制台视图
   [huawei-ui-console0]authentication-mode aaa   //激活配置
    
ctrl + ]   彻底退出系统

<Huawei>save      //保存设置
<Huawei>reboot        //重启设备

<Huawei>reset saved-configuration  //重置配置文件(恢复出厂)
<Huawei>reboot        //重启设备

ip 
mac 硬件地址  物理地址 ,全球唯一不重复  48bit


0123456789ABCDEF

关闭各种信息提示(控制台超时后失效)
undo terminal debugging
undo terminal monitor 
undo terminal logging 
undo terminal trapping 

设置控制台永不超时
sys
user-interface console 0
idle-timeout 0
#####################################################################
date 2

网络的功能
信息传递  资源共享  提高可靠 增加系统处理性能

60年代  分组交换
70~80  tcp/ip
90年代   web技术

拓扑结构
点对点  wan
星形  lan   
网状  lan  

osi七层参考模型
tcp/ip五层参考模型

应用层    
传输层  防火墙
网络层  路由器
数据链路层  交换机
物理层  网卡

用户视图
系统视图
接口视图
协议视图

交换机工作原理
学习,广播,转发,更新

广播泛滥

广播域
vlan  虚拟局域网 
virtual 
控制广播
增加安全
提高带宽的利用率
降低数据传递的延迟
50~60ms   100ms
20ms
1s=1000ms

vlan 最大数量4096个

vlan1  默认vlan,无需创建,不能删除

1, 创建vlan
进入系统视图  
vlan 2		//创建vlan2
undo vlan 2   //删除vlan 2
2, 将接口加入相关vlan  
in e0/0/3    //进入接口3
port link-type access    //接口类型更改为接入,表示即将为某一个vlan传输数据
port default vlan 2   //修改接口服务的vlan

display vlan   查看vlan列表验证之前的操作

vlan batch 10 20 30    
undo vlan batch 10 20 30

[Huawei]vlan batch 2 3			//创建VLAN2、3
[Huawei]port-group 1    //建组,组号是1
[Huawei-port-group-1]group-member Ethernet0/0/3 Ethernet0/0/4    //组中加入3口和4口
[Huawei-port-group-1]port link-type access   //在组1中所敲的命令,等于对该组中所有接口敲
[Huawei-port-group-1]port default vlan 2		

网段
vlan1
192.168.1.1
192.168.1.2
vlan2
192.168.2.1
192.168.2.2
vlan3
192.168.3.1
192.168.3.2


access 接入链路  承载1个vlan
trunk  中继链路  承载多个vlan  打vlan标记

in e0/0/7
port default vlan 1    //恢复默认vlan
port link-type trunk    //修改为中继链路
port trunk allow-pass vlan all    //允许通过所有vlan

链路聚合,增加可靠,增加带宽

进入系统视图
clear configuration interface ethernet0/0/7    //清空所有配置,恢复默认,此时接口会自动关闭
[Huawei]interface ethernet0/0/7
undo shutdown     //打开接口

[Huawei]interface Eth-trunk 1   //进入(创建)链路聚合接口1
[Huawei- Eth-trunk1]trunkport e 0/0/7  0/0/8  //捆绑7口和8口,此步骤如果接口不是默认状态,会提示报错,要求恢复默认.
port link-type trunk    //将链路聚合接口修改为中继链路
port trunk allow-pass vlan all    //放行所有vlan


网络层	   路由器   ip
数据链路层  交换机   mac

不同部门=不同vlan=不同网段=不同广播域

2的n次方-2

A  1~127       1677万+
255.0.0.0
B  128~191     65534
255.255.0.0
C  192~223     254
255.255.255.0

192.168.0.1~192.168.0.254
每个网段第一个地址是网络id,最后一个地址是广播地址

192.168.0.1

172.16.0.0     172.16.255.255
172.16.0.1~172.16.255.254

icmp 英特网控制报文协议  可以查询网络状态并反馈相应数据

undo ip add   进入接口,删除ip
在接口中使用 display this 查看配置的ip地址

路由表
直连路由  路由器接口配置ip,并开启之后自动产生
静态路由  由管理员手工配置,小规模网络适用

R1
ip route-static 192.168.3.0 24 192.168.2.2
ip route-static 192.168.4.0 24 192.168.2.2

R2
undo ip route-static 192.168.1.0 24 192.168.2.3
ip route-static 192.168.1.0 24 192.168.2.1

display ip routing-table | include /24    查看路由表包含/24的行

????????????????????????????????????????????????????????????????????????????????????????????????
 day02(2)

## 网络的通信类型

- 单播unicast：一对一
- 多播，也叫组播multicast：一对部分
- 广播broadcast：一对所有
- 在ipv6中，没有广播了，增加的是任播anycast。任播地址与单播地址一样，只不过这个地址配置在了多个节点上。

## 广播域

- 设备发出广播后，能够接收到广播的所有设备的集合是一个广播域。

- 没有任何配置的情况下，多台交换机连接起来，也是处于一个广播域。
- 交换机会将以下数据帧向所有端口发送
  - 广播
  - 组播
  - 未知地址的单播

## VLAN：虚拟局域网

- 最主要的作用是划分广播域，实现广播控制

### VLAN配置

- 创建VLAN：每个VLAN都有一个ID号，还可以添加可选的名字
- 将端口划分到VLAN

```shell
# 查看VLAN信息，默认所有端口都在vlan1中
<Huawei>system-view
[Huawei]display vlan  # 查看VLAN

# 创建一个VLAN
[Huawei]vlan 10    # VLAN id号范围是1-4094
[Huawei-vlan10]description ops   # VLAN10是运维部VLAN
[Huawei-vlan10]display this  # 查看当前模式下有哪些配置

# 批量创建VLAN
[Huawei]vlan batch 15 20   # 创建两个VLAN
[Huawei]vlan batch 21 to 25  # 创建5个VLAN
[Huawei]display vlan

# 删除VLAN：在创建VLAN的命令前加undo
[Huawei]undo vlan 20
[Huawei]undo vlan batch 15 21
[Huawei]undo vlan batch 22 to 25
```

端口类型

- 接入端口：接入端口仅属于一个VLAN
- 中继端口：不属于任何VLAN，但是可以承载所有VLAN的数据

```shell
[Huawei]int g0/0/1
[Huawei-GigabitEthernet0/0/1]port link-type access  # 设置端口类型
[Huawei-GigabitEthernet0/0/1]port default vlan 10   # 加入vlan10
[Huawei-GigabitEthernet0/0/1]display this

# 批量将端口加入VLAN
[Huawei]port-group 1   # 创建端口组，组号为1
[Huawei-port-group-1]group-member g0/0/5 g0/0/8  # 将不连续端口加入组
[Huawei-port-group-1]group-member g0/0/11 to g0/0/15 # 将连续端口加入组
[Huawei-port-group-1]port link-type access
[Huawei-port-group-1]port default vlan 10
[Huawei]display vlan
```

综合练习：

- 两台交换机sw1和sw2
- sw1:
  - vlan1: g0/0/1 - g0/0/2     pc1: 192.168.1.10  pc2: 192.168.1.20
  - vlan2: g0/0/3 - g0/0/4     pc3: 192.168.2.10  pc4: 192.168.2.20
  - vlan3: g0/0/5 - g0/0/6     pc5: 192.168.3.10  pc6: 192.168.3.20
  - g0/0/24 连接 sw2 g0/0/24
- sw2:
  - vlan1: g0/0/1 - g0/0/2     pc7: 192.168.1.70  pc8: 192.168.1.80
  - vlan2: g0/0/3 - g0/0/4     pc9: 192.168.2.90  pc10: 192.168.2.100
  - vlan3: g0/0/5 - g0/0/6     pc11: 192.168.3.110  pc12: 192.168.3.120
  - g0/0/24 连接 sw1 g0/0/24

### 设备网络参数

- IP地址：设备的地址
- 子网掩码：判断地址属于哪个网络
- 网关：数据包发出自己网络必须经过的地址

网络通信：A设备与B设备通，A先判断B与自己是不是在同一网络，如果是则直接发送；如果不是，则发往网关。

## Trunk中继

- 中继链路主要用在交换机之间
- 中继链路不属于任何VLAN，但是允许所有VLAN的数据通过

```shell
# 配置中继，两个步骤。注意，链路两端的交换机端口都需要配置
# 1. 将端口设置为中继模式
[sw1]int g0/0/24
[sw1-GigabitEthernet0/0/24]port link-type trunk

# 2. 设置中继端口允许哪些VLAN的数据通过
[sw1-GigabitEthernet0/0/24]port trunk all-pass vlan all
```

## 链路聚合

- 交换机之间可以连接多条链路
- 将多条链路捆绑成一个逻辑端口，以提供更大的带宽，同时可以实现容错
- 注意
  - 参与捆绑的所有端口需要有一致的物理状态，如都是1000Mb/s
  - 参与捆绑的所有端口要么同属于同一VLAN，要么都是中继

```shell
# 1. 清除参与捆绑端口的配置
[sw1]clear configuration interface GigabitEthernet 0/0/23
[sw1]clear configuration interface GigabitEthernet 0/0/24
# 2. 创建名为Eth-Trunk 0的逻辑端口
[sw1]interface Eth-Trunk 0
# 3. 把物理端口加入到逻辑端口中
[sw1-Eth-Trunk0]trukport GigabitEthernet 0/0/23 0/0/24
# 4. 配置逻辑端口为中继状态
[sw1-Eth-Trunk0]port link-type trunk
[sw1-Eth-Trunk0]port trunk allow-pass vlan all
# 5. 将物理端口启用
[sw1]interface GigabitEthernet 0/0/23
[sw1－GigabitEthernet0/0/23]undo shutdown
[sw1]interface GigabitEthernet 0/0/24
[sw1－GigabitEthernet0/0/24]undo shutdown
# 6. 查看
[sw1]display vlan
[sw1]display interface Eth-Trunk 0
[sw1]display current-configuration
```

## 网络层

- IP地址：32位2进制数。
  - 私有地址
    - 10.0.0.0/8
    - 172.16.0.0 - 172.31.0.0/16
    - 192.168.0.0 - 192.168.255.0/24
- 路由器：
  - 路由：路径
  - 路由器：负责路径选择的设备

- ARP：地址解析协议
  - 三层需要IP地址
  - 二层需要MAC地址
  - ARP协议用于将IP地址解析为MAC地址

### 路由器工作原理

- 路由器负责将不同的网络连接起来；交换机连接的是相同网络
- 路由器是三层设备，它的每个端口都有IP地址
- 路由器收到数据包后，根据自己的路由表做出转发决定
- 如果目的地不在路由表中，则将数据包丢弃
- 路由器不允许广播通过
- 路由表的形成可以是管理员手工配置静态路由；也可以通过路由协议自动学习
- 路由表中保存的是最优路径，而不是全部路径

```shell
[R1]display interface brief  # 查看端口简要信息
[R1]display ip routing-table  # 查看路由表
[R1]int g0/0/0
[R1-GigabitEthernet 0/0/0]ip address 192.168.1.1 24  # 配置IP地址
[R1]display ip routing-table  # 配置IP地址后，路由表中将出现直连路由
[R1]ip route-static 目标网络 目标掩码 下一跳地址
[R1]ip route-static 192.168.3.0 24 192.168.2.2

# 缺省路由，也叫默认路由。不管目标是哪，下一跳一样，采用默认路由
[R1]ip route-static 0.0.0.0 0 下一跳
[R1]ip route-static 0.0.0.0 0 192.168.2.2
```










####################################################################

      day 3


 交换机   二层
vlan
控制广播,增加安全,带宽利用率提高,降低数据传递的延迟

路由器 实现不同网段的链接 ,在物理接口配置ip

三层交换机=二层交换+三层路由 ,在虚拟接口配置ip
使用三层交换机搭建网络:

1,三层交换机创建vlan 2 3
   vlan batch 2 3
2,将接口加入对应vlan
in g0/0/2
port link-type access
port default vlan 2
dis vlan
3,进入vlan接口(虚拟接口)配置ip地址,此ip将作为
终端设备的网关
in vlan 1
ip add 192.168.1.254 24

dis cur

添加S3700交换机, 达到更合理利用三层交换机的目的

1,在S3700创建vlan2 3
2,在S3700将pc所链接的接口加入相应vlan
3,将2台交换机之间的链路配置为中继链路
port link-type trunk
port trunk allow-pass vlan all

排错
1,查ip,网关
2,所属vlan
3,测试与网关的链接

网段 , vlan

为三层交换机接口配置ip的思路:

1,S5700创建vlan4
2,进入vlan4虚拟接口配置ip
in vlan 4
ip add 192.168.4.1 24
3,将g0/0/2口加入vlan4

动态路由 是由某种动态路由协议实现全网互通的目的,适用于大型网络

rip,isis,eigrp,bgp,ospf

宣告 


三层交换机配置:
ospf		//开启动态路由ospf
area 0      //进入第一个区域,一般超大型网络才需要多个区域,中小规模只使用第一个也就是0区域即可
network 192.168.1.0 0.0.0.255   //宣告设备自身所链接的网段
network 192.168.2.0 0.0.0.255
network 192.168.3.0 0.0.0.255
network 192.168.4.0 0.0.0.255
路由器:
ospf
area 0 
network 192.168.4.0 0.0.0.255
network 192.168.5.0 0.0.0.255
display ip routing-table | include /24    查看最终结果


直连路由 配置ip,并开启接口自动生成
静态路由 手工配置   192.168.1.0 24 192.168.1.X
动态路由
默认路由 是特殊的静态路由,能够匹配任意网段,当路由表中无法查询到目标网段时使用,通常用在内部设备访问公网时使用.

三层交换机
ip route-static 0.0.0.0 0 192.168.4.2    //可以匹配任意网络
路由器
ip route-static 0.0.0.0 0 192.168.5.1



传输层     端口号  端到端
网络层         路由器  ip  点到点
数据链路层  交换机 vlan trunk  mac

http  80    tcp
https 443

mysql  3306 tcp

tcp   传输控制协议
可靠性高,效率低,面向链接

syn 打算与对方建立链接
ack 确认
fin 打算与对方断开链接

三次握手  syn-->ack,syn-->ack
四次断开  fin-->ack-->   fin-->ack   (客户端要等待服务端回复fin)

udp   用户数据报协议
可靠性低,效率高,无链接

acl  访问控制列表,对匹配的数据进行限制.

基本acl  2000~2999   可以对源ip限制
高级acl  3000~3999   可以对源ip,目标ip,协议,端口限制

acl练习1:
[Huawei]interface GigabitEthernet 0/0/0
[Huawei-GigabitEthernet0/0/0] ip address  192.168.1.254 24
[Huawei]acl 2000   //创建acl,列表号是2000,表示即将使用基本acl
[Huawei-acl-basic-2000]rule deny source 192.168.2.1 0   //创建规则,拒绝源ip是192.168.2.1的数据通过
[Huawei]interface GigabitEthernet 0/0/1
[Huawei-GigabitEthernet0/0/1]ip address  192.168.2.254 24
[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 2000
   //进入g0/0/1接口后,放置acl 2000,用来过滤即将进入路由器的数据.

acl练习2:
acl 2000    //重新进入列表2000
display this   //查看
undo rule 5   //删除之前的条目,根据序号删除
rule permit source 192.168.2.1 0   //创建新条目,允许2.1通过
rule deny   //拒绝所有人通过

在同接口的同方向,只能放一条acl


date4

回顾
直连路由,静态路由,缺省(默认)路由, 0.0.0.0 0,动态路由
传输层  
tcp (面向连接) 
三次握手  syn-->ack syn-->ack
	四次断开  fin-->ack      fin-->ack
ssh 22,http 80,ftp 21,dns 53,smtp 25,https 443

udp (面向非连接)
tftp 69,dns 53,ntp 123

acl
基本 2000~2999   源ip
高级 3000~3999   源ip  目标ip  协议  端口
##############################################
使用高级acl配置网络:
[Huawei]acl 3000    
[Huawei-acl-adv-3000]rule deny tcp source 192.168.2.1 0 destination 192.168.1.1 0 destination-port eq 21   //拒绝2.1访问1.1的ftp服务

in g0/0/1
undo traffic-filter inbound    //如果有acl 2000,需要删除
traffic-filter inbound acl 3000   //在接口应用acl

[Huawei]acl 3000   
[Huawei-acl-adv-3000]rule deny tcp source 192.168.2.2 0 destination 192.168.1.1 0 destination-port eq 80   //拒绝2.2访问1.1的www服务

#############################################
NAT 网络地址转换 , 可以将内部私有地址与外部公有地址相互转换,实现内外互通的目的
优点: 节约公网ip,增加安全,处理地址重叠

ipv4   42亿
A 1~127   255.0.0.0     /8
B 128~191 255.255.0.0   /16
C 192~223 255.255.255.0 /24

私有地址范围 
A 10.0.0.0~10.255.255.255
B 172.16.0.0~172.31.255.255
C 192.168.0.0~192.168.255.255
=================================
nat常用的2种类型:
静态转换     1对1    适合服务器对外发布服务的环境   内外双方均可发起链接
easy ip  1对多   适合仅仅访问外网的需求,比如办公室环境员工上网, 只能由内向外发起数据请求
=================================
静态nat配置
[Huawei]interface GigabitEthernet 0/0/1   //进入外网接口
[Huawei-GigabitEthernet0/0/1]nat static global 100.0.0.2 inside 192.168.2.1   //配置nat实现2.1在访问外网时使用的地址是100.0.0.2
[Huawei-GigabitEthernet0/0/1]nat static global 100.0.0.3 inside 192.168.2.2   //配置nat实现2.2在访问外网时使用的地址是100.0.0.3
=================================
easy ip 配置
首先删除之前的静态nat
undo nat static global 100.0.0.2 inside 192.168.2.1
undo nat static global 100.0.0.3 inside 192.168.2.2
acl 2000    //定义acl
rule permit source any   //设置允许访问外网的主机,放行所有人
in g0/0/1    //进入外网接口
nat outbound 2000   //开启nat功能,需要配合acl列表号
#########################################
实现网关的高可用
vrrp 虚拟路由冗余协议,可以理解为网关的备份

==========================
按拓扑需求配置ip
三层交换机接口配置ip需要先创建vlan
然后进入vlan配置ip,再将对应的接口加入vlan
in g0/0/2
port link-type access
port default vlan 2

三层交换机和路由器都开启动态路由
ospf
area 0
network 192.168.1.0 0.0.0.255
network 192.168.2.0 0.0.0.255

pc2临时使用252或者253作为网关
==================================
vrrp三个角色
主路由器(master),负责转发数据 
备份路由器(backup),监视主路由器,准备随时替代
虚拟路由器,客户机的网关
===================================
配置:
in vlan 1
vrrp vrid 1 virtual-ip 192.168.1.254
dis vrrp brief  //查看vrrp信息
pc的网关修改为254
===================================
使用vrrp实现数据的负载均衡
sw1   vlan1   主    vlan2  备
sw2   vlan2   主    vlan1  备

所有交换机创建vlan2
所有链路配置为trunk,为了节约时间可以使用接口组
port-group 1    //创建1号接口组
group-member g0/0/1 to g0/0/3  //组中添加1口到3口
port link-type trunk    //为所有加入的接口配置trunk
port trunk allow-pass vlan all
注意s3700使用的是E口

########################################################

date 5

准备环境: 所有交换机创建vlan2 ,sw1与sw2分别配置不通vlan的ip地址
所有交换机之间的链路配置为中继(trunk)链路
sw1   vlan1  主    vlan2  备
sw2   vlan1  备    vlan2  主
分别进入2台s5700配置vrrp
in vlan 1
vrrp vrid 1 virtual-ip 192.168.1.254
in vlan 2
vrrp vrid 2 virtual-ip 192.168.2.254
dis vrrp brief   //查看vrrp状态
--------------------------------------------
sw1 
in vlan 1
vrrp vrid 1 priority 105   //修改sw1的vlan1中vrrp优先级
sw2
in vlan 2
vrrp vrid 2 priority 105   //修改sw2的vlan2中vrrp优先级
dis vrrp brief   //再次查看vrrp状态
=====================================
升级企业级网络:
1, 所有设备添加vlan3 vlan4,新添加的设备要创建vlan2~vlan4
相当于目前所有交换机拥有vlan 1~4
2,在网关设备添加新ip地址
3,完善全网trunk
4,完善vrrp
sw1   vlan1  主    vlan2  备     vlan3  主    vlan4  备
sw2   vlan1  备    vlan2  主     vlan3  备    vlan4  主

sw1
in vlan 3
vrrp vrid 3 virtual-ip 192.168.3.254
vrrp vrid 3 priority 105 
in vlan 4
vrrp vrid 4 virtual-ip 192.168.4.254
sw2
in vlan 3
vrrp vrid 3 virtual-ip 192.168.3.254
in vlan 4
vrrp vrid 4 virtual-ip 192.168.4.254
vrrp vrid 4 priority 105 

5,添加pc,配置ip与网关
pc1  192.168.1.1   192.168.1.254
pc2  192.168.2.1   192.168.2.254
pc3  192.168.3.1   192.168.3.254
pc4  192.168.4.1   192.168.4.254

6,为不同pc链接的交换机接口加入对应的vlan
pc1 vlan1
pc2 vlan2
pc3 vlan3
pc4 vlan4
最后效果是全网互通

7,添加连接外部网络的路由器ar2220两台
再给s5700与路由器链接的线路配置ip
	路由器接口直接配ip即可
	s5700配置ip先创建vlan

8,配置动态路由,在路由器与s5700开启ospf
并宣告自身所直连的网段

9,添加外部网络设备并配置ip

10,配置nat
	创建acl列表放行所有设备
	acl 2000
	rule permit source any
	in g0/0/2
	nat outbound 2000
11,在路由器配置默认路由,并进入ospf宣告此路由
	ip route-static 0.0.0.0 0 100.0.0.10
	[Huawei]ospf
	[Huawei-ospf-1]default-route-advertise 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                            其它内容
 1, 破解密码:
选择模式画面按“e”进入编辑模式

光标移动到linux16开头的行

在行尾输入：空格 rd.break console=tty0

按“Ctrl+x”进入救援模式

mount -o remount,rw /sysroot		#以可读写的方式重新挂载根系统

chroot /sysroot				#切换到根系统

echo "xxxxxx"  |  passwd --stdin root	#设置root密码

touch /.autorelabel			#标记下一次启动时重做SELinux标签

exit

reboot


loop:modulr loaded 


[root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward    //开启路由转发 
(linux可以做软路由充当路由器)



???????????????????????????????????????????????????????????????????????????????

                      shell 

  date 1

shell脚本
/bin/bash   默认解释器
cat /etc/shells   查看所有解释器
yum -y install ksh   安装新解释器

bash优点 
tab建,快捷键,历史记录,管道符,重定向
--------------------------------------------------------------------------
规范的shell脚本
1,声明解释器
2,注释脚本功能,变量含义等等
3,执行代码
--------------------------------------------------------------------------
脚本的运行方式
1, 添加x执行权限  
chmod +x test1.sh
2, 使用解释器执行, 开启子进程
bash test1.sh
3, 使用当前解释器执行,不开启子进程
source test1.sh
. test1.sh
4, 当运行可执行脚本时(绿色)
  ./脚本名
----------------------------------------------------------------------
编写一键部署ftp服务的脚本:
#!/bin/bash
yum -y install vsftpd &> /dev/null
systemctl restart vsftpd
systemctl enable vsftpd
cp /etc/passwd /var/ftp/pub

测试时把防火墙临时关闭
使用真机访问虚拟机的ftp

常量 固定不变
变量 灵活多变
1,自定义变量,名称需要使用大小写字母,数字或下划线,禁止使用特殊符号,不能以数字开头
   变量名称=值
2,环境变量 USER UID HOME HOSTNAME SHELL PATH PS1 PS2
3,位置变量和预定义变量
    $1  $2  $3  $0  $$  $#  $*  $? $!
#!/bin/bash
echo $1   脚本后的第1个参数
echo $2   脚本后的第2个参数
echo $3   脚本后的第3个参数
echo $0   脚本名
echo $$   显示脚本执行时的进程ID号
echo $#   参数的个数
echo $*   所有参数
echo $?   判断上一条指令是否执行成功 0成功   非0失败
echo $!   最后放入后台的进程
编写创建账户与配置密码的脚本:
#!/bin/bash
useradd xyz
echo 123 | passwd --stdin xyz

升级版:
#!/bin/bash
useradd $1
echo $2 | passwd --stdin $1

env 查看所有环境变量
set 查看所有变量
=======================================
变量扩展知识:
""  双引号,界定范围
''   单引号,界定范围,屏蔽特殊符号
``  反撇号 或$() ,获取命令执行的结果
tar -zcf log-`date +%Y-%m-%d`.tar.gz /var/log
-------------------------------------------
使用read功能编写交互式脚本:
#!/bin/bash
read -p "请输入用户名"  User
useradd $User
read -p "请输入密码"  Pass
echo $Pass | passwd --stdin $User
-------------------------------------------
stty -echo  屏蔽回显
stty echo   恢复回显
------------------------------------------
#!/bin/bash
read -p "请输入用户名" User
useradd $User
stty -echo
read -p "请输入密码" Pass
stty echo
echo $Pass | passwd --stdin $User
-------------------------------------------
export 发布全局变量
export a=10  发布新的全局变量
export b  将局部变量扩展为全局变量
export -n a   取消全局变量,恢复为局部变量
unset a  取消变量定义(删除变量)
====================================
shell中的运算
1, expr
expr 1 + 1  加
expr 1 - 1  减
expr 2 \* 2 乘        \ 转义符号,屏蔽之后一个字符的特殊含义
expr 10 / 5 除
expr 10 % 3 求模,相当于取余数
2, $[] 或 $(())
echo $[1+1]
echo $[10-5]
echo $[10*5]
echo $[10/5]
echo $[10%5]
3, let 通常用于变量计算,结果不显示
let a=1+1
let c=c+c
对变量自增减:
				     主流写法(主要掌握)
let a=a+1  相当于    let a++
let a=a-1 		  let a--
let a=a+2  		  let a+=2
let a=a-2  		  let a-=2
let a=a*2  		  let a*=2
let a=a/2  		  let a/=2
let a=a%2  		  let a%=2

4 ,计算器  bc 可以计算小数
echo "1.1+1" | bc
echo "scale=3;10/3" | bc

########################################################


    date 2
回顾
1,声明解释器 
#!/bin/bash
2,注释
#
3,执行代码

bash优点
tab键,快捷键,历史记录,管道符,重定向

变量
1,自定义变量

2,环境变量
USER UID HOME HOSTNAME SHELL PWD PATH PS1 PS2
3,位置变量和预定义变量
$1 $2 $3 ....
$0  $$  $#  $*  $?  $!

变量扩展
""   ''   ``  $()
read -p
stty -echo
stty echo

export  发布全局变量
export -n 

shell中的运算
1  
expr 1 + 1
expr 1 \* 1
expr 1 % 1
2
$[]  $(())
echo $[1+1]
3
let a=1+1
let a++   let a--
let a+=2  let a%=5
4
echo "scale=3;10/3" | bc

--------------------------------------------------------------
shell中的条件测试:
使用方式
1,test 测试语句
2,[  测试语句 ]
=========================================
测试内容包含:
1,字符串
==是否相等   !=是否不等     -z是否为空
test a == a  或者  [  a == a ]    使用  echo $?查看结果
2,数字
-eq等于  -ne不等于  -gt大于  -ge大于等于  -lt小于  -le小于等于
3,文件
-e 判断文件是否存在,不关心文件类型  -d 判断目录是否存在  -f 判断普通文件是否存在  -r   -w   -x
4,  逻辑测试 
&&并且        之前的任务成功,之后的任务才会执行
||或者           之前的任务失败,之后的任务才会执行

[ $USER == root ] && echo "我 是 管理员"      
-----------------------------------------------------------------------
两个逻辑符号连续使用:
ls a || ls b && ls test1.sh
a
test1.sh
ls a || ls b || ls test1.sh
a
ls a && ls b || ls test1.sh
a
b
-----------------------------------------------------------------------
[ $USER == root ] && echo "我 是 管理员"  ||  echo "我不是管理员"

编写脚本, 每2分钟检测当前登录系统的用户数量,如果超过3人,发邮件通知管理员
#!/bin/bash
n=`who | wc -l`
[ $n -gt 3 ] && echo "有人入侵服务器!隔壁老王来了" | mail -s test root
保存退出之后赋予脚本x权限 
chmod +x test1.sh
然后在计划任务中添加时间频率和执行的脚本路径
crontab -e
*/2 * * * * /opt/test1.sh
-----------------------------------------------------------------------
mail -s test root < 123    使用输入重定向发送邮件
-----------------------------------------------------------------------
shell中的if
单分支
if 条件测试 ;then
	命令序列
fi
双分支
if 条件测试 ;then
	命令序列1
else
	命令序列2
fi
多分支
if 条件测试 ;then
	命令序列1
elif 条件测试 ;then
	命令序列2
else
	命令序列3
fi
------------------------------------------------------------------------
ping -c定义ping次数  -i定义间隔时间,秒  -W等待反馈信息的时间,秒
ping -c 3 -i 0.2 -W 1 172.25.0.10
------------------------------------------------------------------------
使用if双分支编写ping脚本:
#!/bin/bash
ping -c 3 -i 0.2 -W 1 172.25.0.10 &> /dev/null
if [ $? -eq 0 ] ;then
	echo "通了"
else
	echo "不通"
fi
-------------------------------
#!/bin/bash
ping -c 3 -i 0.2 -W 1 $1 &> /dev/null
if [ $? -eq 0 ] ;then
	echo "通了"
else
	echo "不通"
fi
-----------------------------------------------------------------------
使用if多分支编写猜数脚本:
#!/bin/bash
x=$[RANDOM%10]
read -p "请输入一个数字(0-9)"  n
if [ $x -eq $n ] ;then
        echo "猜对了!!"
elif [ $n -lt $x ] ;then
        echo "猜小了"
else
        echo "猜大了"
fi
=================================
for循环:
for 变量名称 in 值1 值2 值3......
do
	执行指令
done

for ((i=1;i<5;i++))     //for(())为类 C 语言的语法格式  
do
echo $i
done
1
2
3
4


-------------------------
1, 循环次数,和值有关   2, 循环时的变量,也和值有关
-------------------------
#!/bin/bash
for i in {1..10}     多个值的简单写法
do
        echo $i
done
--------------------------------- 
#!/bin/bash
a=10
for i in {1..$a}     大括号不支持套用变量
do
        echo $i
done
---------------------------------
#!/bin/bash
a=10
for i in `seq $a`    可以使用seq支持变量
do
        echo $i
done
------------------------------------------------
#!/bin/bash
x=0
y=0
for i in {1..15}
do
    ping -c 3 -i 0.2 -W 1 172.25.0.$i &> /dev/null
    if [ $? -eq 0 ];then
        echo "172.25.0.$i通了"
        let x++
    else
        echo "172.25.0.$i不通"
        let y++
    fi
done
echo "$x台通了,$y台不通"
=======================================
while循环
while 条件测试
do
	执行指令
done
---------------------------------------------
使用while循环编写猜数脚本,猜对为止
#!/bin/bash
x=$[RANDOM%100]
y=0
while :
do
        let y++
        read -p "请输入数字(0-99)" n
        if [ $x -eq $n ];then
                echo "猜对了!!猜了$y次"
                exit
        elif [ $n -lt $x ];then
                echo "猜小了"
        else
                echo "猜大了"
        fi
done

   echo -e "\e[32;1m[OK]\e[0m"     //显示绿色OK 字体粗 1m可以改变字体
    [OK]
   echo -e "\033[32m[OK]\033[0m"    //-e 扩展的用法 显示绿色OK 字体细
    [OK]
   echo -e "\033[行;列H*"            //几行几列显示*
   echo -e "123\n456" > a.txt        //加-e选项 换行
##########################################################################

date 3

回顾
条件测试
1,字符串    ==    !=   -z   ! -z
2,数字  -eq   -ne   -gt   -ge   -lt   -le
3,文件  -e  -d  -f  -r  -w  -x
4,逻辑   &&       ||

if
单分支
if 条件测试 ;then
	命令序列
fi
双分支
if 条件测试 ;then
	命令序列1
else
	命令序列2
fi
多分支
if 条件测试1 ;then
	命令序列1
elif 条件测试2 ;then
	命令序列2
elif 条件测试3;then
	命令序列3
elif 条件测试4 ;then
	命令序列4
.......
else
	命令序列n
fi

ping -c  -i  -W 1

for    有次数限制
for i in 值1 值2 .....
do
	循环任务
done

while :   无限循环
do
	循环任务
	exit
done
=======================================
case分支,相当于简化版本的if,功能不如if强大,但是代码比if精简

case  变量  in
模式1)
    命令序列1 ;;
模式2)
    命令序列2 ;;
    .. ..
*)
    默认命令序列
esac
---------------------------------------------------------
#!/bin/bash
case $1 in
t)
        touch $2 ;;
m)
        mkdir $2 ;;
r)
        rm -rf $2 ;;
*)
        echo "t|m|r"
esac

==============================
使用case分支编写工具脚本:
1,准备工作
scp lnmp_soft.tar.gz root@server0:/opt   将真机的tar包传入虚拟机
tar -xf lnmp_soft.tar.gz  在虚拟机中释放tar包
cp lnmp_soft/nginx-1.12.2.tar.gz /opt  拷贝nginx包到opt
---------------------------------------------------------
编写一键源代码安装nginx的脚本
#!/bin/bash
yum -y install gcc openssl-devel pcre-devel  &> /dev/null
tar -xf nginx-1.12.2.tar.gz
cd nginx-1.12.2
./configure
make
make install
------------------------------------------------------
运行脚本后,nginx自动安装完毕
cd /usr/local/nginx/sbin/    前往nginx主程序所在目录
./nginx    执行程序(开启nginx网站服务)
关闭防火墙后,在真机打开浏览器输入虚拟机的地址可以看到网站
----------------------------------------------------------------------------
#!/bin/bash
case $1 in
st)
        /usr/local/nginx/sbin/nginx ;;
stop)
        /usr/local/nginx/sbin/nginx -s stop ;;
re)
        /usr/local/nginx/sbin/nginx -s stop
        /usr/local/nginx/sbin/nginx ;;
*)
        echo "st开启|stop关闭|re重启"
esac
----------------------------------------------------------------------------
完善脚本:
#!/bin/bash
case $1 in
st)
        /usr/local/nginx/sbin/nginx ;;
stop)
        /usr/local/nginx/sbin/nginx -s stop ;;
re)
        /usr/local/nginx/sbin/nginx -s stop
        /usr/local/nginx/sbin/nginx ;;
sa)
        netstat -ntulp |grep -q nginx
        [ $? -eq 0 ] && echo "服务正在运行" || echo "服务没有开启"  ;;
*)
        echo "st开启|stop关闭|re重启|sa查询状态"
esac
---------------------------------------------------------------------------
修改输出字体颜色
echo -e "\033[32mABCD\033[0m"     输出不通颜色的ABCD
echo -e "\033[33mABCD\033[0m"
echo -e "\033[34mABCD\033[0m"
---------------------------------------------------------------------------
函数 
1）函数的定义方法

格式1：

function  函数名 {
    命令序列
    .. ..
}

格式2：

函数名() {
    命令序列
    .. ..
}
--------------------------------------------------------------
使用函数编写方便调用不同颜色字体的脚本:
#!/bin/bash
cecho (){
echo -e "\033[$1m$2\033[0m"
}

cecho 31 ABCDEFG
cecho 32 ABCDEFG
cecho 33 ABCDEFG
cecho 34 ABCDEFG
cecho 35 ABCDEFG
cecho 36 ABCDEFG
cecho 37 ABCDEFG



#!/bin/bash
abc(){
abc|abc &
}
abc

==================================
循环的控制:
exit        退出脚本
break       终止循环,执行循环之后的任务 
continue	终止当前循环,继续下一次循环
------------------------
#!/bin/bash
for i in {1..10}
do
        [ $i -eq 5 ] && continue
        echo $i
done
echo ok
-------------------------
#!/bin/bash
for i in {1..10}
do
        [ $i -eq 5 ] && break
        echo $i
done
echo ok
=====================================
字符串的处理
1,字符串的截取
${变量名:起始位置:长度}         如果是第1位,那么起始位置是0
b=1802874632   定义变量
echo ${b:3:4}   截取变量的内容从第4位开始截取4位
echo ${b::4}	起始位置是0的话可以省略不写
------------------------------------
编写随机获取1位字符的脚本:
#!/bin/bash
x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQ
RSTUVWXYZ0123456789
n=$[RANDOM%62]
echo ${x:n:1}
-----------------------------------------------------
编写获取随机8位密码的脚本
#!/bin/bash
x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRS
TUVWXYZ0123456789
for i in {1..8}
do
n=$[RANDOM%62]    获取0~61之间的随机数字
p=${x:n:1}        获取1位随机字符
pass=$pass$p      将每次获取的随机字符赋值给变量pass
done
echo $pass
-------------------------------------------------------------------
2,字符串的替换
格式：${变量名/old/new}
b=1802874632    
echo ${b/1/a}     将1替换为a
echo ${b/8/a}	  将8替换为a
echo ${b//8/a}    将所有8替换为a
echo ${b/0/}      将数字0替换为空,相当于删除
----------------------------------------------
3,字符串的删除
${变量名#*关键词}    从左往右删除   掐头
echo $a
root:x:0:0:root:/root:/bin/bash
echo ${a#root}    删除到第一个root
echo ${a##*root}  删除到最后一个root,以及此root左边所有
echo ${a##*/}     删除到最后一个/,以及此/左边所有
echo ${a#*:root}  删除:root,以及左边所有
--------------------------------------------
${变量名%关键词*}    从右往左删除   去尾
echo ${a%bash}   从右往左删除到bash
echo ${a%root*}  从右往左删除到第一个root,以及root右边所有
echo ${a%/*}     从右往左删除到第一个/,以及/右边所有
echo ${a%%/*}    从右往左删除到最后一个/,以及/右边所有
--------------------------------------------
利用字符串删除功能,编写批量修改文件扩展名的脚本:
#!/bin/bash
for i in `ls *.txt`    首先找到修改目标
do
        n=${i%.*}      利用删除中的去尾将扩展名删除,剩下不带扩展名的文件名
        mv $i $n.doc   在将上述文件名与.doc组合,修改为新名字
done

#######################################################################


date 4

回顾
case分支

case 变量 in
模式1)
	命令序列 ;;
模式2)
	命令序列 ;;
*)
	命令序列
esac

函数 可以将公共的语句块存储在一个函数中,达到精简脚本的目的

方式一
function 函数名 {
	命令序列
}
方式二
函数名 (){
	命令序列
}
----------------------------------------
for    
while 
exit
break
continue
-----------------------------
字符串处理
${变量名:}   截取
${变量名/}  替换
${变量名#}  掐头
${变量名%}  去尾
===================================
字符串初值的处理 
${变量名:-} 
[root@server0 opt]# a=
[root@server0 opt]# echo ${a:-123}      当变量是空时调用初值
123
[root@server0 opt]# a=789
[root@server0 opt]# echo ${a:-123}      变量有值时不使用初值
789
-------------------------------------------------------
配置密码时使用初值: 
#!/bin/bash
read -p "请输入用户名"  u
useradd $u
read -p "请输入密码(默认123456)" p
echo ${p:-123456} | passwd --stdin $u
-------------------------------------------------------
正则表达式,使用若干符号配合对应工具,实现对文本的匹配,查找,过滤
基本正则:
^     grep ^root user     搜索以root开头
$	  grep in$ user		  搜索以in结尾
[]	  grep [in] user	  搜索字母i或者n
[^]	  grep [^in] user     搜索除了字母i或者n
grep "." user      搜索任意单个字符,包括空格,但不包括空行
grep "ro*t" user   搜索r?t,r与t之间有没有o都可以
grep ".*"   user   搜索任意, 包括空行
grep "ro\{1,2\}t"  user   搜索rot,其中o可以出现1~2次
grep "ro\{2\}t" user      搜索rot,其中o出现2次
grep "ro\{1,\}t" user     搜索rot,其中o可以出现1次以及1次以上
grep "0:\{2\}" user		  搜索0::
grep "\(0:\)\{2\}" user   搜索0:0:
-----------------------------------------------------------------------
使用扩展正则, 需要用egrep或者 grep -E
grep -E "ro+t" user      搜索rot,o可以出现1次以及1次以上
egrep "ro+t" user	     搜索rot,o可以出现1次以及1次以上
egrep "bi?n" user	     搜索bin,i可以出现0次或者1次
egrep "ro{2}t" user 	 搜索rot,o出现2次
egrep "ro{1,3}t" user 	 搜索rot,o出现1~3次
egrep "ro{2,}t" user 	 搜索rot,o出现2次以及2次以上
grep "\(0:\)\{2\}" user  搜索0:0:
egrep "(0:){2}" user	 使用扩展正则搜索0:0:
egrep "ro|in" user		 搜索ro或者in
grep "\bthe" user1       搜索单词the,前面不能有数字字母下划线

======================================
echo 123 >> 1.txt
vim 
sed  流式编辑器, 非交互式修改文本,而且支持正则表达式,工作方式是逐行处理
使用方式:
1,  sed 选项  (定址符)指令     被处理的文件
2,   前置命令  | sed 选项  (定址符)指令
选项
-n   屏蔽默认输出        -r   支持扩展正则     -i   写入文件
指令
p  输出         d  删除      s  替换


sed 命令后面引入变量或Linux命令时 要用双引号 :如----> sed -i "2s/$/`hostname`" a.txt

sed -n 'p' user      使用sed输出所有行,屏蔽默认输出
sed -n '1p' user     输出第1行
sed -n '2,4p' user   输出2~4行
sed -n '3p;5p' user  输出第3行和第5行
sed -n '2,+3p' user  输出第2行以及后面的3行
sed -n '1~2p' user   输出奇数行
sed -n '2~2p' user   输出偶数行
sed -n '/bash$/p' user     使用正则输出以bash结尾的行
sed -rn '/root|bin/p' user 使用扩展正则输出有root或者bin的行
sed -n '$p' /etc/passwd   显示最后一行
sed -n '=' user      显示行号
sed -n '$=' user	 显示最后一行的行号
sed -n '$=' /etc/passwd
sed  'd' user	     删除所有行
sed  '1d' user		 删除第1行
sed  '2,4d' user	 删除2~4行
sed  '3,+2d' user    删除第3行以及后面2行
sed  '2d;5d' user    删除第2行和第5行
sed -i '1,3d' user   删除1~3行,并写入文件

sed 's/xml/XML/'  a.txt		将每行中第1个xml替换为XML
sed 's/xml/XML/3' a.txt 	将每行中的第3个xml替换为XML
sed 's/xml/XML/g' a.txt 	将所有的xml都替换为XML
sed 's/xml//g'     a.txt 	将所有行的xml都删除

/bin/bash 换成 /sbin/sh

sed 's//bin/bash//sbin/sh/' user
sed 's/\/bin\/bash/\/sbin\/sh/' user
sed 's!/bin/bash!/sbin/sh!' user
sed 's(/bin/bash(/sbin/sh(' user
sed 's#/bin/bash#/sbin/sh#' user

编写脚本,对vsftpd服务完成装包配置启服务的过程,其中使用sed完成配置过程,实现服务可以匿名访问并且上传文件.

#!/bin/bash
yum -y install vsftpd &> /dev/null
sed -i '/anon_up/s/#//'   /etc/vsftpd/vsftpd.conf
systemctl restart vsftpd
systemctl enable vsftpd
systemctl stop firewalld
setenforce 0
chmod 777 /var/ftp/pub

====================================================
sed -i 's/#anon_up/anon_up/'   /etc/vsftpd/vsftpd.conf

ab -c 人数 -n 总次数 网站(http://)     //同时访问同一个网站

##################################################################

date 5




sed 选项  (定址符)指令    处理的文件
前置指令 |  sed 选项  (定址符)指令
-n   -r   -i     p    d    s

cat nssw.txt

Hello th6e World
ni ha7o ma beijing

删除文件中每行的第二个、最后一个字符
sed 's/.//2;s/.$//' u

将文件中每行的第一个、倒数第1个字符互换
( )  保留(相当于复制)   \1 \2 相当于粘贴
sed -r 's/^(.)(.*)(.)$/\3\2\1/' u

删除文件中所有的数字
sed 's/[0-9]//g' u

为文件中每个大写字母添加括号
sed -r 's/([A-Z])/(\1)/g' u
----------------------------------------------------------------------
a在行下追加    i在行上添加    c替换整行

sed 'i XXXX' a        所有行上添加XXXX
sed '1i XXXX' a       第一行上添加XXXX
sed '1,2i XXXX' a     1~2行上添加
sed '1a XXXX' a       第一行下追加
sed 'c XXXX' a        所有行替换为XXXX
sed '1c XXXX' a       第一行替换
sed '/abc/c XXXX' a   有abc的行替换

-----------------------------------------------------------------------
编写脚本,找出使用bash的用户,按照 名字 --> 密码  的格式输出: 
#!/bin/bash
u=`sed -n '/bash$/s/:.*//p' /etc/passwd`    找到用bash的用户,并且把名字都存在变量u中
for i in $u   将变量u交给for循环处理
do
	x=`grep $i: /etc/shadow`   第一次循环,变量i是第一个用户
	a1=${x#*:}		掐头
	a2=${a1%%:*}    去尾
	echo "$i --> $a2"     输出
done

========================================
正则     
grep   模糊搜索
sed    可以修改文档
awk    精确搜索
------------------------------------------------
awk使用方式:
1 ,  awk 选项  (条件)指令   被处理的文件
2 ,    前置命令  |   awk 选项  (条件)指令  
选项:
-F 定义分隔符    
指令
print  输出
内置变量:
列  $0  $1  $2  $3 ...... NF列   NR行

awk '{print}' u
awk '{print $2}' u
awk '{print $0}' u
awk '{print $1}' u
awk '{print $1 $3}' u
awk '{print $1,$3}' u
awk '{print $0,$3}' u
awk '/beijing/{print}' u
----------------------------------------------------
cat user    准备素材
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
awk -F: '{print $6}' user  修改分隔符为冒号, 显示第6列
/root
/bin
awk -F: '/root/{print $6}' user   配合正则匹配有root的行,显示第6列
/root
awk -F/ '/root/{print $3}' user   修改分隔符,显示第3列
bin
awk -F[:/] '/root/{print $9}' user  使用冒号或者斜杠做分隔符,显示第9列
awk -F: '{print $1"的解释器是"$7}' user  输出常量,需要使用引号
awk -F: '{print $1 abc $7}' user    不加引号,系统会识别为变量,如果变量没有定义,则输出的值为空
awk -F: '{print $1 "abc" $7}' user  加引号,变常量输出
awk -F: '{print NR,NF}' user     输出行号和列号
----------------------------------------------------------------------------------------
ifconfig eth0 |awk '/TX p/{print "当前主机eth0网卡的发送流量是"$5"字节"}'
ifconfig eth0 |awk '/RX p/{print "当前主机eth0网卡的接收流量是"$5"字节"}'
df -h | awk '/vda1/{print "主机根分区剩余空间是"$4}'
----------------------------------------------------------------------------------------
使用awk,筛选出远程登录本机密码输入失败的主机ip:
awk '/Failed/{print $11}' /var/log/secure
----------------------------------------------------------------------------------------
awk的工作流程控制
BEGIN任务    执行1次
逐行任务       执行N次
END任务        执行1次
----------------------------------
awk 'BEGIN{x=10;print x}'    仅仅使用begin任务,执行1次
----------------------------------
awk 'BEGIN{print "x"}{print "A"}' user   执行1次begin任务,然后在执行逐行任务,逐行任务的执行次数与user文本的行数有关
----------------------------------
awk 'BEGIN{print "x"}{print "A"}END{print "Q"}' user   分别给begin,逐行,end 三个任务
----------------------------------------------------------------------------------------
\t  制表符  相当于tab键, 可以起到一定的排版效果
------------------------------------
awk -F: 'BEGIN{print "User\tUID\tHome"}{print $1"\t"$3"\t"$6}END{print "总计 "NR" 行"}' user 
==============================================
awk的条件
1,使用正则匹配
    ~   包含
awk '/bin/' user          输出含有bin的行
awk -F: '$1~/bin/' user   输出第一列包含bin的行
awk -F: '$1!~/bin/' user    输出第1列不包含bin的行
awk -F: '$1!~/^(bin|root)/' user   输出第1列不包含以bin或者root开头的行
-----------------------------------------
2,使用数值/字符串比较设置条件
==(等于)    !=（不等于） >（大于）
>=（大于等于） <（小于） <=（小于等于）
awk 'NR==2{print}' user   输出第2行内容
awk -F: '$1=="root"' user    输出第1列是root的行
awk -F: '$1!="root"' user    输出第1列不是root的行
awk -F: '$3=="0"' user       输出第3列是0的行
awk -F: '$3<10' /etc/passwd   输出第3列小于10的行
awk -F: 'NR<10' /etc/passwd   输出小于10行的内容,相当于输出1~9行
awk -F: '$3>=1000' /etc/passwd   输出第3列大于等于1000的行
--------------------------------------------
3,使用逻辑符号     &&并且       ||或者
---------------------------------------------
4,计算
awk 'BEGIN{x++;print x}'   
awk 'BEGIN{print 2*3}'     
awk 'BEGIN{a=10;b=20;print a*b}'
awk 'BEGIN{print 23%8}'
seq 200 | awk '$1%33==0'


登录虚拟机server0,完成以下习题

文本练习回顾
如何取出本机默认网卡的IPv4地址?
ifconfig|sed -n '2p'|awk '{print $2}'



如何取出本机private1/private2的网卡的IPv6地址?
ifconfig|grep -A1 "private1"|sed -n '2p'|awk '{print $2}'
ifconfig|grep -A1 "private2"|sed -n '2p'|awk '{print $2}'



获取/etc/passwd文本第4行至第7行的相关文本信息?
cat /etc/passwd|sed -n '4,7p'
awk 'NR>=4&&NR<=7' /etc/passwd



获取/etc/passwd整个文本信息?
cat /etc/passwd
sed -n '1,$p' /etc/passwd
awk '{print}' /etc/passwd


获取/etc/passwd文本关于rpc用户的相关信息(需精确匹配,不涉及rpcuser用户)?
awk -F: '{if($1=="rpc")print}' /etc/passwd
awk -F: '$1=="rpc"{print}' /etc/passwd


获取/etc/passwd文本文件的总行数?
cat /etc/passwd|wc -l
sed -n '$='  /etc/passwd
awk 'END{print NR}' /etc/passwd

获取/etc/passwd文本来自于root用户所在的行号?
cat /etc/passwd|awk -F: '{if($1=="root")print NR}'
cat  /etc/passwd|sed -n '/^root/='



删除/etc/passwd文本关于nfsnobody用户的相关信息?
sed '/nfsnobody/d' /etc/passwd


获取/etc/passwd奇数行
sed -n '1~2p' /etc/passwd
awk 'NR%2==1' /etc/passwd
sed -n 'p;n' /etc/passwd


获取/etc/passwd偶数行
sed -n '0~2p' /etc/passwd
awk 'NR%2==0' /etc/passwd
sed -n 'n;p' /etc/passwd


打印/etc/passwd所有以ss或ga为开头的记录行
egrep  '^ss|^ga' /etc/passwd
awk '/^(ss|ga)/' /etc/passwd
sed -n '/^ss/p;/^ga/p' /etc/passwd


在/etc/passwd文本中打印用户名是以"t"字符为结尾的记录行
awk -F: '{if($1~/t$/)print}' /etc/passwd



在/etc/passwd中打印以"/sbin/nologin"为解析器的记录行,并求出它们UID的总和
awk -F: '$NF~/\/sbin\/nologin$/{print}' /etc/passwd|awk -F: '{a+=$3}END{print a}'
awk -F: '$NF~/\/sbin\/nologin$/{print}' /etc/passwd|awk -F: '{print $3}'|paste -s -d"+"|bc



脚本练习1
使用for循环计算100以内所有偶数的和,然后用while循环和until循环来实现这个功能
#!/bin/bash
sum=0
for((i=2;i<=100;i+=2))
do
    let sum+=i
done
echo "100以内的所有偶数和为$sum"


#!/bin/bash
sum=0
i=0
while [ $i -le 100 ]
do
     let sum+=i
     let i+=2
done

echo "100以内的所有偶数和为$sum"



#!/bin/bash
sum=0
i=0
until [ $i -gt 100 ]
do
     let sum+=i
     let i+=2
done

echo "100以内的所有偶数和为$sum"





脚本练习2
使用while循环或者until循环实现从命令行读入字符串,直到输入的字符串为句号为止.
#!/bin/bash
while [ true ]
do
read -p "请输入一个字符串: " str 
 if [ "$str" == "." ]
 then
     echo "你输入的是句号!"
     break
 fi
done

#!/bin/bash
until [ "$str" == "." ]
do
    read -p "请输入一个字符串: " str
done
    echo "你输入了句号!"




脚本练习3
写脚本打印如下的"*"组成的图案:
*
*	*
*	*	*
*	*	*	*
*	*	*	*	* 

#!/bin/bash
for((i=1;i<=5;i++))
do
yes "*"|head -$i|paste -s
done






脚本练习4
倒置读取/etc/passwd文本内容?(脚本实现tac命令功能)
#!/bin/bash
numline=$(cat /etc/passwd|wc -l)
while [ "$numline" -gt 0 ]
do
    sed -n "${numline}p" /etc/passwd
    let numline--
done







脚本练习5
如何获取任意文本的中间行?(偶数行文本取最中间两行)
#!/bin/bash
read -p "请输入一个文本: " file
file_line_num=$(cat $file|wc -l)
echo "$file_line_num"
yushu=`echo ${file_line_num}%2|bc`
if [ "$yushu" -eq 0 ]
then
     middle_line_num=`echo "$file_line_num/2"|bc`
     middle_line_next_num=`echo "${middle_line_num}+1"|bc`
     sed -n "${middle_line_num}p;${middle_line_next_num}p" $file
else 
     middle_line_num=`echo "$file_line_num/2"|bc`
     middle_line_next_num=`echo ${middle_line_num}+1|bc`
     sed -n "${middle_line_next_num}p" $file
fi


#!/bin/bash
read -p "请输入一个文本: " file
/bin/cp ${file} ${file}.bak
while [ true ]
do
file_line_num=$(cat ${file}.bak|wc -l)
    if [ "$file_line_num" -ge 3 ]
    then 
        sed -i '1d;$d' ${file}.bak
    else
        cat ${file}.bak
        break
    fi
done




脚本练习6
找出100以内所有能被3整除的数,每行显示8个数,然后换行显示.
#!/bin/bash
count=1
for((i=1;i<=100;i++))
do
     yushu=$(echo "$i%3"|bc)
     if [ "$yushu" -eq 0 ] && [ $count -ne 8 ]
     then     
         echo -n "$i "
         let count++
     elif [ "$yushu" -eq 0 ] && [ $count -eq 8 ]
     then
         echo "$i "
         let count=1
     else
         continue
     fi
done






脚本练习7
如果一个正整数各位数字之和可以被9整除,那么该正整数就可以被9整除,编写一个脚本提示用户输入
一个正整数,按照以上的逻辑判断输出该正整数,并告知该正整数是否可被9整除.
#!/bin/bash
read -p "请输入一个正整数数字: " num
while [ true ]
do
str=$(echo $num|sed 's#[0-9]##g')
   if [ "$str" != "" ]
   then
       read -p "您输入的不是数字,请重新输入一个数字正整数: " num
   else
       break
   fi
done

num_length=$(echo ${#num})

for((i=0;i<num_length;i++))
do
    n=`echo ${num:$i:1}`
    let sum+=n
done
    yushu=`echo ${sum}%9|bc`
    if [ "$yushu" -eq 0 ]
    then 
        echo "$num可被9整除"
    else
        echo "$num不可被9整除"
    fi




#!/bin/bash
read -p "请输入一个正整数数字: " num
while [ true ]
do
str=$(echo $num|sed 's#[0-9]##g')
   if [ "$str" != "" ]
   then
       read -p "您输入的不是数字,请重新输入一个数字正整数: " num
   else
       break
   fi
done
sum=`echo "$num"|fold -1|paste -s -d+|bc`
  yushu=`echo $sum%9|bc`
  if [ "$yushu" -eq 0 ]
  then
     echo "$num可被9整除"
  else
     echo "$num不可被9整除"
  fi






脚本练习8
编写一个脚本,该脚本提示用户输入一些正整数,然后通过程序控制分别计算出这些正整数中奇数之和
与偶数之和,并将其输出.
#!/bin/bash
read -p "请输入一个正整数数字: " num
while [ true ]
do
str=$(echo $num|sed 's#[0-9]##g')
   if [ "$str" != "" ]
   then
       read -p "您输入的不是数字,请重新输入一个数字正整数: " num
   else
       break
   fi
done

num_length=$(echo ${#num})

for((i=0;i<num_length;i++))
do
    n=`echo ${num:$i:1}`
    yushu=`echo $n%2|bc`
    if [ "$yushu" -ne 0 ]    
    then
        let jishu_he+=n
    else
        let oushu_he+=n
    fi
done
    echo "您输入的数字$num的奇数和为$jishu_he,偶数和为$oushu_he"





脚本练习9
使用for循环在/opt目录下批量创建10个html文件,其中每个文件需要包含10个随机小写字母加固定字符串"_opt"
#!/bin/bash
for((i=1;i<=10;i++))
do
    random=`cat /dev/urandom|sed 's#[^a-z]##g'|strings -n 1|fold -1|head|paste -s -d ""`
    touch /opt/${random}_opt.html
done

补充点:
cat /dev/urandom|tr -dc a-z |head -c10



#############################################################################

date 6

案例1：awk流程控制
案例2：awk扩展应用
案例3：编写监控脚本
案例4：编写安全检测脚本
1 案例1：awk流程控制
1.1 问题

本案例要求了解awk的流程控制操作，可自行设置awk语句来有验证以下操作：
if分支结构（单分支、双分支、多分支）
练习awk数组的使用
1.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：awk过滤中的if分支结构

1）单分支
统计/etc/passwd文件中UID小于或等于1000的用户个数：
[root@svr5 ~]# awk -F: '{if($3<=1000){i++}}END{print i}' /etc/passwd
39
统计/etc/passwd文件中UID大于1000的用户个数：
[root@svr5 ~]# awk -F: '{if($3>1000){i++}}END{print i}' /etc/passwd
8
统计/etc/passwd文件中登录Shell是“/bin/bash”的用户个数：
[root@svr5 ~]# awk -F: '{if($7~/bash$/){i++}}END{print i}'  /etc/passwd
29
2）双分支
分别统计/etc/passwd文件中UID小于或等于1000、UID大于1000的用户个数：
[root@svr5 ~]# awk -F: '{if($3<=1000){i++}else{j++}}END{print i,j}' /etc/passwd
39 8
分别统计/etc/passwd文件中登录Shell是“/bin/bash”、 登录Shell不是“/bin/bash”的用户个数：
[root@svr5 ~]# awk -F: '{if($7~/bash$/){i++}else{j++}} END{print i,j}' /etc/passwd
29 38
步骤二：awk数组

1）数组的语法格式
数组是一个可以存储多个值的变量，具体使用的格式如下：
定义数组的格式：数组名[下标]=元素值
调用数组的格式：数组名[下标]
遍历数组的用法：for(变量 in 数组名){print 数组名[变量]}。
[root@svr5 ~]# awk 'BEGIN{a[0]=11;a[1]=88;print a[1],a[0]}'
88 11
[root@svr5 ~]# awk 'BEGIN{a++;print a}'
1
[root@svr5 ~]# awk 'BEGIN{a0++;print a0}'
1
[root@svr5 ~]# awk 'BEGIN{a[0]++;print a[0]}'
1
[root@svr5 ~]# awk 'BEGIN{a[0]=0;a[1]=11;a[2]=22; for(i in a){print i,a[i]}}'
0 0
1 11
2 22
注意，awk数组的下标除了可以使用数字，也可以使用字符串，字符串需要使用双引号：
[root@svr5 ~]# awk 'BEGIN{a["hehe"]=11;print a["hehe"]}'
11
2 案例2：awk扩展应用
2.1 问题

本案例要求使用awk工具完成下列两个任务：
分析Web日志的访问量排名，要求获得客户机的地址、访问次数，并且按照访问次数排名
2.2 方案

1）awk统计Web访问排名
在分析Web日志文件时，每条访问记录的第一列就是客户机的IP地址，其中会有很多重复的IP地址。因此只用awk提取出这一列是不够的，还需要统计重复记录的数量并且进行排序。
通过awk提取信息时，利用IP地址作为数组下标，每遇到一个重复值就将此数组元素递增1，最终就获得了这个IP地址出现的次数。
针对文本排序输出可以采用sort命令，相关的常见选项为-r、-n、-k。其中-n表示按数字顺序升序排列，而-r表示反序，-k可以指定按第几个字段来排序。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：统计Web访问量排名

分步测试、验证效果如下所述。
1）提取IP地址及访问量
[root@svr5 ~]# awk '{ip[$1]++} \
>  END{for(i in ip) {print ip[i],i }}' /var/log/httpd/access_log
4  127.0.0.1
17 192.168.4.5
13 192.168.4.110
.. ..
2）对第1）步的结果根据访问量排名
[root@svr5 ~]# awk  '{ip[$1]++} END{for(i in ip) {print i,ip[i]}}' /var/log/httpd/access_log | sort -nr
17 192.168.4.5
13 192.168.4.110
4 127.0.0.1
.. ..
3 案例3：编写监控脚本
3.1 问题

本案例要求编写脚本，实现计算机各个性能数据监控的功能，具体监控项目要求如下：
CPU负载
网卡流量
内存剩余容量
磁盘剩余容量
计算机账户数量
当前登录账户数量
计算机当前开启的进程数量
本机已安装的软件包数量
3.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：准备工作

1）查看性能数据的命令
[root@svr5 ~]# iostat                             //获取当前磁盘的读写信息
[root@svr5 ~]# traceroute                         //路由追踪
[root@svr5 ~]# uptime                            //查看CPU负载
[root@svr5 ~]# ifconfig eth0                    //查看网卡流量
[root@svr5 ~]# free                            //查看内存信息
[root@svr5 ~]# df                                //查看磁盘空间
[root@svr5 ~]# wc -l /etc/passwd                //查看计算机账户数量
[root@svr5 ~]# who |wc -l                        //查看登录账户数量
[root@svr5 ~]# rpm -qa |wc -l                    //查看已安装软件包数量
步骤二：编写参考脚本

1）脚本内容如下：
[root@svr5 ~]# vim test.sh
#!/bin/bash
ip=`ifconfig eth0 | awk '/inet /{print $2}'`
echo "本地IP地址是:"$ip
cpu=`uptime | awk '{print $NF}'`            
#awk中NF为当前行的列数，$NF是最后一列
echo "本机CPU最近15分钟的负载是:"$cpu
net_in=`ifconfig eth0 | awk '/RX p/{print $5}'`
echo "入站网卡流量为:"$net_in
net_out=`ifconfig eth0 | awk '/TX p/{print $5}'`
echo "出站网卡流量为:"$net_out
mem=`free | awk '/Mem/{print $4}'`
echo "内存剩余容量为:"$mem
disk=`df | awk '/\/$/{print $4}'`
echo "根分区剩余容量为:"$disk
user=`cat /etc/passwd |wc -l`
echo "本地账户数量为:"$user
login=`who | wc -l`
echo "当前登陆计算机的账户数量为:"$login
process=`ps aux | wc -l`
echo "当前计算机启动的进程数量为:"$process
soft=`rpm -qa | wc -l`
echo "当前计算机已安装的软件数量为:"$soft
4 案例4：编写安全检测脚本
4.1 问题

本案例要求编写脚本，防止远程ssh暴力破解密码，具体监控项目要求如下：
检测ssh登录日志，如果远程登陆账号名错误3次，则屏蔽远程主机的IP
检测ssh登录日志，如果远程登陆密码错误3次，则屏蔽远程主机的IP
4.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：准备工作

1）过滤帐户名失败的命令(登陆日志文件为/var/log/secure)
[root@svr5 ~]# awk '/Invalid user/{print $10}' /var/log/secure
2）过滤密码失败的命令
[root@svr5 ~]# awk '/Failed password/{print $11}' /var/log/secure
步骤二：编写参考脚本

1）脚本内容如下：
[root@svr5 ~]# vim test.sh
#!/bin/bash
awk '/Failed password/{print $11}' /var/log/secure  | awk '{ip[$1]++}END{for(i in ip){print ip[i],i}}' | awk '$1>3{print $2}'
awk '/Invalid user/{print $10}' /var/log/secure  | awk '{ip[$1]++}END{for(i in ip){print ip[i],i}}' | awk '$1>3{print $2}'

########################################################################
           
                 OPERATION

Top
NSD Operation DAY01

案例1：搭建Nginx服务器
案例2：用户认证
案例3：基于域名的虚拟主机
案例4：SSL虚拟主机
1 案例1：搭建Nginx服务器
1.1 问题

在IP地址为192.168.4.5的主机上安装部署Nginx服务，并可以将Nginx服务器，要求编译时启用如下功能：
支持SSL加密功能
设置Nginx账户及组名称均为nginx
Nginx服务器升级到更高版本。
然后客户端访问页面验证Nginx Web服务器：
使用火狐浏览器访问
使用curl访问
1.2 方案

提前准备运维课程所需的所有虚拟机，为后续所有实验做准备，克隆4台RHEL7虚拟机，实验环境所需要的主机及对应的IP设置列表如表-1所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。不需要配置网关与DNS。
表－1 主机列表

第一天课程需要使用2台RHEL7虚拟机，其中一台作为Nginx服务器（192.168.4.5）、另外一台作为测试用的Linux客户机（192.168.4.10），如图-1所示。

图-1
安装nginx-1.10.3版本时，需要使用如下参数：
--with-http_ssl_module：提供SSL加密功能
--user：指定账户
--group：指定组
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：构建Nginx服务器

1）使用源码包安装nginx软件包
[root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        //安装依赖包
[root@proxy ~]# useradd -s /sbin/nologin nginx
[root@proxy ~]# tar  -xf   nginx-1.10.3.tar.gz
[root@proxy ~]# cd  nginx-1.10.3
[root@proxy nginx-1.10.3]# ./configure   \
> --prefix=/usr/local/nginx   \                //指定安装路径
> --user=nginx   \                            //指定用户
> --group=nginx  \                            //指定组
> --with-http_ssl_module                        //开启SSL加密功能
[root@proxy nginx-1.10.3]# make && make install    //编译并安装
2）nginx命令的用法
[root@proxy ~]# /usr/local/nginx/sbin/nginx                    //启动服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s stop            //关闭服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload        //重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx -V                //查看软件信息
[root@proxy ~]# ln -s /usr/local/nginx/sbin/nginx /sbin/        //方便后期使用
[root@proxy ~]# echo "/usr/local/nginx/sbin/nginx" >> /etc/rc.local  //nginx 设置开机自启,该文件需加X权限
[root@proxy ~]# chmod +x /etc/rc.local
netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）
nginx服务默认通过TCP 80端口监听客户端请求：
root@proxy ~]# netstat  -anptu  |  grep nginx
tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx
3）设置防火墙与SELinux（非必须的操作，如果有则关闭）
[root@proxy ~]# systemctl stop firewalld
[root@proxy ~]# setenforce 0
4）测试首页文件
Nginx Web服务默认首页文档存储目录为/usr/local/nginx/html/，在此目录下默认有一个名为index.html的文件，使用客户端访问测试页面：
[root@client ~]# curl http://192.168.4.5
<html>
<head>
<title>Welcome to nginx!</title>
</head>
<body bgcolor="white" text="black">
<center><h1>Welcome to nginx!</h1></center>
</body>
</html>
步骤二：升级Nginx服务器

1）编译新版本nginx软件
[root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --prefix=/usr/local/nginx   \ 
> --user=nginx   \ 
> --group=nginx  \ 
> --with-http_ssl_module
[root@proxy nginx-1.12.2]# make            
2) 备份老的nginx主程序，并使用编译好的新版本nginx替换老版本
[root@proxy nginx-1.12.2]# mv /usr/local/nginx/sbin/nginx  \
>/usr/local/nginx/sbin/nginxold
[root@proxy nginx-1.12.2]# cp objs/nginx  /usr/local/nginx/sbin/         //拷贝新版本
[root@proxy nginx-1.12.2]# make upgrade                            //升级
#或者使用killall nginx杀死进程后再启动nginx。
/usr/local/nginx/sbin/nginx -t
nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`
sleep 1
test -f /usr/local/nginx/logs/nginx.pid.oldbin
kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`
[root@proxy ~]# /usr/local/nginx/sbin/nginx -V                //查看版本
步骤三：客户端访问测试

1）分别使用浏览器和命令行工具curl测试服务器页面
如果使用firefox火狐浏览器，注意在ssh远程的时候一定要加-X选项。
[root@client ~]# firefox http://192.168.4.5
[root@client ~]# curl http://192.168.4.5
2 案例2：用户认证
2.1 问题

沿用练习一，通过调整Nginx服务端配置，实现以下目标：
访问Web页面需要进行用户认证
用户名为：tom，密码为：123456
2.2 方案

通过Nginx实现Web页面的认证，需要修改Nginx配置文件，在配置文件中添加auth语句实现用户认证。最后使用htpasswd命令创建用户及密码即可。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：修改Nginx配置文件

1）修改/usr/local/nginx/conf/nginx.conf
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
        auth_basic "Input Password:";                        //认证提示符信息
        auth_basic_user_file "/usr/local/nginx/pass";        //认证的密码文件
        location / {
            root   html;
            index  index.html index.htm;
        }
  }
2）生成密码文件，创建用户及密码
使用htpasswd命令创建账户文件，需要确保系统中已经安装了httpd-tools。
[root@proxy ~]# yum -y install  httpd-tools
[root@proxy ~]# htpasswd -c /usr/local/nginx/pass   tom        //创建密码文件
New password: 
Re-type new password: 
Adding password for user tom
[root@proxy ~]# htpasswd  /usr/local/nginx/pass   jerry      //追加用户，不使用-c选项
New password: 
Re-type new password: 
Adding password for user jerry
[root@proxy ~]# cat /usr/local/nginx/pass
3）重新加载配置
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload    //重新加载配置文件    
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤二：客户端测试

1）登录192.168.4.10客户端主机进行测试
如果使用firefox火狐浏览器，注意在ssh远程的时候一定要加-X选项。
或者直接使用真实主机的火狐也可以。
[root@client ~]# firefox http://192.168.4.5                    //输入密码后可以访问
3 案例3：基于域名的虚拟主机
3.1 问题

沿用练习二，配置基于域名的虚拟主机，实现以下目标：
实现两个基于域名的虚拟主机，域名分别为www.a.com和www.b.com
对域名为www.a.com的站点进行用户认证，用户名称为tom，密码为123456
3.2 方案

修改Nginx配置文件，添加server容器实现虚拟主机功能；对于需要进行用户认证的虚拟主机添加auth认证语句。
虚拟主机一般可用分为：基于域名、基于IP和基于端口的虚拟主机。
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：修改配置文件

1）修改Nginx服务配置，添加相关虚拟主机配置如下
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;                                      //端口
        server_name  www.a.com;                                //域名
auth_basic "Input Password:";                        //认证提示符
        auth_basic_user_file "/usr/local/nginx/pass";        //认证密码文件
location / {
            root   html;                                    //指定网站根路径
            index  index.html index.htm;
       }
       
}
… …
    server {
        listen  80;                                        //端口
        server_name  www.b.com;                                //域名
location / { 
root   www;                                 //指定网站根路径
index  index.html index.htm;
}
}
2）创建网站根目录及对应首页文件
[root@proxy ~]# mkdir /usr/local/nginx/www
[root@proxy ~]# echo "www" > /usr/local/nginx/www/index.html
3）重新加载配置
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤二：客户端测试

1）修改客户端主机192.168.4.10的/etc/hosts文件，进行域名解析
 [root@client ~]# vim /etc/hosts
192.168.4.5    www.a.com  www.b.com
2）登录192.168.4.10客户端主机进行测试
注意：请先关闭真实机的firefox，再SSH -X远程连接调用虚拟机的firefox。
[root@client ~]# firefox http://www.a.com            //输入密码后可以访问
[root@client ~]# firefox http://www.b.com            //直接访问
提示：或者直接使用真实主机做客户端主机验证，修改真实主机的/etc/hosts文件，直接使用真实主机的火狐浏览器访问也可以。
步骤三：扩展课外实验：其他类型的虚拟主机

1.基于端口的虚拟主机（参考模板）
server {
        listen       8080;                        //端口
        server_name  web1.example.com;          //域名
        ......
}
    server {
        listen       8000;                         //端口
        server_name  web1.example.com;           //域名
      .......
}
2.基于IP的虚拟主机（参考模板）
server {
        listen       192.168.0.1:80;              //IP地址与端口
        server_name  web1.example.com;          //域名
  ... ...
}
    server {
        listen       192.168.0.2:80;             //IP地址与端口
        server_name  web1.example.com;
... ...
}
4 案例4：SSL虚拟主机
4.1 问题

沿用练习三，配置基于加密网站的虚拟主机，实现以下目标：
域名为www.c.com
该站点通过https访问
通过私钥、证书对该站点所有数据加密
4.2 方案

源码安装Nginx时必须使用--with-http_ssl_module参数，启用加密模块，对于需要进行SSL加密处理的站点添加ssl相关指令（设置网站需要的私钥和证书）。
加密算法一般分为对称算法、非对称算法、信息摘要。
对称算法有：AES、DES，主要应用在单机数据加密。
非对称算法有：RSA、DSA，主要应用在网络数据加密。
信息摘要：MD5、sha256，主要应用在数据完整性校验。
4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置SSL虚拟主机
1）生成私钥与证书
[root@proxy ~]# cd /usr/local/nginx/conf
[root@proxy ~]# openssl genrsa > cert.key                            //生成私钥
[root@proxy ~]# openssl req -new -x509 -key cert.key > cert.pem      //生成证书
2）修改Nginx配置文件，设置加密网站的虚拟主机
[root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
… …    
server {
        listen       443 ssl;
        server_name            www.c.com;
        ssl_certificate      cert.pem;         #这里是证书文件
        ssl_certificate_key  cert.key;         #这里是私钥文件
        ssl_session_cache    shared:SSL:1m;
        ssl_session_timeout  5m;
        ssl_ciphers  HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers  on;
        location / {
            root   html;
            index  index.html index.htm;
        }
    }
3）重新加载配置
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤二：客户端验证
1）修改客户端主机192.168.4.10的/etc/hosts文件，进行域名解析
[root@client ~]# vim /etc/hosts
192.168.4.5    www.c.com  www.a.com   www.b.com
2）登录192.168.4.10客户端主机进行测试
[root@client ~]# firefox https://www.c.com            //信任证书后可以访问
          
##############################################################################


 
NSD OPERATION DAY02

案例1：部署LNMP环境
案例2：构建LNMP平台
案例3：地址重写
1 案例1：部署LNMP环境
1.1 问题

安装部署Nginx、MariaDB、PHP环境
安装部署Nginx、MariaDB、PHP、PHP-FPM；
启动Nginx、MariaDB、FPM服务；
并测试LNMP是否工作正常。
1.2 方案

LNMP（Linux、Nginx、MySQL、PHP）
在RHEL7系统中，源码安装Nginx，使用RPM包安装MariaDB、PHP、PHP-FPM软件。
操作过程中需要安装的软件列表如下：
nginx
mariadb、mariadb-server、mariadb-devel
php、php-fpm、php-mysql
备注：mariadb（数据库客户端软件）、mariadb-server（数据库服务器软件）、mariadb-devel（其他客户端软件的依赖包）、php（解释器）、php-fpm（进程管理器服务）、php-mysql（PHP的数据库扩展包）。
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：安装软件

1）使用yum安装基础依赖包
[root@proxy ~]# yum -y install gcc openssl-devel pcre-devel
2）源码安装Nginx（如果前面课程中已经安装Nginx，则忽略这一步）
[root@proxy ~]# useradd -s /sbin/nologin  nginx
[root@proxy ~]# tar -xvf nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --user=nginx   --group=nginx \
> --with-http_ssl_module
[root@proxy ~]# make && make install
.. ..
3）安装MariaDB
Mariadb在新版RHEL7光盘中包含有该软件，配置yum源后可以直接使用yum安装：
[root@proxy ~]# yum -y install   mariadb   mariadb-server   mariadb-devel
4）php和php-fpm
[root@proxy ~]# yum -y  install  php   php-mysql
[root@proxy ~]# yum -y  install  php-fpm
步骤二：启动服务

1）启动Nginx服务（如果已经启动nginx，则可以忽略这一步）
这里需要注意的是，如果服务器上已经启动了其他监听80端口的服务软件（如httpd），则需要先关闭该服务，否则会出现冲突。
[root@proxy ~]# systemctl stop httpd                   //如果该服务存在则关闭该服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx             //启动Nginx服务
[root@proxy ~]# netstat -utnlp | grep :80
tcp    0    0 0.0.0.0:80        0.0.0.0:*        LISTEN        32428/nginx         
2）启动MySQL服务
[root@proxy ~]# systemctl start  mariadb           //启动服务器
[root@proxy ~]# systemctl status mariadb           //查看服务状态
[root@proxy ~]# systemctl enable mariadb           //设置开机启动
3）启动PHP-FPM服务
[root@proxy ~]# systemctl start php-fpm           //启动服务
[root@proxy ~]# systemctl status php-fpm          //查看服务状态
[root@proxy ~]# systemctl enable php-fpm          //设置开机启动
2 案例2：构建LNMP平台
2.1 问题

沿用练习一，通过调整Nginx服务端配置，实现以下目标：
配置Fast-CGI支持PHP网页
创建PHP测试页面，测试使用PHP连接数据库的效果
2.2 方案

使用2台RHEL7虚拟机，其中一台作为LNMP服务器（192.168.4.5）、另外一台作为测试用的Linux客户机（192.168.4.10），如图-1所示。

图-1
Nginx结合FastCGI技术即可支持PHP页面架构，如图-2所示。

图-2
因此本案例，需要延续练习一的实验内容，通过修改Nginx及php-fpm配置文件实现对PHP页面的支持。
注意，FastCGI的内存消耗问题，一个PHP-FPM解释器将消耗约25M的内存。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一： php-fpm配置文件

1）查看php-fpm配置文件（实验中不需要修改该文件）
[root@proxy etc]# vim /etc/php-fpm.d/www.conf
[www]
listen = 127.0.0.1:9000            //PHP端口号
pm.max_children = 32                //最大进程数量
pm.start_servers = 15                //最小进程数量
pm.min_spare_servers = 5            //最少需要几个空闲着的进程
pm.max_spare_servers = 32            //最多允许几个进程处于空闲状态
步骤二：修改Nginx配置文件并启动服务


如果用户访问的是静态,则找到文件直接返回
如果用户访问的是动态,则转发给9000执行脚本,再返回


  location 匹配浏览器的地址栏(从域名后开始)
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
location / {                          //匹配一切 优先级最低;
            root   html;              //找脚本
            index  index.php  index.html   index.htm;

location /abc {deny all}                     //拒绝所有
location /test {deny 192.168.1.1;allow all}   //拒绝1.1,允许其它所有



#设置默认首页为index.php，当用户在浏览器地址栏中只写域名或IP，不说访问什么页面时，服务器会把默认首页index.php返回给用户
        }
 location  ~  \.php$  {                      //支持正则 ~ 包含即可(如果用户访问浏览器的地址栏以.php结尾,那么执行{html找脚本转发给9000}里的)

            root           html;              #找脚本
            fastcgi_pass   127.0.0.1:9000;    #将请求转发给本机9000端口，PHP解释器
            fastcgi_index  index.php;          #首页
            #fastcgi_param   SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi.conf;       #加载其他配置文件
        }
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤三：创建PHP页面，测试LNMP架构能否解析PHP页面

1）创建PHP测试页面1，可以参考lnmp_soft/php_scripts/test.php：
[root@proxy ~]# vim /usr/local/nginx/html/test.php
<?php
$i="This is a test Page";
echo $i;
?>
2）创建PHP测试页面,连接并查询MariaDB数据库。
可以参考lnmp_soft/php_scripts/mysql.php:
[root@proxy ~]# vim /usr/local/nginx/html/mysql.php
<?php
$mysqli = new mysqli('localhost','root','密码','mysql');
//注意：root为mysql数据库的账户名称，密码需要修改为实际mysql密码，无密码则留空即可
//localhost是数据库的域名或IP，mysql是数据库的名称
if (mysqli_connect_errno()){
    die('Unable to connect!'). mysqli_connect_error();
}
$sql = "select * from user";
$result = $mysqli->query($sql);
while($row = $result->fetch_array()){
    printf("Host:%s",$row[0]);
    printf("</br>");
    printf("Name:%s",$row[1]);
    printf("</br>");
}
?>
3）客户端使用浏览器访问服务器PHP首页文档，检验是否成功：
[root@client ~]# firefox http://192.168.4.5/test.php
[root@client ~]# firefox http://192.168.4.5/mysql.php
4）LNMP常见问题
Nginx的默认访问日志文件为/usr/local/nginx/logs/access.log
Nginx的默认错误日志文件为/usr/local/nginx/logs/error.log
PHP默认错误日志文件为/var/log/php-fpm/www-error.log
如果动态网站访问失败，可用参考错误日志，查找错误信息。

3 案例3：地址重写
3.1 问题

沿用练习二，通过调整Nginx服务端配置，实现以下目标：
所有访问a.html的请求，重定向到b.html;
所有访问192.168.4.5的请求重定向至www.tmooc.cn；
所有访问192.168.4.5/下面子页面，重定向至www.tmooc.cn/下相同的页面；
实现firefox与curl访问相同页面文件，返回不同的内容。
3.2 方案

关于Nginx服务器的地址重写，主要用到的配置参数是rewrite：
rewrite regex replacement flag   //regex-->支持正则表达式
rewrite 旧地址 新地址 [选项]
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：修改配置文件(访问a.html重定向到b.html)

1）修改Nginx服务配置：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite /a.html  /b.html;            
location / {
    root   html;
index  index.html index.htm;
}
}
[root@proxy ~]# echo "BB" > /usr/local/nginx/html/b.html
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
3）客户端测试
[root@client ~]# firefox  http://192.168.4.5/a.html
步骤二：访问a.html重定向到b.html（跳转地址栏）

1）修改Nginx服务配置：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite /a.html  /b.html  redirect;  // redirect选项是将地址栏跳到网页实际的地址          
location / {
    root   html;
index  index.html index.htm;
}
}
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端测试（仔细观察浏览器地址栏的变化）
[root@client ~]# firefox  http://192.168.4.5/a.html
步骤三：修改配置文件(访问192.168.4.5的请求重定向至www.tmooc.cn)

1) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite ^/  http://www.tmooc.cn/;
location / {
    root   html;
index  index.html index.htm;
# rewrite /a.html  /b.html  redirect;
}
}
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端测试（真实机测试，真实机才可以连接tmooc）
[root@room9pc01 ~]# firefox  http://192.168.4.5
步骤四：修改配置文件(访问192.168.4.5/下面子页面，重定向至www.tmooc.cn/下相同的页面)

1) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite ^/(.*)$  http://www.tmooc.cn/$1;     //(.*)保留 $1相当于复制;
location / {
    root   html;
index  index.html index.htm;
}
}
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端测试（真实机测试，真实机才可以连接tmooc）
[root@room9pc01 ~]# firefox  http://192.168.4.5
[root@room9pc01 ~]# firefox  http://192.168.4.5/test
步骤五：修改配置文件(实现curl和火狐访问相同链接返回的页面不同)
1) 创建网页目录以及对应的页面文件：
[root@proxy ~]# echo "I am Normal page" > /usr/local/nginx/html/test.html
[root@proxy ~]# mkdir  -p  /usr/local/nginx/html/firefox/
[root@proxy ~]# echo "firefox page" > /usr/local/nginx/html/firefox/test.html
2) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
location / {
    root   html;
index  index.html index.htm;
}

if ($http_user_agent ~* firefox) {            //识别客户端firefox浏览器
rewrite ^(.*)$  /firefox/$1;                  //这里，~符号代表正则匹配，*符号代表不区分大小写
}
}
3）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
4）客户端测试
[root@client ~]# firefox  http://192.168.4.5/test.html
[root@client ~]# curl     http://192.168.4.5/test.html
5）地址重写格式【总结】
rewrite 旧地址 新地址 [选项];
last 不再读其他rewrite
break 不再读其他语句，结束请求
redirect 临时重定向
permament 永久重定向

##########################################################################################

date 3

Top
NSD Operation DAY03

案例1：Nginx反向代理
案例2：Nginx的TCP/UDP调度器
案例3：Nginx常见问题处理
1 案例1：Nginx反向代理
1.1 问题

使用Nginx实现Web反向代理功能，实现如下功能：
后端Web服务器两台，可以使用httpd实现
Nginx采用轮询的方式调用后端Web服务器
两台Web服务器的权重要求设置为不同的值
最大失败次数为1，失败超时时间为30秒
1.2 方案

使用4台RHEL7虚拟机，其中一台作为Nginx代理服务器，该服务器需要配置两块网卡，IP地址分别为192.168.4.5和192.168.2.5，两台Web服务器IP地址分别为192.168.2.100和192.168.2.200。客户端测试主机IP地址为192.168.4.10。如图-1所示。

图-1
1.3 步骤                                           
                                                            --------------->web1(eth1 192.168.2.100)
                                                                             |
                            nginx代理服务器                        |
   client ----------------->proxy ---------------------------
 eth0 192.168.4.10       eth0 192.168.4.5                   |
                         eth1 192.168.2.5                   |
                                                            ---------------->web2(eth1 192.168.2.200)

实现此案例需要按照如下步骤进行。
步骤一：部署实施后端Web服务器

1）部署后端Web1服务器
后端Web服务器可以简单使用yum方式安装httpd实现Web服务，为了可以看出后端服务器的不同，可以将两台后端服务器的首页文档内容设置为不同的内容。
[root@web1 ~]# yum  -y  install  httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
[root@web1 ~]# systemctl restart httpd
[root@web1 ~]# firewall-cmd --set-default-zone=trusted
[root@web1 ~]# setenforce 0
2）部署后端Web2服务器
[root@web2 ~]# yum  -y  install  httpd
[root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html
[root@web2 ~]# systemctl restart httpd
[root@web2 ~]# firewall-cmd --set-default-zone=trusted
[root@web2 ~]# setenforce 0
步骤二：配置Nginx服务器，添加服务器池，实现反向代理功能

1）修改/usr/local/nginx/conf/nginx.conf配置文件
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
.. ..
#使用upstream定义后端服务器集群，集群名称任意(如webserver)
#使用server定义集群中的具体服务器和端口
upstream webserver {
                server 192.168.2.100:80;
                server 192.168.2.200:80;
        }
.. ..
server {
        listen        80;
        server_name  localhost;
            location / {
#通过proxy_pass将用户的请求转发给webserver集群
            proxy_pass http://webserver;
        }
}
2）重新加载配置
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
步骤二：配置upstream服务器集群池属性

1）设置失败次数，超时时间，权重
weight可以设置后台服务器的权重，max_fails可以设置后台服务器的失败次数，fail_timeout可以设置后台服务器的失败超时时间。
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
.. ..
upstream webserver {
                server 192.168.2.100 weight=1 max_fails=1 fail_timeout=30;
                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=30;
                server 192.168.2.101 down;
        }
#weight设置服务器权重值，默认值为1
#max_fails设置最大失败次数
#fail_timeout设置失败超时时间，单位为秒
#down标记服务器已关机，不参与集群调度
.. ..
server {
        listen        80;
        server_name  localhost;
            location / {
            proxy_pass http://webserver;
        }
}
2）重新加载配置
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）关闭一台后端服务器（如web1）
[root@web1 ~]# systemctl stop httpd
4）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
5）再次启动后端服务器的httpd（如web1）
[root@web1 ~]# systemctl start httpd
6）客户端再次使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
步骤三：配置upstream服务器集群的调度算法

1）设置相同客户端访问相同Web服务器
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
.. ..
upstream webserver {
#通过ip_hash设置调度规则为：相同客户端访问相同服务器
                 ip_hash;
                server 192.168.2.100 weight=1 max_fails=2 fail_timeout=10;
                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=10;
        }
.. ..
server {
        listen        80;
        server_name  www.tarena.com;
            location / {
            proxy_pass http://webserver;
        }
}
2）重新加载配置
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果


2 案例2：Nginx的TCP/UDP调度器

2.1 问题

使用Nginx实现TCP/UDP调度器功能，实现如下功能：
后端SSH服务器两台
Nginx编译安装时需要使用--with-stream，开启ngx_stream_core_module模块
Nginx采用轮询的方式调用后端SSH服务器
2.2 方案

使用4台RHEL7虚拟机，其中一台作为Nginx代理服务器，该服务器需要配置两块网卡，IP地址分别为192.168.4.5和192.168.2.5，两台SSH服务器IP地址分别为192.168.2.100和192.168.2.200。客户端测试主机IP地址为192.168.4.10。如图-2所示。

图-2
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署支持4层TCP/UDP代理的Nginx服务器

1）部署nginx服务器
编译安装必须要使用--with-stream参数开启4层代理模块。
[root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        //安装依赖包
[root@proxy ~]# tar  -xf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd  nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --with-http_ssl_module                                //开启SSL加密功能
> --with-stream                                       //开启4层反向代理功能
[root@proxy nginx-1.12.2]# make && make install           //编译并安装
步骤二：配置Nginx服务器，添加服务器池，实现TCP/UDP反向代理功能


注意: stream不要在http{}里:

1）修改/usr/local/nginx/conf/nginx.conf配置文件
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
stream {
            upstream backend {
               server 192.168.2.100:22;            //后端SSH服务器的IP和端口
               server 192.168.2.200:22;
}
            server {
                listen 12345;                    //Nginx监听的端口
                proxy_connect_timeout 1s;         //连接的超时时间，可选配置
                proxy_timeout 3s;
                 proxy_pass backend;
             }
}
http {
.. ..
}
2）重新加载配置
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端使用访问代理服务器测试轮询效果
[root@client ~]# ssh 192.168.4.5 -p 12345            //使用该命令多次访问查看效果,-p 指定端口号
3 案例3：Nginx常见问题处理
3.1 问题

本案例要求对Nginx服务器进行适当优化，解决如下问题，以提升服务器的处理性能：
如何自定义返回给客户端的404错误页面
如何查看服务器状态信息
如果客户端访问服务器提示“Too many open files”如何解决
如何解决客户端访问头部信息过长的问题
如何让客户端浏览器缓存数据
日志切割
开启gzip压缩功能，提高数据传输效率
开启文件缓存功能
然后客户机访问此Web服务器验证效果：
使用ab压力测试软件测试并发量
编写测试脚本生成长头部信息的访问请求
客户端访问不存在的页面，测试404错误页面是否重定向
3.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：自定义报错页面

1）优化前，客户端使用浏览器访问不存在的页面，会提示404文件未找到
[root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面
2）修改Nginx配置文件，自定义报错页面
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
        charset utf-8;                    //仅需要中文时需要改选项，可选项
error_page   404  /404.html;    //自定义错误页面
.. ..
[root@proxy ~]# vim /usr/local/nginx/html/404.html        //生成错误页面
Oops,No NO no page …
[root@proxy ~]# nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）优化后，客户端使用浏览器访问不存在的页面，会提示自己定义的40x.html页面
[root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面
4）常见http状态码
常见http状态码可用参考表-1所示。
表－1 主机列表
200   一切正常
301   永久重定向
302   临时重定向
401   用户名或密码错误
403   禁止访问(客户端IP地址被拒绝)
404   文件不存在
414   请求URI头部过长
500   服务器内部错误
502   Bad Gateway


步骤二：如何查看服务器状态信息（非常重要的功能）

1）编译安装时使用--with-http_stub_status_module开启状态页面模块
[root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd  nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --with-http_ssl_module                        //开启SSL加密功能
> --with-stream                                //开启TCP/UDP代理模块
> --with-http_stub_status_module                //开启status状态页面
[root@proxy nginx-1.12.2]# make && make install    //编译并安装
2）启用Nginx服务并查看监听端口状态
ss命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）
注意：在RHEL7系统中可以使用ss命令替代netstat命令，功能一样，选项一样。
[root@proxy ~]# /usr/local/nginx/sbin/nginx
[root@proxy ~]# netstat  -anptu  |  grep nginx
tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx
[root@proxy ~]# ss  -anptu  |  grep nginx
3）修改Nginx配置文件，定义状态页面
[root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
… …
location /status {
                stub_status on;
                 #allow IP地址;
                 #deny IP地址;
        }
… …
[root@proxy ~]# nginx
4）优化后，查看状态页面信息
[root@proxy ~]# curl  http://192.168.4.5/status
Active connections: 1 
server accepts handled requests   //总值,只增不减
 10 10 3 
Reading: 0 Writing: 1 Waiting: 0
Active connections：当前活动的连接数量(并发量)。
Accepts：已经接受客户端的连接总数量。
Handled：已经处理客户端的连接总数量。
（一般与accepts一致，除非服务器限制了连接数量）。
Requests：客户端发送的请求数量。
Reading：当前服务器正在读取客户端请求头的数量。
Writing：当前服务器正在写响应信息的数量。
Waiting：当前多少客户端在等待服务器的响应。

步骤三：优化Nginx并发量

1）优化前使用ab高并发测试
[root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/   //httpd-tools获得ab命令
               -n 总访问量  -c 人数
Benchmarking 192.168.4.5 (be patient)
socket: Too many open files (24)                //提示打开文件数量过多
2）修改Nginx配置文件，增加并发量
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
worker_processes  2;                    //nginx启动时启动的进程 与CPU核心数量一致
events {
worker_connections 65535;        //每个worker最大并发连接数 (linux端口号最大是65536)
}
.. ..
[root@proxy ~]# nginx -s reload
3）优化Linux内核参数（最大文件数量）
[root@proxy ~]# ulimit -a                        //查看所有属性值
[root@proxy ~]# ulimit -Hn 100000                //设置硬限制（临时规则）
[root@proxy ~]# ulimit -Sn 100000                //设置软限制（临时规则）
[root@proxy ~]# vim /etc/security/limits.conf
    .. ..
*               soft    nofile            100000
*               hard    nofile            100000
#该配置文件分4列，分别如下：
#用户或组    硬限制或软限制    需要限制的项目   限制的值
4）优化后测试服务器并发量（因为客户端没调内核参数，所以在proxy测试）
[root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/
步骤四：优化Nginx数据包头缓存

1）优化前，使用脚本测试长头部请求是否能获得响应
[root@proxy ~]# cat lnmp_soft/buffer.sh 
#!/bin/bash
URL=http://192.168.4.5/index.html?
for i in {1..5000}
do
    URL=${URL}v$i=$i
done
curl $URL                                //经过5000次循环后，生成一个长的URL地址栏
[root@proxy ~]# ./buffer.sh
.. ..
<center><h1>414 Request-URI Too Large</h1></center>        //提示头部信息过大
2）修改Nginx配置文件，增加数据包头部缓存大小
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
client_header_buffer_size    1k;        //默认请求包头信息的缓存    
large_client_header_buffers  4 4k;        //大请求包头部信息的缓存个数与容量
.. ..
}
[root@proxy ~]# nginx -s reload
3）优化后，使用脚本测试长头部请求是否能获得响应
[root@proxy ~]#cat cat buffer.sh 
#!/bin/bash
URL=http://192.168.4.5/index.html?
for i in {1..5000}
do
    URL=${URL}v$i=$i
done
curl $URL
[root@proxy ~]# ./buffer.sh

步骤五：浏览器本地缓存静态数据

1）使用Firefox浏览器查看缓存
以Firefox浏览器为例，在Firefox地址栏内输入about:cache将显示Firefox浏览器的缓存信息，如图-3所示，点击List Cache Entries可以查看详细信息。

图-3
2）清空firefox本地缓存数据，如图-4所示。


图-4
3）修改Nginx配置文件，定义对静态页面的缓存时间
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
server {
        listen       80;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }
location ~* \.(jpg|jpeg|gif|png|css|js|ico|xml)$ {
expires        30d;            //定义客户端缓存时间为30天  ~ 包含 * 忽略大小写
}
}
[root@proxy ~]# cp /usr/share/backgrounds/day.jpg /usr/local/nginx/html
[root@proxy ~]# nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
4）优化后，使用Firefox浏览器访问图片，再次查看缓存信息
[root@client ~]# firefox http://192.168.4.5/day.jpg
在firefox地址栏内输入about:cache，查看本地缓存数据，查看是否有图片以及过期时间是否正确。

步骤六：日志切割

日志文件越来越大怎么办？单个文件10G? 如何切割？（非常常见的面试题）
步骤：1. 把旧的日志重命名
2. kill USR1 PID(nginx的进程PID号)    //生成新的日志
1）手动执行
备注：/usr/local/nginx/logs/nginx.pid文件中存放的是nginx的进程PID号。
[root@proxy ~]#  mv access.log access2.log
[root@proxy ~]# kill -USR1 $(cat /usr/local/nginx/logs/nginx.pid) //生成新的日志
2）自动完成
每周5的03点03分自动执行脚本完成日志切割工作。
[root@proxy ~]# vim /usr/local/nginx/logbak.sh
#!/bin/bash
date=`date +%Y%m%d`
logpath=/usr/local/nginx/logs
mv $logpath/access.log $logpath/access-$date.log
mv $logpath/error.log $logpath/error-$date.log
kill -USR1 $(cat $logpath/nginx.pid)
[root@proxy ~]# crontab -e
03 03 * * 5  /usr/local/nginx/logbak.sh
步骤七：对页面进行压缩处理

1）修改Nginx配置文件
[root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
http {
.. ..
gzip on;                            //开启压缩
gzip_min_length 1000;                //小文件不压缩
gzip_comp_level 4;                //压缩比率
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
                                    //对特定文件压缩，类型参考mime.types(/usr/local/nginx/conf/mime.types)
.. ..
}
步骤八：服务器内存缓存

1）如果需要处理大量静态文件，可以将文件缓存在内存，下次访问会更快。
http { 
open_file_cache          max=2000  inactive=20s;
        open_file_cache_valid    60s;
        open_file_cache_min_uses 5;
        open_file_cache_errors   off;
//设置服务器最大缓存2000个文件句柄，关闭20秒内无请求的文件句柄
//文件句柄的有效时间是60秒，60秒后过期
//只有访问次数超过5次会被缓存
//缓存报错日志关闭
} 

###########################################################################

Top
NSD OPERATION DAY04

案例1：PHP的本地Session信息
案例2：构建memcached服务
案例3：LNMP+memcached
案例4：PHP实现session共享
1 案例1：PHP的本地Session信息
1.1 问题

通过Nginx调度器负载后端两台Web服务器，实现以下目标：
部署Nginx为前台调度服务器
调度算法设置为轮询
后端为两台LNMP服务器
部署测试页面，查看PHP本地的Session信息
1.2 方案

概念：
Session：存储在服务器端，保存用户名、登陆状态等信息。
Cookies：由服务器下发给客户端，保存在客户端的一个文件里。
保存的内容主要包括：SessionID。
实验拓扑环境：
使用4台RHEL7虚拟机，其中一台作为Nginx前端调度器服务器（eth0:192.168.4.5,eth1:192.168.2.5）、两台虚拟机部署为LNMP服务器，分别为Web1服务器（192.168.2.100）和Web2服务器（192.168.2.200），另外一台作为测试用的Linux客户机（192.168.4.10），拓扑如图-2所示。

图-2
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署后端LNMP服务器相关软件

注意:以下部署LNMP服务器的操作，需要在两台后端服务器做相同的操作，下面我们以一台Web2服务器（192.168.2.200）为例，对Web1服务器执行相同操作即可。
1）使用yum安装基础依赖包
[root@web2 ~]# yum -y install gcc openssl-devel pcre-devel
.. ..
2）源码安装Nginx
[root@web2 ~]# tar -xf nginx-1.12.2.tar.gz
[root@web2 ~]# cd nginx-1.12.2
[root@web2 nginx-1.12.2]#  ./configure   \
> --with-http_ssl_module 
[root@web2 nginx-1.12.2]# make && make install
3）安装MariaDB数据库
[root@web2 ~]# yum -y install  mariadb  mariadb-server  mariadb-devel
4）安装PHP
[root@web2 ~]# yum -y install  php  php-mysql
[root@web2 ~]# yum -y install  php-fpm
5）修改Nginx配置文件（修改默认首页与动静分离）
[root@web2 ~]# vim /usr/local/nginx/conf/nginx.conf
location / {
            root   html;
            index  index.php  index.html   index.htm;
        }
 location  ~  \.php$  {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
           # fastcgi_param   SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi.conf;
        }
步骤二：启动LNMP服务器相关的服务

1）启动Nginx服务
这里需要注意的是，如果服务器上已经启动了其他监听80端口的服务软件（如httpd），则需要先关闭该服务，否则会出现冲突。
[root@web2 ~]# systemctl stop  httpd                //如果该服务存在，则关闭该服务
[root@web2 ~]# /usr/local/nginx/sbin/nginx
[root@web2 ~]# netstat -utnlp | grep :80
tcp    0    0 0.0.0.0:80        0.0.0.0:*        LISTEN        32428/nginx         
2）启动MySQL服务
[root@web2 ~]# systemctl start mariadb
[root@web2 ~]# systemctl status mariadb
3）启动PHP-FPM服务
[root@web2 ~]# systemctl start  php-fpm
[root@web2 ~]# systemctl status php-fpm
步骤三：部署前端Nginx调度服务器

1）使用源码安装nginx软件（如果Nginx软件包已安装可以忽略此步骤）
[root@proxy ~]# yum  -y  install   gcc pcre-devel openssl-devel
[root@proxy ~]# tar -xf nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure
[root@proxy nginx-1.12.2]# make && make install
2）修改Nginx配置文件，实现代理服务器
Nginx配置文件中，通过upstream定义后端服务器地址池，默认调度策略为轮询，使用proxy_pass调用upstream定义的服务器地址池：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
upstream webs  {
        server 192.168.2.100:80;
        server 192.168.2.200:80;
  }
 server  {
          listen       80;
          server_name  localhost;
          location  /  {
              proxy_pass http://webs;
            root   html;
            index  index.php index.html index.htm;
          }
}
3）重新加载配置文件

[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤四：测试环境是否配置成功

1）浏览器访问测试页面验证。
[root@client ~]# curl  http://192.168.4.5/index.html        //查看是否有数据
步骤五：部署测试页面

1）部署测试页面(Web1服务器）。
测试页面可以参考lnmp_soft/php_scripts/php-memcached-demo.tar.gz。
[root@web1 ~]# cd lnmp_soft/php_scripts/
[root@web1 php_scripts]# tar -xf php-memcached-demo.tar.gz
[root@web1 php_scripts]# cd php-memcached-demo
[root@web1 php-memcached-demo]# cp -r  *  /usr/local/nginx/html/
2）浏览器直接访问后端服务器的测试页面（Web1服务器）。
[root@web1 ~]# firefox http://192.168.2.100            //填写账户信息
[root@web1 ~]# cd /var/lib/php/session/            //查看服务器本地的Session信息
[root@web1 ~]# ls
sess_ahilcq9bguot0vqsjtd84k7244                        //注意这里的ID是随机的
[root@web1 ~]# cat sess_ahilcq9bguot0vqsjtd84k7244
注意：可用修改index.php和home.php两个文件的内容，添加页面颜色属性，以区别后端两台不同的服务器:<body bgcolor=blue>。
3）部署测试页面(Web2服务器）。
测试页面可以参考lnmp_soft/php_scripts/php-memcached-demo.tar.gz。
[root@web2 ~]# cd lnmp_soft/php_scripts/
[root@web2 php_scripts]# tar -xf php-memcached-demo.tar.gz
[root@web2 php_scripts]# cd php-memcached-demo
[root@web2 php-memcached-demo]# cp -a  *  /usr/local/nginx/html/
4）浏览器直接访问后端服务器的测试页面（Web2服务器）。
[root@web2 ~]# firefox http://192.168.2.100             //填写账户信息
[root@web2 ~]# cd /var/lib/php/session/            //查看服务器本地的Session信息
[root@web2 ~]# ls
sess_qqek1tmel07br8f63d6v9ch401                        //注意这里的ID是随机的
[root@web2 ~]# cat sess_qqek1tmel07br8f63d6v9ch401    
注意：可用修改index.php和home.php两个文件的内容，添加页面颜色属性，以区别后端两台不同的服务器:<body bgcolor=green>。
5）浏览器访问前端调度器测试（不同后端服务器Session不一致）。
推荐使用google浏览器测试。
[root@client ~]# google-chrome http://192.168.4.5
//填写注册信息后，刷新，还需要再次注册，说明两台计算机使用的是本地Session
//第二台主机并不知道你再第一台主机已经登录，第一台主机的登录信息也没有传递给第二台主机

2 案例2：构建memcached服务
2.1 问题

本案例要求先快速搭建好一台memcached服务器，并对memcached进行简单的增、删、改、查操作：
安装memcached软件，并启动服务
使用telnet测试memcached服务
对memcached进行增、删、改、查等操作
2.2 方案

使用1台RHEL7虚拟机作为memcached服务器（192.168.4.5）。
在RHEL7系统光盘中包含有memcached，因此需要提前配置yum源，即可直接使用yum安装，客户端测试时需要提前安装telnet远程工具。
验证时需要客户端主机安装telnet，远程memcached来验证服务器的功能：
add name 0 180 10	//变量不存在则添加
set name 0 180 10	//添加或替换变量
replace name 0 180 10	//替换(覆盖现有的变量)
get name	//读取变量
append name 0 180 10	//向变量中追加数据
delete name	//删除变量
flush_all	//清空所有
提示：0表示不压缩，180为数据缓存时间，10为需要存储的数据字节数量。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：构建memcached服务

1）使用yum安装软件包memcached
[root@proxy ~]# yum -y  install   memcached
[root@proxy ~]# rpm -qa memcached
memcached-1.4.15-10.el7_3.1.x86_64
2) memcached配置文件（查看即可，不需要修改）
[root@proxy ~]# vim /usr/lib/systemd/system/memcached.service
ExecStart=/usr/bin/memcached -u $USER -p $PORT -m $CACHESIZE -c $MAXCONN $OPTIONS   //-u 用户 -p 端口 -m 内存 -c 最大连接数
[root@proxy ~]# vim /etc/sysconfig/memcached
PORT="11211"
USER="memcached"
MAXCONN="1024"
CACHESIZE="64"
OPTIONS=""
3）启动服务并查看网络连接状态验证是否开启成功：
ss命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）
注意：在RHEL7系统中，使用ss命令可以替代netstat，功能与选项一样。
[root@proxy ~]# systemctl  start  memcached
[root@proxy ~]# systemctl  status  memcached
[root@proxy ~]# netstat  -anptu  |  grep memcached
tcp    0    0 0.0.0.0:11211        0.0.0.0:*        LISTEN        2839/memcached      
tcp    0    0 :::11211            :::*                LISTEN        2839/memcached      
udp    0    0 0.0.0.0:11211        0.0.0.0:*                    2839/memcached      
udp    0    0 :::11211            :::*                            2839/memcached
[root@proxy ~]# setenforce 0
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
步骤二：使用telnet访问memcached服务器

1）使用yum安装telnet
[root@proxy ~]# yum -y install telnet
2)使用telnet连接服务器测试memcached服务器功能，包括增、删、改、查等操作。  //增(add,set,replace)、删(delete)、改(append)、查(get)
[root@proxy ~]# telnet  192.168.4.5  11211
Trying 192.168.4.5...
……
##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
set name 0 180 3                //定义变量，变量名称为name
plj                            //输入变量的值，值为plj                
STORED
get name                        //获取变量的值
VALUE name 0 3                 //输出结果
plj
END
##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
add myname 0 180 10            //新建，myname不存在则添加，存在则报错
set myname 0 180 10            //添加或替换变量
replace myname 0 180 10        //替换，如果myname不存在则报错
get myname                    //读取变量
append myname 0 180 10        //向变量中追加数据
delete myname                    //删除变量
flush_all                        //清空所有
quit                            //退出登录          
                        
3 案例3：LNMP+memcached
3.1 问题

沿用练习一和练习二，部署LNMP+memcached网站平台,通过PHP页面实现对memcached服务器的数据操作，实现以下目标：
为PHP安装memcache扩展
创建PHP页面，并编写PHP代码，实现对memcached的数据操作
3.2 方案

如果希望使用PHP来操作memcached，注意必须要为PHP安装memcache扩展（php-pecl-memcache），否则PHP无法解析连接memcached的指令。客户端测试时需要提前安装telnet远程工具。
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：创建PHP页面，使用PHP语言测试memcached服务

1）部署测试页面
创建PHP首页文档/usr/local/nginx/html/mem.php，测试页面可以参考lnmp_soft/php_scripts/mem.php。
注意：192.168.2.5是memcached数据库。
 [root@web1 ~]# vim /usr/local/nginx/html/mem.php
<?php
$memcache=new Memcache;                //创建memcache对象
$memcache->connect('192.168.2.5',11211) or die ('could not connect!!');
$memcache->set('key','test');             //定义变量
$get_values=$memcache->get('key');        //获取变量值
echo $get_values;
?>
2）客户端测试（结果会失败）
客户端使用浏览器访问服务器PHP首页文档，检验对memcached的操作是否成功：
[root@web1 ~]# firefox http://192.168.2.100/mem.php
注意：这里因为没有给PHP安装扩展包，默认PHP无法连接memcached数据库，需要给PHP安装扩展模块才可以连接memcached数据库。
3）为PHP添加memcache扩展
[root@web1 ~]# yum -y install  php-pecl-memcache
[root@web1 ~]# systemctl restart php-fpm
4）客户端再次测试（结果会成功显示数据结果）
[root@web1 ~]# firefox http://192.168.2.100/mem.php


4 案例4：PHP实现session共享
4.1 问题

沿用练习三，通过修改PHP-FPM配置文件，实现session会话共享：
配置PHP使用memcached服务器共享Session信息
客户端访问两台不同的后端Web服务器时，Session 信息一致
4.2 方案

在练习三拓扑的基础上，Nginx服务器除了承担调度器外，还需要担任memcached数据库的角色，并在两台后端LNMP服务器上实现PHP的session会话共享。拓扑结构如图-4所示。

图-4
4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：在后端LNMP服务器上部署Session共享

注意：这些操作在两台后端Web服务器上均需要执行，以下操作以Web1（192.168.2.100）服务器为例。
1）为PHP添加memcache扩展
注意，因为后端两台web服务器(web1,web2)都需要连接memcached数据库，所以两台主机都需要安装PHP扩展模块(下面也web1为例)。
[root@web1 ~]# yum -y install  php-pecl-memcache
2）修改PHP-FPM配置文件，并重启服务
注意，因为后端两台web服务器(web1,web2)都需要修改配置文件(下面也web1为例)。
[root@web1 ~]# vim  /etc/php-fpm.d/www.conf            //修改该配置文件的两个参数
//文件的最后2行
修改前效果如下:
php_value[session.save_handler] = files
php_value[session.save_path] = /var/lib/php/session
//原始文件，默认定义Sessoin会话信息本地计算机（默认在/var/lib/php/session）
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
修改后效果如下:
php_value[session.save_handler] = memcache
php_value[session.save_path] = "tcp://192.168.2.5:11211"
//定义Session信息存储在公共的memcached服务器上，主机参数中为memcache（没有d）
//通过path参数定义公共的memcached服务器在哪（服务器的IP和端口）
[root@web1 ~]# systemctl  restart  php-fpm
步骤三：客户端测试

客户端使用浏览器访问两台不同的Web服务器。
操作步骤参考练习一，最终可以获得相关的Session ID信息。

################################################################################



Top
NSD OPERATION DAY05

案例1：安装部署Tomcat服务器
案例2：使用Tomcat部署虚拟主机
案例3：使用Varnish加速Web

java SE(标准版)
java EE(企业版)
java ME(移动版)


httpd,nginx,...(PHP , python) 网站
LNMP  , LAMP

java支持的网站: (sun) ---Oracle  
tomcat(Apache开源),weblogic(Oracle),websphere(IBM),jboss(redhat)

1 案例1：安装部署Tomcat服务器
1.1 问题

本案例要求部署Tomcat服务器，具体要求如下：
安装部署JDK基础环境
安装部署Tomcat服务器
创建JSP测试页面，文件名为test.jsp，显示服务器当前时间
然后客户机访问此Web服务器验证效果：
使用火狐浏览器访问Tomcat服务器的8080端口，浏览默认首页
使用火狐浏览器访问Tomcat服务器的8080端口，浏览默认测试页面
1.2 方案

使用2台RHEL7虚拟机，其中一台作为Tomcat服务器（192.168.2.100）、另外一台作为测试用的Linux客户机（192.168.2.5），如图-1所示。

图-1
使用RPM安装JDK基础环境
使用源码安装部署Tomcat服务器
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署Tomcat服务器软件(192.168.2.100/24)

1）使用RPM安装JDK环境
[root@web1 ~]# yum -y install  java-1.8.0-openjdk                //安装JDK
[root@web1 ~]# yum -y install java-1.8.0-openjdk-headless        //安装JDK
[root@web1 ~]# java -version                                    //查看JAVA版本
2）安装Tomcat（apache-tomcat-8.0.30.tar.gz软件包，在lnmp_soft中有提供）
[root@web1 ~]# tar -xf  apache-tomcat-8.0.30.tar.gz
[root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
[root@web1 ~]# ls /usr/local/tomcat
bin/                                            //主程序目录
lib/                                            //库文件目录
logs/                                          //日志目录  
temp/                                         //临时目录
work/                                        //自动编译目录jsp代码转换servlet
conf/                                        //配置文件目录
webapps/                                        //页面目录
3）启动服务
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
4）服务器验证端口信息
[root@web1 ~]# netstat -nutlp |grep java        //查看java监听的端口
tcp        0      0 :::8080              :::*                LISTEN      2778/java 
tcp        0      0 :::8009              :::*                LISTEN      2778/java                     
tcp        0      0 ::ffff:127.0.0.1:8005     :::*         LISTEN       2778/java 
提示：如果检查端口时，8005端口启动非常慢，默认tomcat启动需要从/dev/random读取大量的随机数据，默认该设备生成随机数据的速度很慢，可用使用下面的命令用urandom替换random（非必须操作）。
[root@web1 ~]# mv /dev/random  /dev/random.bak
[root@web1 ~]# ln -s /dev/urandom  /dev/random
另外，还可以使用方案二解决：
[root@web1 ~]# yum install rng-tools
[root@web1 ~]# systemctl start rngd
[root@web1 ~]# systemctl enable rngd
5）客户端浏览测试页面(proxy作为客户端)
[root@proxy ~]# firefox http://192.168.2.100:8080
步骤二：修改Tomcat配置文件

1）创建测试JSP页面
[root@web1 ~]# vim  /usr/local/tomcat/webapps/ROOT/test.jsp
<html>
<body>
<center>
Now time is: <%=new java.util.Date()%>            //显示服务器当前时间
</center>
</body>
</html>
步骤三：验证测试

1）客户端浏览测试页面(proxy充当客户端角色)
[root@proxy ~]# firefox http://192.168.2.100:8080
[root@proxy ~]# firefox http://192.168.2.100:8080/test.jsp


2 案例2：使用Tomcat部署虚拟主机
2.1 问题

沿用练习二，使用Tomcat部署加密虚拟主机，实现以下要求：
实现两个基于域名的虚拟主机，域名分别为：www.a.com和 www.b.com
使用www.a.com域名访问的页面根路径为/usr/local/tomcat/a/ROOT
使用www.b.com域名访问的页面根路径为/usr/local/tomcat/b/base
访问www.a.com/test时，页面自动跳转到/var/www/html目录下的页面
访问页面时支持SSL加密通讯
私钥、证书存储路径为/usr/local/tomcat/conf/cert
每个虚拟主机都拥有独立的访问日志文件
配置tomcat集群环境
2.2 方案

修改server.xml配置文件，创建两个域名的虚拟主机，修改如下两个参数块：
# cat /usr/local/tomcat/conf/server.xml
<Server>
   <Service>
     <Connector port=8080 />
     <Connector port=8009 />
     <Engine name="Catalina" defaultHost="localhost">
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
</Host>
… …
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置服务器虚拟主机

1）修改server.xml配置文件，创建虚拟主机
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
</Host>
2）创建虚拟主机对应的页面根路径
[root@web1 ~]# mkdir -p  /usr/local/tomcat/{a,b}/ROOT
[root@web1 ~]# echo "AAA"   > /usr/local/tomcat/a/ROOT/index.html
[root@web1 ~]# echo "BBB" > /usr/local/tomcat/b/ROOT/index.html
3）重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
4）客户端设置host文件，并浏览测试页面进行测试(proxy充当客户端角色)
注意：ssh远程连接时使用使用-X参数才可以！！！
[root@proxy ~]# vim /etc/hosts
… …
192.168.2.100      www.a.com  www.b.com
[root@proxy ~]# firefox http://www.a.com:8080/        //注意访问的端口为8080
[root@proxy ~]# firefox http://www.b.com:8080/
步骤二：修改www.b.com网站的首页目录为base

1）使用docBase参数可以修改默认网站首页路径
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base"/>
</Host>
… …
[root@web1 ~]# mkdir  /usr/local/tomcat/b/base
[root@web1 ~]# echo "BASE" > /usr/local/tomcat/b/base/index.html
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
2）测试查看页面是否正确(proxy充当客户端角色)
[root@proxy ~]# firefox http://www.b.com:8080/        //结果为base目录下的页面内容
步骤三：跳转

1）当用户访问http://www.a.com/test打开/var/www/html目录下的页面
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
<Context path="/test" docBase="/var/www/html/" />
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base" />
</Host>
… …
[root@web1 ~]# echo "Test" > /var/www/html/index.html
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
2）测试查看页面是否正确(proxy充当客户端角色)
[root@proxy ~]# firefox http://www.a.com:8080/test    
//返回/var/www/html/index.html的内容
//注意，访问的端口为8080
步骤四：配置Tomcat支持SSL加密网站

1）创建加密用的私钥和证书文件
[root@web1 ~]# keytool -genkeypair -alias tomcat -keyalg RSA -keystore /usr/local/tomcat/keystore                //提示输入密码为:123456
//-genkeypair     生成密钥对
//-alias tomcat     密钥别名
//-keyalg RSA     定义密钥算法为RSA算法
//-keystore         定义密钥文件存储在:/usr/local/tomcat/keystore
2)再次修改server.xml配置文件，创建支持加密连接的Connector
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
maxThreads="150" SSLEnabled="true" scheme="https" secure="true"
keystoreFile="/usr/local/tomcat/keystore" keystorePass="123456" clientAuth="false" sslProtocol="TLS" />
//备注，默认这段Connector被注释掉了，打开注释，添加密钥信息即可
3）重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
4）客户端设置host文件，并浏览测试页面进行测试(proxy充当客户端角色)
[root@proxy ~]# vim /etc/hosts
… …
192.168.2.100      www.a.com  www.b.com
[root@proxy ~]# firefox https://www.a.com:8443/
[root@proxy ~]# firefox https://www.b.com:8443/
[root@proxy ~]# firefox https://192.168.2.100:8443/


步骤五：配置Tomcat日志

1)为每个虚拟主机设置不同的日志文件
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
.. ..
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
<Context path="/test" docBase="/var/www/html/" />
#从默认localhost虚拟主机中把Valve这段复制过来，适当修改下即可
<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix="a_access" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base" />
<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix="b_access" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
</Host>
.. ..
2）重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
3）查看服务器日志文件
[root@web1 ~]# ls /usr/local/tomcat/logs/
步骤六：扩展实验(配置Tomcat集群)

1) 在192.168.4.5主机上配置Nginx调度器（具体安装步骤参考前面的章节）
[root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
http{
    upstream toms {
        server 192.168.2.100:8080;
        server 192.168.2.200:8080;
    }
    server  {
        listen 80;
        server_name localhost;
        location / {
            proxy_pass  http://toms;
        }
    }
}  
2) 在192.168.2.100和192.168.2.200主机上配置Tomcat调度器
以下以Web1为例：
[root@web1 ~]# yum -y install  java-1.8.0-openjdk                //安装JDK
[root@web1 ~]# yum -y install java-1.8.0-openjdk-headless        //安装JDK
[root@web1 ~]# tar -xzf  apache-tomcat-8.0.30.tar.gz
[root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
3）启动服务
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
4) 客户端验证
为了防止有数据缓存，可以使用真实主机的google-chrome访问代理服务器，输入Ctrl+F5刷新页面。


3 案例3：使用Varnish加速Web
3.1 问题

通过配置Varnish缓存服务器，实现如下目标：     CDN 内容分发网络
使用Varnish加速后端Web服务
代理服务器可以将远程的Web服务器页面缓存在本地
远程Web服务器对客户端用户是透明的
利用缓存机制提高网站的响应速度
使用varnishadm命令管理缓存页面
使用varnishstat命令查看Varnish状态
3.2 方案

通过源码编译安装Varnish缓存服务器
编译安装Varnish软件
修改配置文件，缓存代理源Web服务器，实现Web加速功能
使用3台RHEL7虚拟机，其中一台作为Web服务器（192.168.2.100）、一台作为Varnish代理服务器（192.168.4.5,192.168.2.5)，另外一台作为测试用的Linux客户机（192.168.4.10），如图-2所示。

图-2
对于Web服务器的部署，此实验中仅需要安装nginx或者httpd软件、启动服务，并生成测试首页文件即可，默认httpd网站根路径为/var/www/html，首页文档名称为index.html，默认nginx网站根路径为/usr/local/nginx/html，默认首页为index.html。下面的实验我们以httpd为例作为Web服务器。
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：构建Web服务器

1）使用yum安装web软件包
[root@web1 ~]# yum  -y  install  httpd
2）启用httpd服务（注意需要关闭nginx，否则端口冲突）
[root@web1 ~]# systemctl start httpd
httpd服务默认通过TCP 80端口监听客户端请求：
[root@web1 ~]# netstat  -anptu  |  grep httpd
tcp        0        0        :::80        :::*        LISTEN        2813/httpd
3）为Web访问建立测试文件
在网站根目录/var/www/html下创建一个名为index.html的首页文件：
[root@web1 ~]# cat /var/www/html/index.html 
192.168.2.100
4）测试页面是否正常（代理服务器测试后台web）
[root@proxy ~]# firefox http://192.168.2.100               
步骤二：部署Varnish缓存服务器(192.168.4.5)

1）编译安装软件
[root@proxy ~]# yum -y install gcc readline-devel    //安装软件依赖包
[root@proxy ~]# yum -y install ncurses-devel         //安装软件依赖包
[root@proxy ~]# yum -y install pcre-devel            //安装软件依赖包
[root@proxy ~]# yum -y install python-docutils         //安装软件依赖包
 [root@proxy ~]# useradd -s /sbin/nologin varnish                //创建账户
[root@proxy ~]# tar -xf varnish-5.2.1.tar.gz
[root@proxy ~]# cd varnish-5.2.1
[root@proxy varnish-5.2.1]# ./configure
[root@proxy varnish-5.2.1]# make && make install
2）复制启动脚本及配置文件（注意相对路径与绝对路径）
[root@proxy varnish-5.2.1]# cp  etc/example.vcl   /usr/local/etc/default.vcl
3）修改代理配置文件
[root@proxy ~]# vim  /usr/local/etc/default.vcl
backend default {
     .host = "192.168.2.100";
     .port = "80";
 }
4）启动服务
 [root@proxy ~]# varnishd  -f /usr/local/etc/default.vcl
//varnishd命令的其他选项说明如下：
//varnishd -s malloc,128M        //定义varnish使用内存作为缓存，空间为128M
//varnishd -s file,/var/lib/varnish_storage.bin,1G  // 定义varnish使用文件作为缓存,大小为1G
步骤三：客户端测试

1）客户端开启浏览器访问
[root@client ~]# curl http://192.168.4.5
步骤四：其他操作

1）查看varnish日志
[root@proxy ~]# varnishlog                        //varnish日志
[root@proxy ~]# varnishncsa                    //访问日志
2）更新缓存数据，在后台web服务器更新页面内容后，用户访问代理服务器看到的还是之前的数据，说明缓存中的数据过期了需要更新（默认也会自动更新，但非实时更新）。
[root@proxy ~]# varnishadm  
varnish> ban req.url ~ .*
//清空缓存数据，支持正则表达式


##############################################################################


Top
NSD OPERATION DAY06

案例1：Git基本操作
案例2： HEAD指针操作
案例3：Git分支操作
案例4：Git服务器
案例5：制作nginx的RPM包
1 案例1：Git基本操作
1.1 问题

本案例要求先快速搭建好一台Git服务器，并测试该版本控制软件，要求如下：
安装Git软件
创建版本库
客户端克隆版本仓库到本地
本地工作目录修改数据
提交本地修改到服务器

------集中式版本控制软件  (只下载最新版软件)
  . CVS
  . SVN
------分布式版本控制软件   (对服务器的完整克隆)
   . Git
   . BitKeeper(收费)

1.2 方案

实验拓扑如图-1所示，Git工作流如图-2所示。

图-1

图-2
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署Git服务器（192.168.2.100作为远程git服务器）

1）YUM安装Git软件。
[root@web1 ~]# yum -y install git
[root@web1 ~]# git --version
2)初始化一个空仓库。
[root@web1 ~]# mkdir /var/git
[root@web1 ~]# git init /var/git/project --bare    // /var/git/为共享目录  project为仓库
[root@web1 ~]# ls /var/git/project
config  description  HEAD  hooks  info  objects  refs   
步骤二：客户端测试(192.168.2.200作为客户端主机)

使用git常用指令列表如表-1所示。

  ***git clone http://www.github.com/shidaming-github/linux-tedu/***
表－1 git常用指令列表
clone   将远程服务器的仓库克隆到本地
config  修改git配置
add     添加修改到暂存区
commit  提交修改到本地仓库
push    提交修改到远程服务器

1) clone克隆服务器仓库到本地。
[root@web2 ~]# yum -y install git
[root@web2 ~]# git clone root@192.168.2.100:/var/git/project      
[root@web2 ~]# cd project
[root@web2 ~]# ls -a 
.git                 // .git -->本地仓库    project-->工作目录
2) 修改git配置。
[root@web2 project]# git config --global user.email "you@example.com"
[root@web2 project]# git config --global user.name "Your Name"
[root@web2 project]# cat ~/.gitconfig 
[user]
    email = you@example.com
    name = Your Name
3） 本地工作区对数据进行增删改查(必须要先进入仓库再操作数据)。
[root@web2 project]# echo "init date" > init.txt
[root@web2 project]# mkdir demo
[root@web2 project]# cp /etc/hosts demo
4） 查看仓库中数据的状态。
[root@web2 project]# git status
5） 将工作区的修改提交到暂存区。
[root@web2 project]# git add .  //  . 代表当前目录
6) 将暂存区修改提交到本地仓库。
  注释:commit提交到本地仓库后无法查看,可以用 (du -sh .git)  查看仓库的大小
[root@web2 project]# git commit  -m  "注释，可以为任意字符"
[root@web2 project]# git status
7） 将本地仓库中的数据推送到远程服务器(web2将数据推送到web1)。
[root@web2 project]# git config --global push.default simple
[root@web2 project]# git push
root@192.168.2.100's password:  输入服务器root密码
[root@web2 project]# git status
8) 将服务器上的数据更新到本地（web1的数据更新到web2）。
备注：可能其他人也在修改数据并提交服务器，就会导致自己的本地数据为旧数据，使用pull就可以将服务器上新的数据更新到本地。
[root@web2 project]# git pull
9) 查看版本日志。
[root@web2 project]# git log
[root@web2 project]# git log --pretty=oneline
[root@web2 project]# git log --oneline
[root@web2 project]# git reflog
备注：客户端也可以使用图形程序访问服务器。
Windows需要安装git和tortoiseGit。如图-3、图-4所示。

图-3

图-4
2 案例2： HEAD指针操作
2.1 问题

沿用练习一，学习操作HEAD指针，具体要求如下：
查看Git版本信息
移动指针
通过移动HEAD指针恢复数据
2.2 方案

HEAD指针是一个可以在任何分支和版本移动的指针，通过移动指针我们可以将数据还原至任何版本。没做一次提交操作都会导致git更新一个版本，HEAD指针也跟着自动移动。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：HEAD指针基本操作

1）准备工作（多对数据仓库进行修改、提交操作，以产生多个版本）。
[root@web2 project]# echo "new file" > new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "add new.txt"
[root@web2 project]# echo "first" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "new.txt:first line"
[root@web2 project]# echo "second" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "new.txt:second"
[root@web2 project]# echo "third" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "new.txt:third"
[root@web2 project]# git push
[root@web2 project]# echo "123" > num.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "num.txt:123"
[root@web2 project]# echo "456" > num.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "num.txt:456"
[root@web2 project]# echo "789" > num.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "num.txt:789"
[root@web2 project]# git push
2) 查看Git版本信息。
[root@web2 project]# git reflog
[root@web2 project]# git log --oneline
04ddc0f num.txt:789
7bba57b num.txt:456
301c090 num.txt:123
b427164 new.txt:third
0584949 new.txt:second
ece2dfd new.txt:first line
e1112ac add new.txt
1a0d908 初始化
3）移动HEAD指针，将数据还原到任意版本。
提示：当前HEAD指针为HEAD@{0}。
[root@web2 project]# git reset --hard 301c0
[root@web2 project]# git reflog
301c090 HEAD@{0}: reset: moving to 301c0
04ddc0f HEAD@{1}: commit: num.txt:789
7bba57b HEAD@{2}: commit: num.txt:456
301c090 HEAD@{3}: commit: num.txt:123
b427164 HEAD@{5}: commit: new.txt:third
0584949 HEAD@{6}: commit: new.txt:second
ece2dfd HEAD@{7}: commit: new.txt:first line
e1112ac HEAD@{8}: commit: add new.txt
1a0d908 HEAD@{9}: commit (initial): 初始化
[root@web2 project]# cat num.txt                #查看文件是否为123
123
[root@web2 project]# git reset --hard 7bba57b
[root@web2 project]# cat num.txt                #查看文件是否为123，456
123
456
[root@web2 project]# git reflog                #查看指针移动历史
7bba57b HEAD@{0}: reset: moving to 7bba57b
301c090 HEAD@{1}: reset: moving to 301c0
… …
[root@web2 project]# git reset --hard 04ddc0f    #恢复num.txt的所有数据
4)模拟误删后的数据还原操作。
[root@web2 project]# git rm init.txt                    #删除文件
rm 'init.txt'
[root@web2 project]# git commit -m "delete init.txt"    #提交本地仓库
[root@web2 project]# git reflog                        #查看版本历史
0dc2b76 HEAD@{0}: commit: delete init.txt
7bba57b HEAD@{0}: reset: moving to 7bba57b
301c090 HEAD@{1}: reset: moving to 301c0
… …
[root@web2 project]# git reset --hard 04ddc0f            #恢复数据
[root@web2 project]# ls
demo  init.txt  new.txt  num.txt
3 案例3：Git分支操作
3.1 问题

沿用练习二，学习操作Git分支，具体要求如下：
查看分支
创建分支
切换分支
合并分支
解决分支的冲突
3.2 方案

Git支持按功能模块、时间、版本等标准创建分支，分支可以让开发分多条主线同时进行，每条主线互不影响，分支效果如图-5所示。

图-5
常见的分支规范如下：
MASTER分支（MASTER是主分支，是代码的核心）。
DEVELOP分支（DEVELOP最新开发成果的分支）。
RELEASE分支（为发布新产品设置的分支）。
HOTFIX分支（为了修复软件BUG缺陷的分支）。
FEATURE分支（为开发新功能设置的分支）特指小的功能。
步骤一：查看并创建分支

1）查看当前分支。
[root@web2 project]# git status
# On branch master
nothing to commit, working directory clean
[root@web2 project]# git branch -v
* master 0dc2b76 delete init.txt
2）创建分支。
[root@web2 project]# git branch hotfix
[root@web2 project]# git branch feature
[root@web2 project]# git branch -v
  feature 0dc2b76 delete init.txt
  hotfix  0dc2b76 delete init.txt
* master  0dc2b76 delete init.txt
步骤二：切换与合并分支

1）切换分支。
[root@web2 project]# git checkout hotfix
[root@web2 project]# git branch -v
  feature 0dc2b76 delete init.txt
* hotfix  0dc2b76 delete init.txt
master  0dc2b76 delete init.txt
2）在新的分支上可以继续进行数据操作（增、删、改、查）。
[root@web2 project]# echo "fix a bug" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "fix a bug"
3）将hotfix修改的数据合并到master分支。
注意，合并前必须要先切换到master分支，然后再执行merge命令。
[root@web2 project]# git checkout master
[root@web2 project]# cat new.txt        #默认master分支中没有hotfix分支中的数据
[root@web2 project]# git merge hotfix
Updating 0dc2b76..5b4a755
Fast-forward
 new.txt | 1 ++
 1 file changed, 1 insertions(+)
4）将所有本地修改提交远程服务器。
[root@web2 project]# git push
步骤二：解决版本分支的冲突问题

1）在不同分支中修改相同文件的相同行数据，模拟数据冲突。
[root@web2 project]# git checkout hotfix
[root@web2 project]# echo "AAA" > a.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "add a.txt by hotfix"
[root@web2 project]# git checkout master
[root@web2 project]# echo "BBB" > a.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "add a.txt by master"
[root@web2 project]# git merge hotfix
自动合并 a.txt
冲突（添加/添加）：合并冲突于 a.txt
自动合并失败，修正冲突然后提交修正的结果。
2）查看有冲突的文件内容，修改文件为最终版本的数据，解决冲突。
[root@web2 project]# cat a.txt                #该文件中包含有冲突的内容
<<<<<<< HEAD
BBB
=======
AAA
>>>>>>> hotfix
[root@web2 project]# vim a.txt              #修改该文件，为最终需要的数据，解决冲突
BBB
[root@web2 project]# git add .
[root@web2 project]# git commit -m "resolved"
总结：分支指针与HEAD指针的关系。
创建分支的本质是在当前提交上创建一个可以移动的指针
如何判断当前分支呢？答案是根据HEAD这个特殊指针
分支操作流程如图-6，图-7，图-8，图-9，图-10所示。

图-6 HEAD指针指向master分支

图-7 切换分支，HEAD指针指向testing分支

图-8 在testing分支中修改并提交代码

图-9 将分支切换回master分支

图-10 在master分支中修改数据，更新版本

4 案例4：Git服务器
4.1 问题

沿用练习三，学习Git不同的服务器形式，具体要求如下：
创建SSH协议服务器
创建Git协议服务器
创建HTTP协议服务器
4.2 方案

Git支持很多服务器协议形式，不同协议的Git服务器，客户端就可以使用不同的形式访问服务器。创建的服务器协议有SSH协议、Git协议、HTTP协议。
步骤一：SSH协议服务器（支持读写操作）

1）创建基于密码验证的SSH协议服务器（web1主机操作）。
[root@web1 ~]# git init --bare /var/git/base_ssh
Initialized empty Git repository in /var/git/base_ssh/
2)客户端访问的方式（web2主机操作）。
[root@web2 ~]# git clone root@192.168.2.100:/var/git/base_ssh
[root@web2 ~]# rm -rf base_ssh
3）客户端生成SSH密钥，实现免密码登陆git服务器（web2主机操作）。
[root@web2 ~]# ssh-keygen -f /root/.ssh/id_rsa -N ''
[root@web2 ~]# ssh-copy-id  192.168.2.100
[root@web2 ~]# git clone root@192.168.2.100:/var/git/base_ssh
[root@web2 ~]# git push

步骤二：Git协议服务器（只读操作的服务器）

1）安装git-daemon软件包（web1主机操作）。
[root@web1 ~]# yum -y install git-daemon
2）创建版本库（web1主机操作）。
[root@web1 ~]# git init --bare /var/git/base_git
Initialized empty Git repository in /var/git/base_git/
3）修改配置文件，启动git服务（web1主机操作）。
[root@web1 ~]# vim /usr/lib/systemd/system/git@.service
修改前内容如下：
ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/lib/git 
--export-all --user-path=public_git --syslog --inetd –verbose
修改后内容如下：
ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/git 
--export-all --user-path=public_git --syslog --inetd –verbose
[root@web1 ~]# systemctl  start  git.socket
4）客户端访问方式（web2主机操作）
[root@web2 ~]# git clone git://192.168.2.100/base_git

步骤三：HTTP协议服务器（只读操作的服务器）

1）安装gitweb、httpd软件包（web1主机操作）。
[root@web1 ~]# yum -y install httpd gitweb
2）修改配置文件，设置仓库根目录（web1主机操作）。
[root@web1 ~]# vim +11 /etc/gitweb.conf      //光标定义在第11行
$projectroot = "/var/git";                        #添加一行
3) 创建版本仓库（web1主机操作）
[root@web1 ~]# git init --bare /var/git/base_http
4）启动httpd服务器
[root@web1 ~]# systemctl start httpd
5）客户端访问方式（web2主机操作）
注意：调用虚拟机中的firefox浏览器，需要在远程时使用ssh -X 服务器IP，并且确保真实主机的firefox已经关闭。
[root@web2 ~]# firefox http://192.168.2.100/git/
步骤四：课外扩展知识：注册使用Github

1.登陆网站https://github.com，点击Sign up（注册），如图-11所示。

图-11
2.填写注册信息（用户名，邮箱，密码），如图-12所示。

图-12
3. 初始化操作，如图-13和图-14所示。

图-13

图-14
注意，初始化完成后，到邮箱中去激活Github账户。
4. 创建仓库、使用仓库
点击Start a project（如图-15所示），

图-15
填写项目名称（项目名称任意），如图-16所示。

图-16
往仓库中上传文件或新建文件，如图-17所示

图-17
下载仓库中的代码，如图-18所示。

图-18
5. 命令行操作（需要联网的主机，如真实机）
[root@pc001 ~]# yum -y install git
[root@pc001 ~]# git clone https://github.com/账户名称/仓库名称
#clone指令用于将服务器仓库中的资料打包下载到本地
[root@pc001 ~]# cd 仓库名称
[root@pc001 ~]# 任意修改文件，或新建文件
[root@pc001 ~]# git add .
#add添加新文件
[root@pc001 ~]# git commit -m "test"
[root@pc001 ~]# git push
#commit和push实现提交代码的功能
[root@pc001 ~]# git pull
#pull可以从githuab服务器拉取数据到本地
5 案例5：制作nginx的RPM包
5.1 问题

本案例使用nginx-1.12.2版本的源码软件，生成对应的RPM包软件，具体要求如下：
软件名称为nginx
软件版本为1.12.2
RPM软件包可以查询描述信息
RPM软件包可以安装及卸载
5.2 方案

安装rpm-build软件包，编写SPEC配置文件，创建新的RPM软件包。
配置文件中的描述信息如表-2：
表－2 SPEC描述信息

5.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：安装rpm-build软件

1）安装rpm-build软件包
[root@web1 ~]# yum -y install  rpm-build
2）生成rpmbuild目录结构
[root@web1 ~]# rpmbuild -ba nginx.spec                //会报错，没有文件或目录
[root@web1 ~]# ls /root/rpmbuild                    //自动生成的目录结构
BUILD  BUILDROOT  RPMS  SOURCES  SPECS  SRPMS
3）准备工作，将源码软件复制到SOURCES目录
[root@web1 ~]# cp nginx-1.12.2.tar.gz /root/rpmbuild/SOURCES/
4）创建并修改SPEC配置文件
[root@web1 ~]# vim /root/rpmbuild/SPECS/nginx.spec 
Name:nginx                                        #源码包软件名称
Version:1.12.2                                    #源码包软件的版本号
Release:    10                                        #制作的RPM包版本号
Summary: Nginx is a web server software.            #RPM软件的概述    
License:GPL                                        #软件的协议
URL:    www.test.com                                    #网址
Source0:nginx-1.12.2.tar.gz                        #源码包文件的全称
#BuildRequires:                                    #制作RPM时的依赖关系
#Requires:                                        #安装RPM时的依赖关系
%description
nginx [engine x] is an HTTP and reverse proxy server.    #软件的详细描述
%post
useradd nginx                               #非必需操作：安装后脚本(创建账户)
%prep
%setup -q                                #自动解压源码包，并cd进入目录
%build
./configure
make %{?_smp_mflags}
%install
make install DESTDIR=%{buildroot}
%files
%doc
/usr/local/nginx/*                    #对哪些文件与目录打包
%changelog
步骤二：使用配置文件创建RPM包

1）安装依赖软件包
[root@web1 ~]# yum -y install  gcc  pcre-devel openssl-devel
2）rpmbuild创建RPM软件包
[root@web1 ~]# rpmbuild -ba /root/rpmbuild/SPECS/nginx.spec
[root@web1 ~]# ls /root/rpmbuild/RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm
步骤三：安装、卸载软件

[root@web1 ~]# rpm -ivh /root/rpmbuild/RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm 
[root@web1 ~]# rpm -qa |grep nginx
[root@web1 ~]# /usr/local/nginx/sbin/nginx
[root@web1 ~]# curl http://127.0.0.1/


###############################################################################


Top
NSD OPERATION DAY07

案例1：配置GRE VPN
案例2：创建PPTP VPN
案例3：创建L2TP+IPSec VPN
案例4：NTP时间同步
1 案例1：配置GRE VPN
1.1 问题

本案例要求搭建一个GRE VPN环境，并测试该VPN网络是否能够正常通讯，要求如下：
启用内核模块ip_gre
创建一个虚拟VPN隧道(10.10.10.0/24)
实现两台主机点到点的隧道通讯
1.2 方案

使用lsmod查看当前计算机已经加载的模块，使用modprobe加载Linux内核模块，使用modinfo可以查看内核模块的信息。
准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-1所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。
表－1 主机列表

实验拓扑如图-1所示。

图-1
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：启用GRE模块（client和proxy都需要操作）

1）查看计算机当前加载的模块
[root@client ~]# lsmod                            //显示模块列表
[root@client ~]# lsmod  | grep ip_gre            //确定是否加载了gre模块
2)加载模块ip_gre
[root@client ~]# modprobe  ip_gre 
3）查看模块信息
[root@client ~]# modinfo ip_gre
filename:       /lib/modules/3.10.0-693.el7.x86_64/kernel/net/ipv4/ip_gre.ko.xz
alias:          netdev-gretap0
alias:          netdev-gre0
alias:          rtnl-link-gretap
alias:          rtnl-link-gre
license:        GPL
rhelversion:    7.4
srcversion:     F37A2BF90692F86E3A8BD15
depends:        ip_tunnel,gre
intree:         Y
vermagic:       3.10.0-693.el7.x86_64 SMP mod_unload modversions 
signer:         CentOS Linux kernel signing key
sig_key:        DA:18:7D:CA:7D:BE:53:AB:05:BD:13:BD:0C:4E:21:F4:22:B6:A4:9C
sig_hashalgo:   sha256
parm:           log_ecn_error:Log packets received with corrupted ECN (bool)
      
步骤二：Client主机创建VPN隧道

1）创建隧道
[root@client ~]# ip tunnel add tun0  mode gre \ 
>  remote 201.1.2.5 local 201.1.2.10
//ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
//mode设置隧道使用gre模式
//local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址
2）启用该隧道（类似与设置网卡up）
[root@client ~]# ip link show
[root@client ~]# ip link set tun0 up         //设置UP
[root@client ~]# ip link show
3）为VPN配置隧道IP地址
[root@client ~]# ip addr add 10.10.10.10/24 peer 10.10.10.5/24 \
>  dev tun0
//为隧道tun0设置本地IP地址（10.10.10.10.10/24）
//隧道对面的主机IP的隧道IP为10.10.10.5/24
[root@client ~]# ip a s                      //查看IP地址
4）关闭防火墙
[root@client ~]# firewall-cmd --set-default-zone=trusted
步骤三：Proxy主机创建VPN隧道

1）查看计算机当前加载的模块
[root@client ~]# lsmod                            //显示模块列表
[root@client ~]# lsmod  | grep ip_gre            //确定是否加载了gre模块
2)加载模块ip_gre
[root@client ~]# modprobe  ip_gre
3）创建隧道
[root@proxy ~]# ~]# ip tunnel add tun0  mode gre \ 
>  remote 201.1.2.10 local 201.1.2.5
//ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
//mode设置隧道使用gre模式
//local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址
4）启用该隧道（类似与设置网卡up）
[root@proxy ~]# ip link show
[root@proxy ~]# ip link set tun0 up         //设置UP
[root@proxy ~]# ip link show
5）为VPN配置隧道IP地址
[root@proxy ~]# ip addr add 10.10.10.5/24 peer 10.10.10.10/24 \
>  dev tun0
//为隧道tun0设置本地IP地址（10.10.10.10.5/24）
//隧道对面的主机IP的隧道IP为10.10.10.10/24
[root@proxy ~]# ip a s                      //查看IP地址
6）开启路由转发、关闭防火墙
[root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
7)测试连通性
[root@client ~]#  ping 10.10.10.5
[root@proxy ~]#   ping 10.10.10.10
2 案例2：创建PPTP VPN
2.1 问题

本案例要求搭建一个PPTP VPN环境，并测试该VPN网络是否能够正常通讯，要求如下:
使用PPTP协议创建一个支持身份验证的隧道连接
使用MPPE对数据进行加密
为客户端分配192.168.3.0/24的地址池
客户端连接的用户名为jacob，密码为123456
2.2 方案

准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-2所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。
表－2 主机列表

实验拓扑如图-2所示。

图-2
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署VPN服务器

1）安装软件包（软件包参考lnmp_soft）
[root@proxy ~]# yum localinstall pptpd-1.4.0-2.el7.x86_64.rpm
[root@proxy ~]# rpm -qc pptpd
/etc/ppp/options.pptpd
/etc/pptpd.conf
/etc/sysconfig/pptpd
2)修改配置文件
[root@proxy ~]# vim /etc/pptpd.conf
.. ..
localip 201.1.2.5                                    //服务器本地IP
remoteip 192.168.3.1-50                            //分配给客户端的IP池
[root@proxy ~]# vim /etc/ppp/options.pptpd
require-mppe-128                                    //使用MPPE加密数据
ms-dns 8.8.8.8                                    //DNS服务器
[root@proxy ~]# vim /etc/ppp/chap-secrets            //修改账户配置文件
jacob           *               123456      *
//用户名    服务器标记    密码    客户端
[root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward    //开启路由转发
3）启动服务
[root@proxy ~]# systemctl start pptpd
[root@proxy ~]# systemctl enable pptpd
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
4）翻墙设置（非必需操作）
[root@proxy ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
>  -j SNAT --to-source 201.1.2.5
步骤二：客户端设置

启动一台Windows虚拟机，将虚拟机网卡桥接到public2，配置IP地址为201.1.2.20。
新建网络连接（具体操作如图-3所示），输入VPN服务器账户与密码（具体操作如图-4所示），连接VPN并测试网络连通性（如图-5所示）。

图-3

图-4

图-5
3 案例3：创建L2TP+IPSec VPN
3.1 问题

本案例要求搭建一个L2TP+IPSec VPN环境，并测试该VPN网络是否能够正常通讯，具体要求如下：
使用L2TP协议创建一个支持身份验证与加密的隧道连接
使用IPSec对数据进行加密
为客户端分配192.168.3.0/24的地址池
客户端连接的用户名为：jacob，密码为：123456
预共享密钥为：randpass
3.2 方案

准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-3所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。
表－3 主机列表

实验拓扑如图-6所示。

图-6
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署IPSec服务

1）安装软件包
[root@client ~]# yum -y install libreswan
2)新建IPSec密钥验证配置文件
[root@client ~]# cat /etc/ipsec.conf                //仅查看一下该主配置文件
.. ..
include /etc/ipsec.d/*.conf                    //加载该目录下的所有配置文件
[root@client ~]# vim /etc/ipsec.d/myipsec.conf            
//新建该文件，参考lnmp_soft/vpn/myipsec.conf    
conn IDC-PSK-NAT
    rightsubnet=vhost:%priv                        //允许建立的VPN虚拟网络
    also=IDC-PSK-noNAT
conn IDC-PSK-noNAT
    authby=secret                                    //加密认证
        ike=3des-sha1;modp1024                        //算法
        phase2alg=aes256-sha1;modp2048                //算法
    pfs=no
    auto=add
    keyingtries=3
    rekey=no
    ikelifetime=8h
    keylife=3h
    type=transport
    left=201.1.2.10                                //重要，服务器本机的外网IP
    leftprotoport=17/1701
    right=%any                                    //允许任何客户端连接
    rightprotoport=17/%any
3)创建IPSec预定义共享密钥
[root@client ~]# cat /etc/ipsec.secrets                 //仅查看，不要修改该文件
include /etc/ipsec.d/*.secrets
[root@client ~]# vim /etc/ipsec.d/mypass.secrets        //新建该文件
201.1.2.10   %any:    PSK    "randpass"             //randpass为预共享密钥
                                                //201.1.2.10是VPN服务器的IP
4)启动IPSec服务
[root@client ~]# systemctl start ipsec        
[root@client ~]# netstat -ntulp |grep pluto
udp        0      0 127.0.0.1:4500          0.0.0.0:*           3148/pluto          
udp        0      0 192.168.4.10:4500      0.0.0.0:*           3148/pluto          
udp        0      0 201.1.2.10:4500         0.0.0.0:*           3148/pluto          
udp        0      0 127.0.0.1:500           0.0.0.0:*           3148/pluto          
udp        0      0 192.168.4.10:500       0.0.0.0:*           3148/pluto          
udp        0      0 201.1.2.10:500          0.0.0.0:*           3148/pluto          
udp6       0      0 ::1:500                 :::*                 3148/pluto
步骤二：部署XL2TP服务

1）安装软件包（软件包参考lnmp_soft）
[root@client ~]# yum localinstall xl2tpd-1.3.8-2.el7.x86_64.rpm
2) 修改xl2tp配置文件（修改3个配置文件的内容）
[root@client ~]#  vim  /etc/xl2tpd/xl2tpd.conf                //修改主配置文件
[global]
.. ..    
[lns default]
.. ..
ip range = 192.168.3.128-192.168.3.254                    //分配给客户端的IP池
local ip = 201.1.2.10                                    //VPN服务器的IP地址
[root@client ~]# vim /etc/ppp/options.xl2tpd            //认证配置
require-mschap-v2                                         //添加一行，强制要求认证
#crtscts                                                //注释或删除该行
#lock                                                //注释或删除该行
root@client ~]# vim /etc/ppp/chap-secrets                    //修改密码文件
jacob   *       123456  *                //账户名称   服务器标记   密码   客户端IP
3）启动服务
[root@client ~]# systemctl start xl2tpd
[root@client ~]# netstat  -ntulp |grep xl2tpd        
udp     0      0 0.0.0.0:1701      0.0.0.0:*          3580/xl2tpd
4）设置路由转发，防火墙
[root@client ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
[root@client ~]# firewall-cmd --set-default-zone=trusted
5）翻墙设置（非必需操作）
[root@client ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
>  -j SNAT --to-source 201.1.2.10
步骤三：客户端设置

启动一台Windows虚拟机，将虚拟机网卡桥接到public2，配置IP地址为201.1.2.20。
1. 新建网络连接（参考案例2），输入VPN服务器账户与密码（参考案例2）。
设置VPN连接的属性，预共享密钥是IPSec配置文件中填写的randpass，具体操作如图-7所示。

图-7
2. 设置Windows注册表（不修改注册表，连接VPN默认会报789错误），具体操作如下：
单击"开始"，单击"运行"，键入"regedit"，然后单击"确定"
找到下面的注册表子项，然后单击它：
HKEY_LOCAL_MACHINE\ System\CurrentControlSet\Services\Rasman\Parameters
在"编辑"菜单上，单击"新建"->"DWORD值"
在"名称"框中，键入"ProhibitIpSec"
在"数值数据"框中，键入"1"，然后单击"确定"
退出注册表编辑器，然后重新启动计算机
连接VPN并测试网络连通性（参考案例2）。
4 案例4：NTP时间同步
4.1 问题

本案例要求搭建一个NTP服务器，为整个网络环境中的所有主机提供时间校准服务，具体要求如下：
部署一台NTP时间服务器
设置时间服务器上层与0.centos.pool.ntp.org同步
设置本地服务器层级数量为10
允许192.168.4.0/24网络的主机同步时间
客户端验证时间是否同步
4.2 方案

准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-4所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。
表－4 主机列表

实验拓扑如图-8所示。

图-8
Network Time Protocol（网络时间协议）采用的是分层设计，如图-9所示，Stratum层的总数限制在15以内（包括15）。

图-9
4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署NTP服务

1）安装软件包
[root@proxy ~]# yum -y install chrony
[root@proxy ~]# rpm -qc chrony                        //查看配置文件列表
/etc/chrony.conf
/etc/chrony.keys
.. ..
2)修改配置文件
[root@proxy ~]# cat /etc/chrony.conf
.. ..
server 0.centos.pool.ntp.org iburst         //server用户客户端指向上层NTP服务器
allow 192.168.4.0/24                        //允许那个IP或网络访问NTP
#deny  192.168.4.1                        //拒绝那个IP或网络访问NTP
local stratum 10                            //设置NTP服务器的层数量
.. ..
3)启动NTP服务
[root@proxy ~]# systemctl  restart  chronyd
[root@proxy ~]# systemctl  enable   chronyd
4)设置防火墙
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
步骤二：配置客户端

1）安装软件包
[root@client ~]# yum -y install chrony
2) 修改配置文件
[root@client ~]# vim /etc/chrony.conf
server 192.168.4.5 iburst                //设置与哪台服务器同步数据
                                        //iburst参数设置重启服务后尽快同步时间
3) 将客户端时间修改为错误的时间
[root@client ~]#  date  -s  "hour:minute"         //调整时间（小时：分钟）
[root@client ~]#  date                            //查看修改后的时间
4) 重启chrony与服务器同步时间
[root@client ~]# systemctl  restart  chronyd
5) 确认时间是否已经同步
[root@client ~]# date                            //多执行几次查看结果



所有 nignx 均不要显示版本号    在配置文件里http里  输入server_tokens off;(不显示版本号),后端web服务器也要写这个配置.

watch -n 1 ss -s      //观察服务器连接数变化(每秒执行一次 ss 命令)


  我们可以简单的通过修改Linux内核参数，可以减少Nginx服务器的TIME_WAIT套接字数量，进而提高Nginx服务器并发性能。  
 
vim /etc/sysctl.conf
  net.ipv4.tcp_fin_timeout = 30      // 表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间
  net.ipv4.tcp_keepalive_time = 1200 //表示当keepalive起用的时候，TCP发送keepalive消息的频度
  net.ipv4.tcp_syncookies = 1        //表示开启SYN Cookies,防范少量SYN攻击，默认为0，表示关闭
  net.ipv4.tcp_tw_reuse = 1          //表示开启重用,允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭
  net.ipv4.tcp_tw_recycle = 1        //表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭
  net.ipv4.ip_local_port_range = 1024 65000   //表示用于向外连接的端口范围
  net.ipv4.tcp_max_syn_backlog = 8192        //表示SYN队列的长度，默认为1024,加大队列长度为8192，可以容纳更多等待连接的网络连接数
  net.ipv4.tcp_max_tw_buckets = 5000         //表示系统同时保持TIME_WAIT套接字的最大数量

  sysctl -p       //刷新读取配置文件使永久配置立即生效

           内核参数:


tcp_syn_retries ：INTEGER
默认值是5
对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃。不应该大于255，默认值是5，对应于180秒左右时间。(对于大负载而物理通信良好的网络而言,这个值偏高,可修改为2.这个值仅仅是针对对外的连接,对进来的连接,是由tcp_retries1决定的)

tcp_synack_retries ：INTEGER
默认值是5
对于远端的连接请求SYN，内核会发送SYN ＋ ACK数据报，以确认收到上一个 SYN连接请求包。这是所谓的三次握手( threeway handshake)机制的第二个步骤。这里决定内核在放弃连接之前所送出的 SYN+ACK 数目。不应该大于255，默认值是5，对应于180秒左右时间。(可以根据上面的 tcp_syn_retries 来决定这个值)

tcp_keepalive_time ：INTEGER
默认值是7200(2小时)
当keepalive打开的情况下，TCP发送keepalive消息的频率。(由于目前网络攻击等因素,造成了利用这个进行的攻击很频繁,曾经也有cu的朋友提到过,说如果2边建立了连接,然后不发送任何数据或者rst/fin消息,那么持续的时间是不是就是2小时,空连接攻击? tcp_keepalive_time就是预防此情形的.我个人在做nat服务的时候的修改值为1800秒)

tcp_keepalive_probes：INTEGER
默认值是9
TCP发送keepalive探测以确定该连接已经断开的次数。(注意:保持连接仅在SO_KEEPALIVE套接字选项被打开是才发送.次数默认不需要修改,当然根据情形也可以适当地缩短此值.设置为5比较合适)

tcp_keepalive_intvl：INTEGER
默认值为75
探测消息发送的频率，乘以tcp_keepalive_probes就得到对于从开始探测以来没有响应的连接杀除的时间。默认值为75秒，也就是没有活动的连接将在大约11分钟以后将被丢弃。(对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的值)

tcp_retries1 ：INTEGER
默认值是3
放弃回应一个TCP连接请求前﹐需要进行多少次重试。RFC 规定最低的数值是3﹐这也是默认值﹐根据RTO的值大约在3秒 - 8分钟之间。(注意:这个值同时还决定进入的syn连接)

tcp_retries2 ：INTEGER
默认值为15
在丢弃激活(已建立通讯状况)的TCP连接之前﹐需要进行多少次重试。默认值为15，根据RTO的值来决定，相当于13-30分钟(RFC1122规定，必须大于100秒).(这个值根据目前的网络设置,可以适当地改小,我的网络内修改为了5)

tcp_orphan_retries ：INTEGER
默认值是7
在近端丢弃TCP连接之前﹐要进行多少次重试。默认值是7个﹐相当于 50秒 - 16分钟﹐视 RTO 而定。如果您的系统是负载很大的web服务器﹐那么也许需要降低该值﹐这类 sockets 可能会耗费大量的资源。另外参的考tcp_max_orphans 。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为3)

tcp_fin_timeout ：INTEGER
默认值是 60
对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。默认值为 60 秒。过去在2.2版本的内核中是 180 秒。您可以设置该值﹐但需要注意﹐如果您的机器为负载很重的web服务器﹐您可能要冒内存被大量无效数据报填满的风险﹐FIN-WAIT-2 sockets 的危险性低于 FIN-WAIT-1 ﹐因为它们最多只吃 1.5K 的内存﹐但是它们存在时间更长。另外参考 tcp_max_orphans。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为30)

tcp_max_tw_buckets ：INTEGER
默认值是180000
系 统在同时所处理的最大 timewait sockets 数目。如果超过此数的话﹐time-wait socket 会被立即砍除并且显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要人为的降低这个限制﹐不过﹐如果网络条件需要比默认值更多﹐则可以提高它(或许还要增加内存)。(事实上做NAT的时候最好可以适当地增加该值)

tcp_tw_recycle ：BOOLEAN
默认值是0
打开快速 TIME-WAIT sockets 回收。除非得到技术专家的建议或要求﹐请不要随意修改这个值。(做NAT的时候，建议打开它)

tcp_tw_reuse：BOOLEAN
默认值是0
该文件表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助)

tcp_max_orphans ：INTEGER
缺省值是8192
系统所能处理不属于任何进程的TCP sockets最大数量。假如超过这个数量﹐那么不属于任何进程的连接会被立即reset，并同时显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要依赖这个或是人为的降低这个限制(这个值Redhat AS版本中设置为32768,但是很多防火墙修改的时候,建议该值修改为2000)

tcp_abort_on_overflow ：BOOLEAN
缺省值是0
当守护进程太忙而不能接受新的连接，就象对方发送reset消息，默认值是false。这意味着当溢出的原因是因为一个偶然的猝发，那么连接将恢复状态。只有在你确信守护进程真的不能完成连接请求时才打开该选项，该选项会影响客户的使用。(对待已经满载的sendmail,apache这类服务的时候,这个可以很快让客户端终止连接,可以给予服务程序处理已有连接的缓冲机会,所以很多防火墙上推荐打开它)

tcp_syncookies ：BOOLEAN
默认值是0
只有在内核编译时选择了CONFIG_SYNCOOKIES时才会发生作用。当出现syn等候队列出现溢出时象对方发送syncookies。目的是为了防止syn flood攻击。
注意：该选项千万不能用于那些没有收到攻击的高负载服务器，如果在日志中出现synflood消息，但是调查发现没有收到synflood攻击，而是合法用户的连接负载过高的原因，你应该调整其它参数来提高服务器性能。参考:
tcp_max_syn_backlog
tcp_synack_retries
tcp_abort_on_overflow
syncookie严重的违背TCP协议，不允许使用TCP扩展，可能对某些服务导致严重的性能影响(如SMTP转发)。(注意,该实现与BSD上面使用的tcp proxy一样,是违反了RFC中关于tcp连接的三次握手实现的,但是对于防御syn-flood的确很有用.)

tcp_stdurg ：BOOLEAN
默认值为0
使用 TCP urg pointer 字段中的主机请求解释功能。大部份的主机都使用老旧的 BSD解释，因此如果您在 Linux 打开它﹐或会导致不能和它们正确沟通。

tcp_max_syn_backlog ：INTEGER
对于那些依然还未获得客户端确认的连接请求﹐需要保存在队列中最大数目。对于超过 128Mb 内存的系统﹐默认值是 1024 ﹐低于 128Mb 的则为 128。如果服务器经常出现过载﹐可以尝试增加这个数字。警告﹗假如您将此值设为大于 1024﹐最好修改 include/net/tcp.h 里面的 TCP_SYNQ_HSIZE ﹐以保持TCP_SYNQ_HSIZE*16<=tcp_max_syn_backlog ﹐并且编进核心之内。(SYN Flood攻击利用TCP协议散布握手的缺陷，伪造虚假源IP地址发送大量TCP-SYN半打开连接到目标系统，最终导致目标系统Socket队列资源耗 尽而无法接受新的连接。为了应付这种攻击，现代Unix系统中普遍采用多连接队列处理的方式来缓冲(而不是解决)这种攻击，是用一个基本队列处理正常的完 全连接应用(Connect()和Accept() )，是用另一个队列单独存放半打开连接。这种双队列处理方式和其他一些系统内核措施(例如Syn-Cookies/Caches)联合应用时，能够比较有效的缓解小规模的SYN Flood攻击(事实证明<1000p/s)加大SYN队列长度可以容纳更多等待连接的网络连接数，所以对Server来说可以考虑增大该值.)

tcp_window_scaling ：INTEGER
缺省值为1
该 文件表示设置tcp/ip会话的滑动窗口大小是否可变。参数值为布尔值，为1时表示可变，为0时表示不可变。tcp/ip通常使用的窗口最大可达到 65535 字节，对于高速网络，该值可能太小，这时候如果启用了该功能，可以使tcp/ip滑动窗口大小增大数个数量级，从而提高数据传输的能力(RFC 1323)。（对普通地百M网络而言，关闭会降低开销，所以如果不是高速网络，可以考虑设置为0）

tcp_timestamps ：BOOLEAN
缺省值为1
Timestamps 用在其它一些东西中﹐可以防范那些伪造的 sequence 号码。一条1G的宽带线路或许会重遇到带 out-of-line数值的旧sequence 号码(假如它是由于上次产生的)。Timestamp 会让它知道这是个 '旧封包'。(该文件表示是否启用以一种比超时重发更精确的方法（RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。)

tcp_sack ：BOOLEAN
缺省值为1
使 用 Selective ACK﹐它可以用来查找特定的遗失的数据报--- 因此有助于快速恢复状态。该文件表示是否启用有选择的应答（Selective Acknowledgment），这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）。(对于广域网通信来说这个选项应该启用，但是这会增加对 CPU 的占用。)

tcp_fack ：BOOLEAN
缺省值为1
打开FACK拥塞避免和快速重传功能。(注意，当tcp_sack设置为0的时候，这个值即使设置为1也无效)

tcp_dsack ：BOOLEAN
缺省值为1
允许TCP发送"两个完全相同"的SACK。

http://blog.csdn.net/zhangxinrun/article/details/7621028


#################################################################################333


                            CLUSTER(集群与存储)
Top
NSD CLUSTER DAY01

案例1：ipvsadm命令用法
案例2：部署LVS-NAT集群
案例3：部署LVS-DR集群

集群:
1, 一组通过高速网络互联的计算机,并以单一系统的模式加以管理
2, 将很多服务器集中起来一起,提供同一种服务,在客户端看来就像是只有一个服务器
3. 可以在付出较低成本的情况下获得在性能,可靠性,灵活性方面的相对较高的利益
4, 任务调度是集群系统中的核心技术

集群目的:
提高性能,降低成本,提高可扩展性,增强可靠性

LVS集群组成:
1, 前段: 负载均衡层
2, 中间: 服务器群组层
3, 底端: 数据共享存储层		

LVS  是路由器的原理(不是代理)   路由器的工作原理:数据包转发+NAT

nginx代理工作原理:    nginx作为代理,客户端发送请求给代理,代理帮客户端访问服务器,中间代理频繁进行数据包解压封装
LVS 工作原理:   lvs工作原理为路由器,有地址转换和转发功能,通过地址的转换和转发数据,不进行数据包解压封装,效率提升,存在地址转换,服务器需要设置网关

LVS性能>Haproxy性能>nginx性能 ,LVS功能<Haproxy功 能<nginx功能 ,LVS没有健康检查功能.

LVS工作模式:
NAT: 结构简单,流量瓶颈
DR: 结构复杂,解决流量问题
TUN: 异地通讯,延迟问题

LVS 调度算法:
1, 轮询 rr
2, 加权轮询 wrr
3, 最少连接算法 lc
4, 加权最少连接算法  wlc
5, 原地址哈希 sh(相同客户端访问相同服务器)
6, 目标地址哈希  dh




1 案例1：ipvsadm命令用法
1.1 问题

准备一台Linux服务器，安装ipvsadm软件包，练习使用ipvsadm命令，实现如下功能：
使用命令添加基于TCP一些的集群服务
在集群中添加若干台后端真实服务器
实现同一客户端访问，调度器分配固定服务器
会使用ipvsadm实现规则的增、删、改
保存ipvsadm规则
1.2 方案

安装ipvsadm软件包，关于ipvsadm的用法可以参考man ipvsadm资料。
常用ipvsadm命令语法格式如表-1及表-2所示。



表－1 ipvsadm命令选项
  ipvsadm -A        添加虚拟服务器
  ipvsadm -E        修改虚拟服务器
  ipvsadm -D        删除虚拟服务器
  ipvsadm -C          清空所有
  ipvsadm -a        添加真实服务器
  ipvsadm -e        修改真实服务器
  ipvsadm -d        删除真实服务器
  ipvsadm -L        查看LVS规则表
  -s [rr|wrr|lc|wlc|sh]  指定集群算法
  


表－2 ipvsadm语法案例
   ipvsadm -A -t|u 192.168.4.5:80 -s [算法]   添加虚拟服务器,协议为tcp(-t)或udp(-u)
   ipvsadm -E -t|u 192.168.4.5:80 -s [算法]   修改虚拟服务器,协议为tcp(-t)或udp(-u)
   ipvsadm -D -t|u 192.168.4.5:80            删除虚拟服务器,协议为tcp(-t)或udp(-u)
   ipvsadm -C                                清空所有
   ipvsadm -a -t|u 192.168.4.5:80 -r 192.168.2.100 [-g|i|m] [-w 权重]  添加真实服务器 -g(DR模式(Route) ->默认), -i(隧道模式(Tunnel)), -m(NAT模式(Masq))
   ipvsadm -Ln        查看LVS规则表

NAT: 路由,ip_forward=1  web配置网关(网关地址是代理服务器的另一个IP地址)   ,ipvsadm  LVS
DR : 用户访问调度器,web直接返回给用户
      1,web服务器和客户端在同一个网段
      2,web需要伪装调度器的vip
        3,地址冲突,修改内核参数防止冲突
        4,调度器的vip必须配在辅助接口,DIP在主接口


  lvs,nginx 有负载均衡,无高可用

1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：使用命令增、删、改LVS集群规则

1）创建LVS虚拟集群服务器（算法为加权轮询：wrr）
[root@proxy ~]# yum -y install ipvsadm
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:80 -s wrr
[root@proxy ~]# ipvsadm -Ln          //查看LVS集群规则
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 wrr

2）为集群添加若干real server
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 -w 1
[root@proxy ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 wrr
  -> 192.168.2.100:80             router    1      0          0
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.200 -m -w 2
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.201 -m -w 3
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.202 -m -w 4

3）修改集群服务器设置(修改调度器算法，将加权轮询修改为轮询)
[root@proxy ~]# ipvsadm -E -t 192.168.4.5:80 -s rr
[root@proxy ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 rr
  -> 192.168.2.100:80             router    1      0          0         
  -> 192.168.2.200:80             masq      2      0          0         
  -> 192.168.2.201:80             masq      2      0          0         
  -> 192.168.2.202:80             masq      1      0          0

4）修改read server（使用-g选项，将模式改为DR模式）
[root@proxy ~]# ipvsadm -e -t 192.168.4.5:80 -r 192.168.2.202 -g

5）查看LVS状态
[root@proxy ~]# ipvsadm -Ln
+                
6）创建另一个集群（算法为最少连接算法；使用-m选项，设置工作模式为NAT模式）
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:3306 -s lc
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.100 -m
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.200 -m

7）永久保存所有规则
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm

8）清空所有规则
[root@proxy ~]# ipvsadm -C

2 案例2：部署LVS-NAT集群
2.1 问题

使用LVS实现NAT模式的集群调度服务器，为用户提供Web服务：
集群对外公网IP地址为192.168.4.5
调度器内网IP地址为192.168.2.5
真实Web服务器地址分别为192.168.2.100、192.168.2.200
使用加权轮询调度算法，真实服务器权重分别为1和2
2.2 方案

实验拓扑结构主机配置细节如表-3所示。
表-3

使用4台虚拟机，1台作为Director调度器、2台作为Real Server、1台客户端，拓扑结构如图-1所示，注意：web1和web2必须配置网关地址。

图-1

client  eth0:192.168.4.10/24

proxy   eth0:192.168.4.5/24
        eth1:192.168.2.5/24

web1    eth1:192.168.2.100/24
            网关:192.168.2.5

web2    eth1:192.168.2.200/24
            网关:192.168.2.5

2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置基础环境

1）设置Web服务器（以web1为例）
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
2）启动Web服务器软件
[root@web1 ~]# systemctl restart httpd
3)关闭防火墙与SELinux
[root@web1 ~]# systemctl stop firewalld
[root@web1 ~]# setenforce 0

步骤二：部署LVS-NAT模式调度器

1)确认调度器的路由转发功能(如果已经开启，可以忽略)  ------> 打开路由功能

[root@proxy ~]# echo 1 > /proc/sys/net/ipv4/ip_forward   //此文件无法用vim修改,只能echo且为临时性的 功能是开启路由功能
[root@proxy ~]# cat /proc/sys/net/ipv4/ip_forward
1
[root@proxy ~]# echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf  
#修改配置文件，设置永久规则,功能是开启路由功能


2）创建集群服务器

[root@proxy ~]# yum -y install ipvsadm
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:80 -s wrr
3）添加真实服务器
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 -w 1 -m
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.200 -w 1 -m
4）查看规则列表，并保存规则
[root@proxy ~]# ipvsadm -Ln
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm

步骤三：客户端测试

客户端使用curl命令反复连接http://192.168.4.5，查看BROWSER_ONLY=no
访问的页面是否会轮询到不同的后端真实服务器。


3 案例3：部署LVS-DR集群

准备环境
                     <------返回数据
              ___________________                              
              |                                |
        client------>proxy------->web


1, web需要和client在一个网段 (因为web需要直接返回网页给client)
2, web需要伪装成调度的VIP(因为访问的目标ip,和回复数据的ip必须一致)
3, 修改内核防止网络冲突 (/etc/sysctl.conf)
4, VIP必须配置在辅助接口,DIP必须配置在主接口

1 问题
使用LVS实现DR模式的集群调度服务器，为用户提供Web服务：
客户端IP地址为192.168.4.10
LVS调度器VIP地址为192.168.4.15
LVS调度器DIP地址设置为192.168.4.5
真实Web服务器地址分别为192.168.4.100、192.168.4.200
使用加权轮询调度算法，web1的权重为1，web2的权重为2
说明：
CIP是客户端的IP地址；
VIP是对客户端提供服务的IP地址；
RIP是后端服务器的真实IP地址；
DIP是调度器与后端服务器通信的IP地址（VIP必须配置在虚拟接口）。
3.2 方案

使用4台虚拟机，1台作为客户端、1台作为Director调度器、2台作为Real Server，拓扑结构如图-2所示。实验拓扑结构主机配置细节如表-4所示。

图-2
表-4

3.3 步骤

实现此案例需要按照如下步骤进行。
说明：
CIP是客户端的IP地址；
VIP是对客户端提供服务的IP地址；
RIP是后端服务器的真实IP地址；
DIP是调度器与后端服务器通信的IP地址（VIP必须配置在虚拟接口）。
步骤一：配置实验网络环境

1）设置Proxy代理服务器的VIP和DIP

注意：为了防止冲突，VIP必须要配置在网卡的虚拟接口！！！
   ifdown eth0  //关掉网卡

 [root@proxy ~]# cd /etc/sysconfig/network-scripts/
[root@proxy ~]# cp ifcfg-eth0{,:0}
[root@proxy ~]# vim ifcfg-eth0
TYPE=Ethernet     //网卡是以太网卡
BOOTPROTO=none    //没有dhcp则自己配
DEFROUTE=yes      //默认路由
NAME=eth0         //网卡名
DEVICE=eth0       //设备名称
ONBOOT=yes        //当开机时启动
IPADDR=192.168.4.5  //IP地址
PREFIX=24           //子网掩码
[root@proxy ~]# vim ifcfg-eth0:0
TYPE=Ethernet
BOOTPROTO=none
DEFROUTE=yes
NAME=eth0:0
DEVICE=eth0:0
ONBOOT=yes
IPADDR=192.168.4.15
PREFIX=24
[root@proxy ~]# systemctl restart network       //重启网络
[root@proxy ~]# ifconfig         //这里有时候看不到eth0:0网卡,因为RHEL7里网络配置文件NetworkManager和Centos7里网络配置文件 network 两个服务冲突必须先关掉一个才可以启动(systemctl stop network|NetworkManager)
 
2）设置Web1服务器网络参数
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0
接下来给web1配置VIP地址。
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web1 ~]# cd /etc/sysconfig/network-scripts/
[root@web1 ~]# cp ifcfg-lo{,:0}
[root@web1 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0
防止地址冲突的问题：
这里因为web1也配置与代理一样的VIP地址，默认肯定会出现地址冲突；
sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。
[root@web1 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15
[root@web1 ~]# sysctl -p
重启网络服务，设置防火墙与SELinux
[root@web1 ~]# systemctl restart network
[root@web1 ~]# ifconfig
常见错误：如果重启网络后未正确配置lo:0，有可能是NetworkManager和network服务有冲突，关闭NetworkManager后重启network即可。（非必须的操作）
[root@web1 ~]# systemctl stop NetworkManager
[root@web1 ~]# systemctl restart network   
3）设置Web2服务器网络参数
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0
接下来给web2配置VIP地址
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web2 ~]# cd /etc/sysconfig/network-scripts/
[root@web2 ~]# cp ifcfg-lo{,:0}           //lo本地回环地址网卡
[root@web2 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15          //IP地址
NETMASK=255.255.255.255      //子网掩码
NETWORK=192.168.4.15         //网络位  
BROADCAST=192.168.4.15       //广播地址
ONBOOT=yes                   //当开机时启动网卡
NAME=lo:0
防止地址冲突的问题：
这里因为web1也配置与代理一样的VIP地址，默认肯定会出现地址冲突；
sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。

[root@web2 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容  (防止冲突,只对192.168.4.15有效,其它无效)
net.ipv4.conf.all.arp_ignore = 1   //默认为0 表示问什么回答什么, 1 表示不回答(本机忽略) ,all所有网卡不包含lo
net.ipv4.conf.lo.arp_ignore = 1    //默认为0 表示问什么回答什么, 1 表示不回答(本机忽略)
net.ipv4.conf.lo.arp_announce = 2  //本机不要向外宣告自己的lo回环地址是192.168.4.15
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15
[root@web2 ~]# sysctl -p       //刷新读取配置文件使永久配置立即生效
重启网络服务，设置防火墙与SELinux
[root@web2 ~]# systemctl restart network
[root@web2 ~]# ifconfig
常见错误：如果重启网络后未正确配置lo:0，有可能是NetworkManager和network服务有冲突，关闭NetworkManager后重启network即可。（非必须的操作）
[root@web1 ~]# systemctl stop NetworkManager
[root@web1 ~]# systemctl restart network


/proc/sys/net/ipv4/conf/     //网卡所在目录

步骤二：proxy调度器安装软件并部署LVS-DR模式调度器

1）安装软件（如果已经安装，此步骤可以忽略）
[root@proxy ~]# yum -y install ipvsadm
2）清理之前实验的规则，创建新的集群服务器规则
[root@proxy ~]# ipvsadm -C                                #清空所有规则
[root@proxy ~]# ipvsadm -A -t 192.168.4.15:80 -s wrr
3）添加真实服务器(-g参数设置LVS工作模式为DR模式，-w设置权重)
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.100 -g -w 1
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.200 -g -w 1
4）查看规则列表，并保存规则
[root@proxy ~]# ipvsadm -Ln
TCP  192.168.4.15:80 wrr
  -> 192.168.4.100:80             Route   1      0          0         
  -> 192.168.4.200:80             Route   2      0          0
步骤三：客户端测试

客户端使用curl命令反复连接http://192.168.4.15，查看访问的页面是否会轮询到不同的后端真实服务器。
扩展知识：默认LVS不带健康检查功能，需要自己手动编写动态检测脚本，实现该功能：(参考脚本如下，仅供参考)
[root@proxy ~]# vim check.sh
#!/bin/bash
VIP=192.168.4.15:80
RIP1=192.168.4.100
RIP2=192.168.4.200
while :
do
   for IP in $RIP1 $RIP2
   do
           curl -s http://$IP &>/dev/vnull
if [ $? -eq 0 ];then
            ipvsadm -Ln |grep -q $IP || ipvsadm -a -t $VIP -r $IP
        else
             ipvsadm -Ln |grep -q $IP && ipvsadm -d -t $VIP -r $IP
        fi
   done
sleep 1
done


###############################################################################

Top
NSD CLUSTER DAY02

案例1：Keepalived高可用服务器
案例2：Keepalived+LVS服务器
案例3：配置HAProxy负载平衡集群



1 案例1：Keepalived高可用服务器

1.1 问题

准备三台Linux服务器，两台做Web服务器，并部署Keepalived高可用软件，一台作为客户端主机，实现如下功能：
使用Keepalived实现web服务器的高可用
Web服务器IP地址分别为192.168.4.100和192.168.4.200
Web服务器的浮动VIP地址为192.168.4.80
客户端通过访问VIP地址访问Web页面


Keepalived功能:
  1, VRRP 实现主从热备
   2, 自动配置LVS规则
   3, 健康检查       real server 192.168.4.100 80 {
                               TCP_CHECK{多久检查一次}   仅检测端口
                               HTTP_GET{
                                 url{
                                           }
                                        }    
                               SSL_GET{
                                     url{
                                               }
                                        }
                        }
      如何健康检查web服务器:  1, ping 192.168.4.100  缺点:主机开,服务没有开
                        2, curl http://192.168.4.100:80   主机好的,服务开了,如果服务器被攻击了 ,就无法知道
                               3, 测试具体页面 

1.2 方案

使用3台虚拟机，2台作为Web服务器，并部署Keepalived、1台作为客户端，拓扑结构如图-1所示，主机配置如表-1所示。

图-1
表-1

1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置网络环境（如果在前面课程已经完成该配置，可以忽略此步骤）

1）设置Web1服务器网络参数、配置Web服务
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html
[root@web1 ~]# systemctl restart httpd
2）设置Web2服务器网络参数、配置Web服务
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html
[root@web2 ~]# systemctl restart httpd
3）配置proxy主机的网络参数（如果已经设置，可以忽略此步骤）
[root@proxy ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth0
步骤二：安装Keepalived软件

注意：两台Web服务器做相同的操作。
[root@web1 ~]# yum install -y keepalived
[root@web2 ~]# yum install -y keepalived 
步骤三：部署Keepalived服务

1）修改web1服务器Keepalived配置文件
[root@web1 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                //设置报警收件人邮箱
  }
  notification_email_from ka@localhost    //设置发件人
  smtp_server 127.0.0.1                //定义邮件服务器
  smtp_connect_timeout 30
  router_id  web1                        //设置路由ID号（实验需要修改）
}
vrrp_instance VI_1 {
  state MASTER                         //主服务器为MASTER（备服务器需要修改为BACKUP）
  interface eth0                    //定义网络接口
  virtual_router_id 51                //主备服务器VRID号必须一致
  priority 100                     //服务器优先级,优先级高优先获取VIP  如果优先级都一样就比IP地址,大的优先级就高
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                       //主备服务器密码必须一致
  }
  virtual_ipaddress {                   //谁是主服务器谁获得该VIP（实验需要修改）
192.168.4.80 
}    
}
2）修改web2服务器Keepalived配置文件
[root@web2 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                //设置报警收件人邮箱
  }
  notification_email_from ka@localhost    //设置发件人
  smtp_server 127.0.0.1                //定义邮件服务器
  smtp_connect_timeout 30
  router_id  web2                        //设置路由ID号（实验需要修改）
}
vrrp_instance VI_1 {
  state BACKUP                             //备服务器为BACKUP（实验需要修改）
  interface eth0                        //定义网络接口
  virtual_router_id 51                    //主辅VRID号必须一致
  priority 50                             //服务器优先级（实验需要修改）
  advert_int 1
  authentication {
     auth_type pass
     auth_pass 1111                       //主辅服务器密码必须一致
  }
  virtual_ipaddress {                 //谁是主服务器谁配置VIP（实验需要修改）
192.168.4.80 
 }   
}
3）启动服务
[root@web1 ~]# systemctl start keepalived
[root@web2 ~]# systemctl start keepalived
4）配置防火墙和SELinux
启动keepalived会自动添加一个drop的防火墙规则，需要清空！
[root@web1 ~]# iptables -F               //关闭防火墙
[root@web1 ~]# setenforce 0              //关闭selinux
[root@web2 ~]# iptables -F               //关闭防火墙
[root@web1 ~]# setenforce 0
步骤四：测试

1）登录两台Web服务器查看VIP信息
[root@web1 ~]# ip addr show eth0   //简写: ip a s eth0
[root@web2 ~]# ip addr show eth0
2) 客户端访问
客户端使用curl命令连接http://192.168.4.80，查看Web页面；关闭Web1服务器的网卡，客户端再次访问http://192.168.4.80，验证是否可以正常访问服务。
2 案例2：Keepalived+LVS服务器
2.1 问题

使用Keepalived为LVS调度器提供高可用功能，防止调度器单点故障，为用户提供Web服务：
LVS1调度器真实IP地址为192.168.4.5
LVS2调度器真实IP地址为192.168.4.6
服务器VIP地址设置为192.168.4.15
真实Web服务器地址分别为192.168.4.100、192.168.4.200
使用加权轮询调度算法，真实web服务器权重不同
2.2 方案

使用5台虚拟机，1台作为客户端主机、2台作为LVS调度器、2台作为Real Server，实验拓扑环境结构如图-2所示，基础环境配置如表-2所示。

图-3
表-2

注意：所有主机都需要配置IP地址与有效的YUM源。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置网络环境

1）设置Web1服务器的网络参数
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0
接下来给web1配置VIP地址
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web1 ~]# cd /etc/sysconfig/network-scripts/
[root@web1 ~]# cp ifcfg-lo{,:0}
[root@web1 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0
注意：这里因为web1也配置与调度器一样的VIP地址，默认肯定会出现地址冲突。
写入这四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应。
[root@web1 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15
重启网络服务，设置防火墙与SELinux
[root@web1 ~]# systemctl stop NetworkManager
[root@web1 ~]# systemctl disable NetworkManager
[root@web1 ~]# systemctl restart network
[root@web1 ~]# ifconfig
[root@web1 ~]# systemctl stop firewalld
[root@web1 ~]# setenforce 0
2）设置Web2服务器的网络参数
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0
接下来给web2配置VIP地址
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web2 ~]# cd /etc/sysconfig/network-scripts/
[root@web2 ~]# cp ifcfg-lo{,:0}
[root@web2 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0
注意：这里因为web2也配置与代理一样的VIP地址，默认肯定会出现地址冲突。
写入这四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应。
[root@web2 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15
重启网络服务，设置防火墙与SELinux
[root@web2 ~]# systemctl stop NetworkManager
[root@web1 ~]# systemctl disable NetworkManager
[root@web2 ~]# systemctl restart network
[root@web2 ~]# ifconfig
[root@web2 ~]# systemctl stop firewalld
[root@web2 ~]# setenforce 0
3）配置proxy1主机的网络参数(不配置VIP，由keepalvied自动配置)
[root@proxy1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
[root@proxy1 ~]# nmcli connection up eth0
4）配置proxy2主机的网络参数(不配置VIP，由keepalvied自动配置)
注意：按照前面的课程环境，默认没有该虚拟机，需要重新建一台虚拟机proxy2。
[root@proxy2 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.6/24 connection.autoconnect yes
[root@proxy2 ~]# nmcli connection up eth0
步骤二：配置后台web服务

1）安装软件，自定义Web页面（web1和web2主机）
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html
2）启动Web服务器软件(web1和web2主机)
[root@web1 ~]# systemctl start httpd ; systemctl enable httpd
[root@web2 ~]# systemctl start httpd ; systemctl enable httpd
步骤三：调度器安装Keepalived与ipvsadm软件

注意：两台LVS调度器执行相同的操作（如何已经安装软件，可用忽略此步骤）。
安装软件
[root@proxy1 ~]# yum install -y keepalived
[root@proxy1 ~]# systemctl enable keepalived
[root@proxy1 ~]# yum install -y ipvsadm
[root@proxy1 ~]# ipvsadm -C
[root@proxy2 ~]# yum install -y keepalived
[root@proxy2 ~]# systemctl enable keepalived
[root@proxy2 ~]# yum install -y ipvsadm
[root@proxy2 ~]# ipvsadm -C
步骤四：部署Keepalived实现LVS-DR模式调度器的高可用

1）LVS1调度器设置Keepalived，并启动服务
[root@proxy1 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                //设置报警收件人邮箱
  }
  notification_email_from ka@localhost    //设置发件人
  smtp_server 127.0.0.1                //定义邮件服务器
  smtp_connect_timeout 30
  router_id  lvs1                        //设置路由ID号(实验需要修改)
}
vrrp_instance VI_1 {
  state MASTER                             //主服务器为MASTER
  interface eth0                        //定义网络接口
  virtual_router_id 51                 //主辅VRID号必须一致
  priority 100                         //服务器优先级
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                       //主辅服务器密码必须一致
  }
  virtual_ipaddress {                   //配置VIP（实验需要修改）
192.168.4.15 
 }   
}
virtual_server 192.168.4.15 80 {           //设置ipvsadm的VIP规则（实验需要修改）
  delay_loop 6
  lb_algo rr                              //设置LVS调度算法为RR
  lb_kind DR                               //设置LVS的模式为DR（实验需要修改）
  #persistence_timeout 50                //（实验需要注释）如果访问web1时,50秒内不跳转
#注意这样的作用是保持连接，开启后，客户端在一定时间内始终访问相同服务器
  protocol TCP                          //指定协议
  real_server 192.168.4.100 80 {         //设置后端web服务器真实IP（实验需要修改）
    weight 1                             //设置权重为1
    TCP_CHECK {                           //对后台real_server做健康检查（实验需要修改）
    connect_timeout 3                     //超时时间3秒
    nb_get_retry 3                        //重复试3次
    delay_before_retry 3                  //隔3秒检查一次
    }
  }
 real_server 192.168.4.200 80 {       //设置后端web服务器真实IP（实验需要修改）
    weight 2                          //设置权重为1
    TCP_CHECK {                        //对后台real_server做健康检查（实验需要修改）
    connect_timeout 3
    nb_get_retry 3
    delay_before_retry 3
    }
  }
}
[root@proxy1 ~]# systemctl start keepalived
[root@proxy1 ~]# ipvsadm -Ln                     #查看LVS规则
[root@proxy1 ~]# ip a  s                          #查看VIP配置
[root@proxy1 ~]# iptables -F
2）LVS2调度器设置Keepalived
[root@proxy2 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                //设置报警收件人邮箱
  }
  notification_email_from ka@localhost    //设置发件人
  smtp_server 127.0.0.1                //定义邮件服务器
  smtp_connect_timeout 30
  router_id  lvs2                        //设置路由ID号（实验需要修改）
}
vrrp_instance VI_1 {
  state BACKUP                             //从服务器为BACKUP（实验需要修改）
  interface eth0                        //定义网络接口
  virtual_router_id 51                    //主辅VRID号必须一致
  priority 50                             //服务器优先级（实验需要修改）
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                       //主辅服务器密码必须一致
  }
  virtual_ipaddress {                   //设置VIP（实验需要修改）
192.168.4.15  
}  
}
virtual_server 192.168.4.15 80 {          //自动设置LVS规则（实验需要修改）
  delay_loop 6
  lb_algo  rr                              //设置LVS调度算法为RR
  lb_kind DR                               //设置LVS的模式为DR（实验需要修改）
 # persistence_timeout 50               //（实验需要注释）
#注意这样的作用是保持连接，开启后，客户端在一定时间内始终访问相同服务器
  protocol TCP
  real_server 192.168.4.100 80 {        //设置后端web服务器的真实IP（实验需要修改）
    weight 1                              //设置权重为1
    TCP_CHECK {                         //对后台real_server做健康检查（实验需要修改）
    connect_timeout 3
    nb_get_retry 3
    delay_before_retry 3
    }
  }
 real_server 192.168.4.200 80 {         //设置后端web服务器的真实IP（实验需要修改）
    weight 2                              //设置权重为1
    TCP_CHECK {                        //对后台real_server做健康检查（实验需要修改）
    connect_timeout 3
    nb_get_retry 3
    delay_before_retry 3
    }
  }
[root@proxy2 ~]# systemctl start keepalived
[root@proxy2 ~]# ipvsadm -Ln                 #查看LVS规则
[root@proxy2 ~]# ip  a   s                    #查看VIP设置
[root@proxy2 ~]# iptables -F
步骤五：客户端测试

客户端使用curl命令反复连接http://192.168.4.15，查看访问的页面是否会轮询到不同的后端真实服务器。
3 案例3：配置HAProxy负载平衡集群
3.1 问题

准备4台Linux服务器，两台做Web服务器，1台安装HAProxy，1台做客户端，实现如下功能：
客户端访问HAProxy，HAProxy分发请求到后端Real Server
开启HAProxy监控页面，及时查看调度器状态
设置HAProxy为开机启动
3.2 方案

使用4台虚拟机，1台作为HAProxy调度器、2台作为Real Server、1台作为客户端，拓扑结构如图-3所示，具体配置如表-3所示。

图-3
表-3

3.3 步骤

实现此案例需要按照如下步骤进行。
注意事项：

将前面实验VIP、LVS等实验的内容清理干净！！！！！！

删除所有设备的VIP，清空所有LVS设置，关闭keepalived！！！

web1关闭多余的网卡与VIP，配置本地真实IP地址。
[root@web1 ~]# ifdown lo:0               //临时关掉lo:0  
[root@web1 ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth1
Web2关闭多余的网卡与VIP，配置本地真实IP地址。
[root@web2 ~]# ifdown lo:0              //临时关掉lo:0
[root@web2 ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth1
proxy关闭keepalived服务，清理LVS规则。
[root@proxy ~]# systemctl stop keepalived
[root@proxy ~]# systemctl disable keepalived
[root@proxy ~]# ipvsadm -C
[root@proxy ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth0
[root@proxy ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth1
步骤一：配置后端Web服务器

设置两台后端Web服务（如果已经配置完成，可用忽略此步骤）
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# systemctl start httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# systemctl start httpd
[root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html


步骤二：部署HAProxy服务器

1）配置网络，安装软件
[root@haproxy ~]# yum -y install haproxy
2）修改配置文件
[root@haproxy ~]# vim /etc/haproxy/haproxy.cfg
global
 log 127.0.0.1 local2   ##[err warning info debug]
 chroot /usr/local/haproxy
 pidfile /var/run/haproxy.pid  ##haproxy的pid存放路径
 maxconn 4000     ##最大连接数，默认4000
 user haproxy         
 group haproxy
 daemon       ##创建1个进程进入deamon模式运行
defaults
 mode http    ##默认的模式mode { tcp|http|health } (http7层网站调度器)
option dontlognull  ##不记录健康检查的日志信息
 option httpclose  ##每次请求完毕后主动关闭http通道
 option httplog   ##日志类别http日志格式
 option forwardfor  ##后端服务器可以从Http Header中获得客户端ip
 option redispatch  ##serverid服务器挂掉后强制定向到其他健康服务器
 timeout connect 10000 #如果backend没有指定，默认为10s
 timeout client 300000 ##客户端连接超时
 timeout server 300000 ##服务器连接超时
 maxconn  3000  ##最大连接数
 retries  3   ##3次连接失败就认为服务不可用，也可以通过后面设置


加上下面几行http://192.168.4.5:1080/stats测试状态监控页面是否正常。访问状态监控页的内容
listen stats 0.0.0.0:1080   #监听端口
    stats refresh 30s   #统计页面自动刷新时间
    stats uri /stats   #统计页面url
    stats realm Haproxy Manager #进入管理解面查看状态信息
    stats auth admin:admin  #统计页面用户名和密码设置
  

集群:
listen  websrv-rewrite 0.0.0.0:80
   balance roundrobin(rr)
   server  web1 192.168.2.100:80 check inter 2000 rise 2 fall 5     //健康检查(check) 2000毫秒检查一次,rise 2 -->2次成功连接才成功,fall 5 -->5次连接失败才认为失败  
   server  web2 192.168.2.200:80 check inter 2000 rise 2 fall 5
3）启动服务器并设置开机启动
[root@haproxy ~]# systemctl start haproxy
[root@haproxy ~]# systemctl enable haproxy
步骤三：客户端验证

客户端配置与HAProxy相同网络的IP地址，并使用火狐浏览器访问http://192.168.4.5，测试调度器是否正常工作，客户端访问http://192.168.4.5:1080/stats测试状态监控页面是否正常。访问状态监控页的内容，参考图-4所示。

图-4
备注：
Queue队列数据的信息（当前队列数量，最大值，队列限制数量）；
Session rate每秒会话率（当前值，最大值，限制数量）；
Sessions总会话量（当前值，最大值，总量，Lbtot: total number of times a server was selected选中一台服务器所用的总时间）；
Bytes（入站、出站流量）；
Denied（拒绝请求、拒绝回应）；
Errors（错误请求、错误连接、错误回应）；
Warnings（重新尝试警告retry、重新连接redispatches）；
Server(状态、最后检查的时间（多久前执行的最后一次检查）、权重、备份服务器数量、down机服务器数量、down机时长)。



#####################################################################################################3


Top
NSD CLUSTER DAY03

案例1：实验环境
案例2：部署ceph集群
案例3：创建Ceph块存储
1 案例1：实验环境

什么是ceph(最少3台服务器起步又叫3副本---->过半原则):
  ceph是个分布式文件系统(也是集群),具有高扩展,高可用,高性能的特点.
  ceph可以提供对象存储,块存储,文件系统存储, 可以提供EB级别的存储空间(EB->PB->TB->GB)
   软件定义存储 
ceph官方文档: http://docs.ceph.org/start/intro


1.1 问题

准备四台KVM虚拟机，其三台作为存储集群节点，一台安装为客户端，实现如下功能：
创建1台客户端虚拟机
创建3台存储集群虚拟机
配置主机名、IP地址、YUM源
修改所有主机的主机名
配置无密码SSH连接
配置NTP时间同步
创建虚拟机磁盘
1.2 方案

使用4台虚拟机，1台客户端、3台存储集群服务器，拓扑结构如图-1所示。

图-1
所有主机的主机名及对应的IP地址如表-1所示。
注意：所有主机基本系统光盘的YUM源必须提前配置好。
表－1 主机名称及对应IP地址表

1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：安装前准备

1）物理机为所有节点配置yum源服务器。
提示：ceph10.iso在/linux-soft/02目录。
[root@room9pc01 ~]# mkdir  /var/ftp/ceph
[root@room9pc01 ~]# mount ceph10.iso /var/ftp/ceph/
2）配置无密码连接(包括自己远程自己也不需要密码)，在node1操作。
[root@node1 ~]# ssh-keygen   -f /root/.ssh/id_rsa    -N ''     //-f 位置 -N 密码
[root@node1 ~]# for i in 10  11  12  13
 do
     ssh-copy-id  192.168.4.$i
 done
3）修改/etc/hosts并同步到所有主机。
警告：/etc/hosts解析的域名必须与本机主机名一致！！！！
 [root@node1 ~]# cat /etc/hosts
... ...
192.168.4.10  client
192.168.4.11     node1
192.168.4.12     node2
192.168.4.13     node3
警告：/etc/hosts解析的域名必须与本机主机名一致！！！！
[root@node1 ~]# for i in client node1  node2  node3
do
scp  /etc/hosts   $i:/etc/
done
4）修改所有节点都需要配置YUM源，并同步到所有主机。
[root@node1 ~]# cat /etc/yum.repos.d/ceph.repo
[mon]
name=mon
baseurl=ftp://192.168.4.254/ceph/MON
gpgcheck=0
[osd]
name=osd
baseurl=ftp://192.168.4.254/ceph/OSD
gpgcheck=0
[tools]
name=tools
baseurl=ftp://192.168.4.254/ceph/Tools
gpgcheck=0
[root@node1 ~]# yum repolist                #验证YUM源软件数量
源标识            源名称                    状态
Dvd                redhat                    9,911
Mon                mon                        41
Osd                osd                        28
Tools            tools                    33
repolist: 10,013
[root@node1 ~]# for i in  client  node1  node2  node3
do
scp  /etc/yum.repos.d/ceph.repo   $i:/etc/yum.repos.d/
done
5）所有节点主机与真实主机的NTP服务器同步时间。
提示：默认真实物理机已经配置为NTP服务器。
[root@node1 ~]# vim /etc/chrony.conf
… …
server 192.168.4.254   iburst
[root@node1 ~]# for i in client  node1  node2  node3
do
     scp /etc/chrony.conf $i:/etc/
     ssh  $i  "systemctl restart chronyd"
done
步骤三：准备存储磁盘

物理机上为每个虚拟机准备3块20G磁盘（可以使用命令，也可以使用图形直接添加）。
 [root@room9pc01 ~]# virt-manager
2 案例2：部署ceph集群
2.1 问题

沿用练习一，部署Ceph集群服务器，实现以下目标：
安装部署工具ceph-deploy
创建ceph集群
准备日志磁盘分区
创建OSD存储空间
查看ceph状态，验证
2.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：安装部署软件ceph-deploy

1）在node1安装部署工具，学习工具的语法格式。
[root@node1 ~]#  yum -y install ceph-deploy
[root@node1 ~]#  ceph-deploy  --help
[root@node1 ~]#  ceph-deploy mon --help
2）创建目录
[root@node1 ~]#  mkdir ceph-cluster
[root@node1 ~]#  cd ceph-cluster/



步骤二：部署Ceph集群

1）创建Ceph集群配置,在ceph-cluster目录下生成Ceph配置文件。

在ceph.conf配置文件中定义monitor主机是谁。

[root@node1 ceph-cluster]# ceph-deploy new node1 node2 node3
root@node1 ceph-cluster]# ls
ceph.conf  ceph-deploy-ceph.log  ceph.mon.keyring(存放密码文件)


[root@node1 ceph-cluster]# cat ceph.conf   //查看主配置文件
[global]
fsid = 0df8f608-b633-458f-a70e-00a30e4994c9
mon_initial_members = node1, node2, node3
mon_host = 192.168.4.11,192.168.4.12,192.168.4.13
auth_cluster_required = cephx
auth_service_required = cephx        //cephx密码占位符
auth_client_required = cephx



2）给所有节点安装ceph相关软件包。
[root@node1 ceph-cluster]# for i in node1 node2 node3
do
    ssh  $i "yum -y install ceph-mon ceph-osd ceph-mds ceph-radosgw"
done 
3）初始化所有节点的mon服务，也就是启动mon服务（主机名解析必须对）。mon(不负责存储,专做健康检查,最少3台才能做ceph)
%%%%%%  在生产环境中,做ceph最少要6台机器,mon(健康检查)与osd(存储)必须分开在不同的服务器上做%%%%%%%%%%

[root@node1 ceph-cluster]# ceph-deploy mon create-initial
[root@node1 ceph-cluster]# ceph -s           //查看ceph的状态




常见错误及解决方法（非必要操作，有错误可以参考）：
如果提示如下错误信息：
[node1][ERROR ] admin_socket: exception getting command descriptions: [Error 2] No such file or directory
解决方案如下（在node1操作）：
先检查自己的命令是否是在ceph-cluster目录下执行的！！！！如果确认是在该目录下执行的create-initial命令，依然报错，可以使用如下方式修复。
[root@node1 ceph-cluster]# vim ceph.conf      #文件最后追加以下内容
public_network = 192.168.4.0/24
修改后重新推送配置文件:
[root@node1 ceph-cluster]# ceph-deploy --overwrite-conf config push node1 node2 node3



步骤三：创建OSD

备注：vdb1和vdb2这两个分区用来做存储服务器的journal缓存盘。
for i in node1 node2 node3
do
     ssh $i "parted /dev/vdb mklabel gpt"                 //指定用gpt模式划分磁盘
     ssh $i "parted /dev/vdb mkpart primary 1 50%"         //第1个分区从第1M开始分到整个磁盘的50%
     ssh $i "parted /dev/vdb mkpart primary 50% 100%"      //第2个分区从整个磁盘的50% 到100%
done

2）磁盘分区后的默认权限无法让ceph软件对其进行读写操作，需要修改权限。

node1、node2、node3都需要操作，这里以node1为例。
[root@node1 ceph-cluster]# chown  ceph.ceph  /dev/vdb1
[root@node1 ceph-cluster]# chown  ceph.ceph  /dev/vdb2
用脚本批量修改:
for i in node1 node2 node3
do
  ssh $i "chown ceph.ceph /dev/vdb1"     //这里chown修改权限所有者和所属组之间用(.或:) 都可以
  ssh $i "chown ceph.ceph /dev/vdb2"
done

  注意:权限很重要,否则osd无法读取

#上面的权限修改为临时操作，重启计算机后，权限会再次被重置。
#我们还需要将规则写到配置文件实现永久有效。
#规则：如果设备名称为/dev/vdb1则设备文件的所有者和所属组都设置为ceph。
#规则：如果设备名称为/dev/vdb2则设备文件的所有者和所属组都设置为ceph。
[root@node1 ceph-cluster]# vim /etc/udev/rules.d/70-vdb.rules
ENV{DEVNAME}=="/dev/vdb1",OWNER="ceph",GROUP="ceph"     //2个=号为判断,1个=号为赋值
ENV{DEVNAME}=="/dev/vdb2",OWNER="ceph",GROUP="ceph"

for i in node2 node3 
> do
>   scp /etc/udev/rules.d/70-vdb.rules $i:/etc/udev/rules.d/
> done

3）初始化清空磁盘数据（仅node1操作即可）。
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node1:vdc   node1:vdd    
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node2:vdc   node2:vdd
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node3:vdc   node3:vdd   

也可以一条命令操作:
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node1:vdc node1:vdd node2:vdc   node2:vdd node3:vdc   node3:vdd


4）创建OSD存储空间（仅node1操作即可）起osd服务

重要：很多同学在这里会出错！将主机名、设备名称输入错误！！！
[root@node1 ceph-cluster]# ceph-deploy osd create \
 node1:vdc:/dev/vdb1 node1:vdd:/dev/vdb2  
//创建osd存储设备，vdc为集群提供存储空间，vdb1提供JOURNAL缓存，
//每个存储设备对应一个缓存设备，缓存需要SSD，不需要很大
[root@node1 ceph-cluster]# ceph-deploy osd create \
 node2:vdc:/dev/vdb1 node2:vdd:/dev/vdb2
[root@node1 ceph-cluster]# ceph-deploy osd create \
 node3:vdc:/dev/vdb1 node3:vdd:/dev/vdb2 

[root@node1 ceph-cluster]# ceph -s

 
常见错误及解决方法（非必须操作）。
使用osd create创建OSD存储空间时，如提示下面的错误提示：
[ceph_deploy][ERROR ] RuntimeError: bootstrap-osd keyring not found; run 'gatherkeys'
可以使用如下命令修复文件，重新配置ceph的密钥文件：
[root@node1 ceph-cluster]#  ceph-deploy gatherkeys node1 node2 node3 

步骤四：验证测试

1) 查看集群状态。
[root@node1 ~]#  ceph  -s
2）常见错误（非必须操作）。
如果查看状态包含如下信息：
health: HEALTH_WARN
        clock skew detected on  node2, node3…  
clock skew表示时间不同步，解决办法：请先将所有主机的时间都使用NTP时间同步！！！
Ceph要求所有主机时差不能超过0.05s，否则就会提示WARN。
如果状态还是失败，可以尝试执行如下命令，重启ceph服务：
[root@node1 ~]#  systemctl restart ceph\*.service ceph\*.target

3 案例3：创建Ceph块存储
3.1 问题

沿用练习一，使用Ceph集群的块存储功能，实现以下目标：
创建块存储镜像
客户端映射镜像
创建镜像快照
使用快照还原数据
使用快照克隆镜像
删除快照与镜像
3.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：创建镜像

1）查看存储池。
[root@node1 ~]# ceph osd lspools
0 rbd,
2）创建镜像、查看镜像    //每一个镜像就是一个共享磁盘分区

这个时候rbd不能tab键,要exit退出,再远程管理进入,才能tab键

[root@node1 ~]# rbd create demo-image --image-feature  layering --size 10G   //size定义共享盘的大小,注意这里size不检查系统磁盘的大小的,所以不能大于osd总的大小.
[root@node1 ~]# rbd create rbd/image  --image-feature  layering --size 10G   //指定池子
#这里的demo-image和image为创建的镜像名称，可以为任意字符。
#--image-feature参数指定我们创建的镜像有哪些功能，layering是开启COW功能(快照功能)。

#提示：ceph镜像支持很多功能，但很多是操作系统不支持的，我们只开启layering。
[root@node1 ~]# rbd list    或 rbd ls   //查共享
[root@node1 ~]# rbd info demo-image    //查看详细信息
rbd image 'demo-image':
    size 10240 MB in 2560 objects
    order 22 (4096 kB objects)
    block_name_prefix: rbd_data.d3aa2ae8944a
    format: 2
    features: layering

步骤二：动态调整

1）缩小容量
[root@node1 ~]# rbd resize --size 7G image --allow-shrink
[root@node1 ~]# rbd info image
2）扩容容量
[root@node1 ~]# rbd resize --size 15G image
[root@node1 ~]# rbd info image



步骤三：通过KRBD访问

1）客户端通过KRBD访问
#客户端需要安装ceph-common软件包
#拷贝配置文件（否则不知道集群在哪）
#拷贝连接密钥（否则无连接权限）
[root@client ~]# yum -y  install ceph-common
[root@client ~]# scp 192.168.4.11:/etc/ceph/ceph.conf  /etc/ceph/
[root@client ~]# scp 192.168.4.11:/etc/ceph/ceph.client.admin.keyring \
/etc/ceph/

或者这样scp:
[root@node1 ceph]# scp ceph.conf 192.168.4.10:/etc/ceph/
ceph.conf                                                100%  235   405.9KB/s   00:00    
[root@node1 ceph]# scp ceph.client.admin.keyring client:/etc/ceph/
ceph.client.admin.keyring                                100%   63    97.6KB/s   00:00  

[root@client ~]# rbd map image      
[root@client ~]#  lsblk
[root@client ~]# rbd showmapped
id pool image snap device    
0  rbd  image -    /dev/rbd0


2) 客户端格式化、挂载分区
[root@client ~]# mkfs.xfs /dev/rbd0
[root@client ~]# mount /dev/rbd0 /mnt/
[root@client ~]# echo "test" > /mnt/test.txt
步骤四：创建镜像快照

1) 查看镜像快照（默认所有镜像都没有快照）。
 [root@node1 ~]# rbd snap ls image
2) 给镜像创建快照。
[root@node1 ~]# rbd snap create image --snap image-snap1  //创建快照
#为image镜像创建快照，快照名称为image-snap1
[root@node1 ~]# rbd snap ls image
SNAPID NAME            SIZE 
     4 image-snap1 15360 MB


3) 删除客户端写入的测试文件
[root@client ~]# rm  -rf   /mnt/test.txt
[root@client ~]# umount  /mnt     //一定要卸掉挂载否则弄坏共享磁盘


4) 还原快照
[root@node1 ~]# rbd snap rollback image --snap image-snap1  //还原快照
 
#客户端重新挂载分区
[root@client ~]# mount /dev/rbd0 /mnt/
[root@client ~]# ls  /mnt


步骤四：创建快照克隆 (用现有的镜像克隆一个一样的镜像) -->创建共享镜像

1）克隆快照
[root@node1 ~]#  rbd snap protect image --snap image-snap1   //保护快照
[root@node1 ~]#  rbd snap rm image --snap image-snap1    //会失败
[root@node1 ~]#  rbd clone \
image --snap image-snap1 image-clone --image-feature layering
//使用image的快照image-snap1克隆一个新的名称为image-clone镜像
2）查看克隆镜像与父镜像快照的关系
[root@node1 ~]#  rbd info image-clone
rbd image 'image-clone':
    size 15360 MB in 3840 objects
    order 22 (4096 kB objects)
    block_name_prefix: rbd_data.d3f53d1b58ba
    format: 2
    features: layering
    flags: 
    parent: rbd/image@image-snap1
#克隆镜像很多数据都来自于快照链
#如果希望克隆镜像可以独立工作，就需要将父快照中的数据，全部拷贝一份，但比较耗时！！！

[root@node1 ~]#  rbd flatten image-clone
[root@node1 ~]#  rbd info image-clone
rbd image 'image-clone':
    size 15360 MB in 3840 objects
    order 22 (4096 kB objects)
    block_name_prefix: rbd_data.d3f53d1b58ba
    format: 2
    features: layering
    flags: 
#注意，父快照信息没了！
[root@node1 ~]#  rbd snap unprotect image --snap image-snap1     #取消快照保护
[root@node1 ~]#  rbd snap rm image --snap image-snap1            #可以删除快照
步骤四：其他操作

1） 客户端撤销磁盘映射
[root@client ~]# umount /mnt
[root@client ~]# rbd showmapped
id pool image        snap device    
0  rbd  image        -    /dev/rbd0
//语法格式:
[root@client ~]# rbd unmap /dev/rbd0        //客户端撤销共享盘


#########################################################################################

Top
NSD CLUSTER DAY04

案例1：块存储应用案例
案例2：Ceph文件系统
案例3：创建对象存储服务器
1 案例1：块存储应用案例
1.1 问题

延续Day03的实验内容，演示块存储在KVM虚拟化中的应用案例，实现以下功能：
Ceph创建块存储镜像
客户端安装部署ceph软件
客户端部署虚拟机
客户端创建secret
设置虚拟机配置文件，调用ceph存储

快存储(mon,osd)
文件系统存储(mds和2个池)
对象存储------百度云盘(编写一个程序,通过程序让服务器读写资料)

1.2 方案

使用Ceph存储创建镜像。
KVM虚拟机调用Ceph镜像作为虚拟机的磁盘。
1.3 步骤

实现此案例需要按照如下步骤进行。
1）创建磁盘镜像。
[root@node1 ~]# rbd create vm1-image --image-feature  layering --size 10G  //创建10G的云盘
[root@node1 ~]# rbd  list
[root@node1 ~]# rbd  info  vm1-image

2）Ceph认证账户（仅查看即可）。
Ceph默认开启用户认证，客户端需要账户才可以访问，默认账户名称为client.admin，key是账户的密钥。
可以使用ceph auth添加新账户（案例我们使用默认账户）。
[root@node1 ~]# cat /etc/ceph/ceph.conf                    //配置文件 
[global]
mon_initial_members = node1, node2, node3
mon_host = 192.168.2.10,192.168.2.20,192.168.2.30
auth_cluster_required = cephx                                //开启认证
auth_service_required = cephx                                //开启认证
auth_client_required = cephx                                //开启认证
[root@node1 ~]# cat /etc/ceph/ceph.client.admin.keyring        //账户文件
[client.admin]
    key = AQBTsdRapUxBKRAANXtteNUyoEmQHveb75bISg==
3）创建KVM虚拟机（注意：这里使用真实机操作！！！）。
创建2台的KVM虚拟机，或者直接使用现有的虚拟机也可以。

[root@room9pc01 ~]# virsh secret-list   //列出虚拟机密码


4）配置libvirt secret（注意：这里使用真实机操作！！！）。
编写账户信息文件，让KVM知道ceph的账户名称。
[root@room9pc01 ~]# vim secret.xml            //新建临时文件，内容如下 
<secret ephemeral='no' private='no'>
        <usage type='ceph'>
                <name>client.admin secret</name>
        </usage>
</secret>
#使用XML配置文件创建secret
[root@room9pc01 ~]# virsh secret-define secret.xml
733f0fd1-e3d6-4c25-a69f-6681fc19802b       
//随机的UUID，这个UUID对应的有账户信息
给secret绑定admin账户的密码，密码参考ceph.client.admin.keyring文件。

[root@room9pc01] virsh secret-set-value \
--secret 733f0fd1-e3d6-4c25-a69f-6681fc19802b \
--base64 AQBTsdRapUxBKRAANXtteNUyoEmQHveb75bISg
//这里secret后面是之前创建的secret的UUID
//base64后面是client.admin账户的密码
//现在secret中既有账户信息又有密钥信息
5）虚拟机的XML配置文件。
每个虚拟机都会有一个XML配置文件，包括：
虚拟机的名称、内存、CPU、磁盘、网卡等信息。
[root@room9pc01 ~]# vim /etc/libvirt/qemu/vm1.xml
//原始模板内容如下：
<disk type='file' device='disk'>
      <driver name='qemu' type='qcow2'/>
      <source file='/var/lib/libvirt/images/vm1.qcow2'/>
      <target dev='vda' bus='virtio'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x0'/>
    </disk>
不推荐直接使用vim修改配置文件，推荐使用virsh edit修改配置文件，效果如下：
[root@room9pc01] virsh edit tedu_node01                //tedu_node01为虚拟机名称
<disk type='network' device='disk'>
      <driver name='qemu' type='raw'/>
      <auth username='admin'> 
      <secret type='ceph' uuid='733f0fd1-e3d6-4c25-a69f-6681fc19802b'/>  //uuid不是固定的,用virsh secret-lsit查看uuid
      </auth>
      <source protocol='rbd' name='rbd/vm1-image'>          <host name='192.168.4.11' port='6789'/>     </source>
    <target dev='vda' bus='virtio'/>       //'vda'磁盘如果配置文件里有就重新改名为'vdb'
 </disk>
备注：修改secret的UUID，修改source中的共享名name，修改dev设备名称。


ceph-deploy purgedata node1 node2 node3 
ceph-deploy purge  node1 node2 node3          //


2 案例2：Ceph文件系统
2.1 问题

延续前面的实验，实现Ceph文件系统的功能。具体实现有以下功能：
部署MDSs节点
创建Ceph文件系统
客户端挂载文件系统
2.2 方案

添加一台虚拟机，部署MDS节点。
主机的主机名及对应的IP地址如表-1所示。
表－1 主机名称及对应IP地址表

2.3 步骤

实现此案例需要按照如下步骤进行。
1）添加一台新的虚拟机，要求如下：
IP地址:192.168.4.14
主机名:node4
配置yum源（包括rhel、ceph的源）
与Client主机同步时间
node1允许无密码远程node4

2）部署元数据服务器
登陆node4，安装ceph-mds软件包
[root@node4 ~]# yum -y install ceph-mds 
登陆node1部署节点操作
[root@node1 ~]# cd  /root/ceph-cluster
//该目录，是最早部署ceph集群时，创建的目录
[root@node1 ceph-cluster]# ceph-deploy mds create node4
//远程nod4，拷贝配置文件，启动mds服务
如果没有配置文件则可以通过admin命令重新发送配置和密钥（备选操作）
[root@node1 ceph-cluster]# ceph-deploy admin node4
//同步配置文件和key


3）创建存储池
[root@node4 ~]# ceph osd pool create cephfs_data 128
//创建存储池，对应128个PG(相当于128个目录),这个数字对应的是2的多少次方 
[root@node4 ~]# ceph osd pool create cephfs_metadata 128
//创建存储池，对应128个PG
备注：一个文件系统是由inode和block两部分组成，效果如图-1所示。
inode存储文件的描述信息（metadata元数据），block中存储真正的数据。

图-1
4）创建Ceph文件系统
[root@node4 ~]# ceph mds stat                     //查看mds状态
e2:, 1 up:standby
[root@node4 ~]# ceph fs new myfs1 cephfs_metadata cephfs_data
new fs with metadata pool 2 and data pool 1
//注意，先写medadata池，再写data池
//默认，只能创建1个文件系统，多余的会报错
[root@node4 ~]# ceph fs ls
name: myfs1, metadata pool: cephfs_metadata, data pools: [cephfs_data ]
[root@node4 ~]# ceph mds stat
e4: 1/1/1 up {0=node4=up:creating}


ceph仅支持一个文件系统共享


5）客户端挂载
[root@client ~]# mount -t ceph 192.168.4.11:6789:/  /mnt/ \
-o name=admin,secret=AQBTsdRapUxBKRAANXtteNUyoEmQHveb75bISg==
//注意:文件系统类型为ceph
//192.168.4.11为MON节点的IP（不是MDS节点）
//admin是用户名,secret是密钥
//密钥可以在/etc/ceph/ceph.client.admin.keyring中找到

 ]#vim /etc/fstab
192.168.4.11:6789:/ /media ceph _netdev,name=admin,secret=AQBCvoldX/7FIxAAY1u25SPbw0xamQSQuQnnMw==  0 0
 ]# mount -a
secret(密码)------>cat  /etc/ceph/ceph.client.admin.keyring

3 案例3：创建对象存储服务器
3.1 问题

延续前面的实验，实现Ceph对象存储的功能。具体实现有以下功能：
安装部署Rados Gateway
启动RGW服务
设置RGW的前端服务与端口
客户端测试
3.2 步骤

步骤一：部署对象存储服务器

1）准备实验环境，要求如下：
IP地址:192.168.4.15
主机名:node5
配置yum源（包括rhel、ceph的源）
与Client主机同步时间
node1允许无密码远程node5
修改node1的/etc/hosts，并同步到所有node主机

2）部署RGW软件包
[root@node1 ~]# ceph-deploy install --rgw node5
或者登陆node5手动yum安装软件包ceph-radosgw.

3）新建网关实例
拷贝配置文件，启动一个rgw服务
[root@node1 ~]# cd /root/ceph-cluster
[root@node1 ~]# ceph-deploy rgw create node5
如果没有配置文件则可以通过admin命令重新发送配置和密钥（备选操作）
[root@node1 ceph-cluster]# ceph-deploy admin node4
//同步配置文件和key
登陆node5验证服务是否启动
[root@node5 ~]# ps aux |grep radosgw
ceph      4109  0.2  1.4 2289196 14972 ?       Ssl  22:53   0:00 /usr/bin/radosgw -f --cluster ceph --name client.rgw.node4 --setuser ceph --setgroup ceph
[root@node5 ~]# systemctl  status ceph-radosgw@\*




4）修改服务端口
登陆node5，RGW默认服务端口为7480，修改为8000或80更方便客户端记忆和使用
[root@node5 ~]#  vim  /etc/ceph/ceph.conf   加3行
[client.rgw.node5]
host = node5
rgw_frontends = "civetweb port=8000"
//node5为主机名
//civetweb是RGW内置的一个web服务
步骤二：客户端测试（扩展选做实验）

1）curl测试
[root@client ~]# curl  192.168.4.15:8000
<?xml version="1.0" encoding="UTF-8"?><ListAllMyBucketsResult xmlns="http://s3.amazonaws.com/doc/2006-03-01/"><Owner><ID>anonymous</ID><DisplayName></DisplayName></Owner><Buckets></Buckets></ListAllMyBucketsResult>
2）使用第三方软件访问
登陆node5（RGW）创建账户
[root@node5 ~]#  radosgw-admin user create \
--uid="testuser" --display-name="First User"
… …
"keys": [
        {
            "user": "testuser",
            "access_key": "5E42OEGB1M95Y49IBG7B",
            "secret_key": "i8YtM8cs7QDCK3rTRopb0TTPBFJVXdEryRbeLGK6"
        }
    ],
... ...
#
[root@node5 ~]# radosgw-admin user info --uid=testuser
//testuser为用户，key是账户访问密钥
3）客户端安装软件
[root@client ~]#  yum install s3cmd-2.0.1-1.el7.noarch.rpm
修改软件配置（注意，除了下面设置的内容，其他提示都默认回车）
[root@client ~]#  s3cmd --configure
Access Key: 5E42OEGB1M95Y49IBG7BSecret Key: i8YtM8cs7QDCK3rTRopb0TTPBFJVXdEryRbeLGK6
S3 Endpoint [s3.amazonaws.com]: 192.168.4.15:8000
[%(bucket)s.s3.amazonaws.com]: %(bucket)s.192.168.4.15:8000
Use HTTPS protocol [Yes]: No
Test access with supplied credentials? [Y/n] n
Save settings? [y/N] y
//注意，其他提示都默认回车
4）创建存储数据的bucket（类似于存储数据的目录）
[root@client ~]# s3cmd ls
[root@client ~]# s3cmd mb s3://my_bucket
Bucket 's3://my_bucket/' created
[root@client ~]# s3cmd ls
2018-05-09 08:14 s3://my_bucket
[root@client ~]# s3cmd put /var/log/messages s3://my_bucket/log/
[root@client ~]# s3cmd ls
2018-05-09 08:14 s3://my_bucket
[root@client ~]# s3cmd ls s3://my_bucket
DIR s3://my_bucket/log/
[root@client ~]# s3cmd ls s3://my_bucket/log/
2018-05-09 08:19 309034 s3://my_bucket/log/messages 
5）测试下载功能
[root@client ~]# s3cmd get s3://my_bucket/log/messages /tmp/
6）测试删除功能
[root@client ~]# s3cmd del s3://my_bucket/log/messages




 ##############################################################################


                   做项目:::::::::

Top
NSD Project1 DAY01

案例1：服务器硬件
案例2：部署LNMP动态网站
1 案例1：服务器硬件
1.1 问题

服务器硬件品牌有哪些，服务器硬件组成结构分析：
常见服务器品牌介绍
服务器硬件组成
配置服务器硬件RAID
Dell服务器iDRAC远程管理配置
1.2 方案

常见服务器品牌包括：IBM服务器、Dell服务器、HP服务器、浪潮服务器、华为服务器。
与普通电脑一样，服务器也是由主板、内存、CPU、磁盘、网卡、显卡、电源、主机箱等硬件设备组成。
服务器分为塔式服务器、机架式服务器、刀片服务器。
RAID是Redundant Arrays of Independent Drives（独立冗余磁盘阵列）的简称，RAID分为很多级别，常用级别有RAID0、RAID1、RAID5、RAID6、RAID10、RAID01。
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：常见服务器品牌

1）Dell服务器是目前IDC机房中普遍采用的服务器品牌。
Dell入门级塔式服务器PowerEdge T340，如图-1所示，该服务器的目标应用是文件/打印，协作/共享，邮件/讯息，备份/恢复，视频监控等。

图-1 PowerEdge T340服务器
产品配置如下：
4核和6核英特尔至强E-2100处理器
4个DIMM插槽(高达64GB的内存容量)
8个3.5英寸热插拔HDD硬盘
4个PCIe 3.0插槽
2个1GbE
单个或冗余的双495W电源或者单个350W有线电源
Dell高性能塔式服务器PowerEdge T640，如图-2所示。

图-2 PowerEdge T640服务器
产品配置如下：
双路英特尔至强CPU，每个处理器支持28个内核
24个DIMM内存插槽，最高支持192GB内存，仅支持ECC DDR4
电源750W、1100W、1600W、2000W、2400W
Dell入门级单路机架式服务器PowerEdge R330（1U=44.45mm=4.45cm），如图-3所示。

图-3 PowerEdge R330机架式服务器
产品配置如下：
1路CPU，英特尔至强、英特尔奔腾、英特尔酷睿CPU
4个DIMM，最高支持64GB内存
2.5或3.5寸硬盘，STATA或SAS接口
双电源
Dell机架式服务器PowerEdge R740（2u=88.9mm=8.89cm），如图-4所示。

图-4 PowerEdge R740服务器
产品配置如下：
双路CPU，每个CPU支持28个核心
24个DIMM内存插槽，最高192GB，ECC DDR4
双电源
2）IBM服务器
IBM机架式服务器X3250M6（1U），如图-5所示。

图-5 IBM X3250M6服务器
产品配置如下：
1路CPU，英特尔至强处理器
4个DIMM内存插槽，最大64G内存
4个3.5寸磁盘位，默认无硬盘，最大可配24TB
支持RAID 0，1，5
一个300W固定电源
3）HP服务器
HPE ProLiant DL380 Gen10 服务器（2U），如图-6所示。

图-6 HPE ProLiant DL380 Gen10 服务器
产品配置如下：
2路CPU，英特尔至强
24个DIMM插槽，支持最大3T DDR4内存
24个磁盘接口
iLO远程管理
4个网卡接口
步骤二：服务器硬件组成

1）CPU
英特尔：酷睿八代（i3,i5,i7,i9），酷睿九代(i3,i5,i7,i9)
至强E（标准版），至强W（高功耗版）
奔腾处理器
AMD：	家用版（锐龙、速龙）
服务器版本（皓龙、霄龙）
2) 内存
常见品牌：金士顿、三星
家用普通内存不具有数据校验功能
服务器配置带ECC数据校验功能的内存条
规格：DDR1、DDR2、DDR3、DDR4、DDR5
3）硬盘
常见品牌：三星、英特尔、希捷、西部数据
家用磁盘接口：SATA
服务器磁盘接口：SAS
SSD固态硬盘
大小：2.5寸、3.5寸
4）远程管理设备
Dell：	iDRAC
HP：	iLO
IBM：	Tivoli/ˈtɪvəli/
步骤三：配置服务器硬件RAID

1）RAID5
服务器开机后根据提示快速按Ctrl+R组合键即可进入RAID配置界面，如图-7所示。

图-7
进入RAID配置界面可以看到所有未配置的磁盘列表，主菜单包含：VD Mgmt、PD Mgmt、Ctrl Mgmt、Properties，如图-8所示。

图-8
Ctrl+N进入下一页菜单，Ctrl+P进入上一页菜单，通过F2可以进入配置菜单，如图-9所示。

图-9
正式配置RAID之前可以使用Clear Config清空所有配置，然后选择Create New VD创建新的RADID磁盘阵列，如图-10所示。

图-10
在RAID Level中选择RAID级别，如RAID5（最少需要三块磁盘），并在右侧Physical Disks中选择使用哪些物理磁盘组合RAID，如图-11所示。

图-11
点击OK确定后，可以在主菜单中看到刚刚创建的磁盘阵列，按F2选择Properties可以配置该磁盘阵列的高级属性，如图-12所示。

图-12
点击Advanced高级，如图-13所示。

图-13
在高级属性中开启磁盘缓存，默认未unchanged，需要设置为enable，并可以设置缓存策略：Write Through直写和Write Back回写，write through模式时数据同时被写入缓存和磁盘，安全，但是写入速度慢，write back模式时数据先写入缓存，再写入磁盘，写入速度快，但数据写入缓存时突发断电会导致数据丢失。配置菜单如图-14所示。

图-14
创建完RADID后还需要初始化磁盘，菜单如图-15所示。

图-15
2）RAID故障恢复
将损坏的磁盘拔掉，替换一块新的磁盘即可，注意需要将新磁盘插入损坏的磁盘相同接口。磁盘大小、品牌尽可能一致。恢复数据时界面会提示Rebuild，效果如图-16所示。

图-16
3）配置Hot Space磁盘
热备磁盘是提前准备一块备用的磁盘（当前并不使用），当RAID磁盘阵列出现损坏后，系统自动使用该热备磁盘，替代损坏的磁盘，从而不需要人工插拔磁盘即可自动修复。
创建新的RAID磁盘阵列时，不要使用完所有磁盘，留一块磁盘做热备磁盘，点击Advanced高级选项即可配置热备磁盘，如图-17所示。

图-17
勾选Configure Hot Space配置热备磁盘，如图-18所示。

图-18
在弹出的对话框中勾选需要的热备磁盘即可完成配置，如图-19所示。

图-19
4）其他级别的磁盘阵列
其他级别的磁盘阵列配置方式类似，可以根据自己的需要进行配置如RAID10，RAID6等，但是都需要磁盘阵列卡支持才可以配置。
步骤四：Dell服务器iDRAC远程管理配置

1）配置端口重定向
iDRAC（Integrated Dell Remote Access Controller），是戴尔服务器集成的远程控制卡。
iDRAC需要授权使用，有授权的情况下可以直接通过浏览器访问：http://服务器IP，远程管理服务器，没有授权的情况下可以通过端口重定向将服务器上的显示内容重定向到远程管理端的电脑上（一般是用自己的笔记本远程服务器），这种方式不需要授权。
开启服务器后根据提示快速按F2键进入BIOS界面，如图-20所示。

图-20
进入BIOS Settings后，选择Serial Communication菜单，如图-21所示。

图-21
将控制台重定向到com2，设置Serial Device=com1，Serial Device=com2，效果如图-22所示。

图-22
2）初始化清空iDRAC设置
进入iDRAC Setting界面选择Rest iDRAC configuration to defaults，如图-23所示。

图-23
3）配置iDRAC网络
进入iDRAC Setting界面选择network，如图-24所示。

图-24
选择网卡并配置IP地址，如图-25和图-26所示，网段需要根据实际情况自行配置。

图-25

图-26
开启IPMI智能平台管理接口（配置后可以通过命令行管理服务器），客户端安装ipmitool软件包，如图-27所示。

图-27
4）配置远程管理账户
进入iDRAC Setting界面选择User Configuration，如图-28所示。

图-28
配置账户名称root，并设置密码，如图-29所示。

图-29
5）远程管理端主机配置，安装ipmitool软件包
[root@centos7 ~]# yum -y install ipmitool
常用命令操作列表如下。
[root@centos7 ~]# ipmitool -I lanplus -U root -H 服务器IP  power status
#查看服务器电源状态
[root@centos7 ~]# ipmitool -I lanplus -U root -H 服务器IP  power on
#开启服务器电源
[root@centos7 ~]# ipmitool -I lanplus -U root -H 服务器IP  power off
#关闭服务器电源
[root@centos7 ~]# ipmitool -I lanplus -U root -H 服务器IP  power reset
#重启服务器电源
[root@centos7 ~]# ipmitool -I lanplus -U root -H 服务器IP  sol activate
#远程管理
2 案例2：部署LNMP动态网站
2.1 问题

部署LNMP动态网站，实现以下目标：
安装LNMP平台相关软件
配置Nginx实现动静分离
配置数据库，创建账户与密码
上线Wordpress代码
使用Wordpress后台管理界面，调整Wordpress版式
2.2 方案

实验拓扑如图-30所示，做具体实验前请先配置好环境。

图-30
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：安装部署LNMP软件

备注：mariadb（数据库客户端软件）、mariadb-server（数据库服务器软件）、mariadb-devel（其他客户端软件的依赖包）、php（解释器）、php-fpm（进程管理器服务）、php-mysql（PHP的数据库扩展包）。
1）安装软件包
[root@centos7 ~]# yum -y install gcc openssl-devel pcre-devel 
[root@centos7 ~]# useradd -s /sbin/nologin  nginx
[root@centos7 ~]# tar -xvf nginx-1.12.2.tar.gz
[root@centos7 ~]# cd nginx-1.12.2
[root@centos7 nginx-1.12.2]# ./configure   \
--user=nginx   --group=nginx \
--with-http_ssl_module   \
--with-http_stub_status_module
[root@centos7 nginx-1.12.2]# make && make install
[root@centos7 ~]# yum -y install   mariadb   mariadb-server   mariadb-devel
[root@centos7 ~]# yum -y install   php        php-mysql        php-fpm
2)启动服务(nginx、mariadb、php-fpm)
[root@centos7 ~]# /usr/local/nginx/sbin/nginx                 #启动Nginx服务
[root@centos7 ~]# echo "/usr/local/nginx/sbin/nginx" >> /etc/rc.local
[root@centos7 ~]# chmod +x /etc/rc.local
[root@centos7 ~]# ss -utnlp | grep :80                        #查看端口信息
[root@centos7 ~]# systemctl start   mariadb                   #启动mariadb服务器
[root@centos7 ~]# systemctl enable  mariadb               
    
[root@centos7 ~]# systemctl start  php-fpm                   #启动php-fpm服务
[root@centos7 ~]# systemctl enable php-fpm
附加知识：systemd！！！
源码安装的软件默认无法使用systemd管理，如果需要使用systemd管理源码安装的软件需要手动编写服务的service文件（编写是可以参考其他服务的模板文件）。以下是nginx服务最终编辑好的模板。
Service文件存储路径为/usr/lib/system/system/目录。
[root@centos7 ~]# vim /usr/lib/systemd/system/nginx.service
[Unit]
Description=The Nginx HTTP Server
#描述信息
After=network.target remote-fs.target nss-lookup.target
#指定启动nginx之前需要其他的其他服务，如network.target等
[Service]
Type=forking   //子进程   
#Type为服务的类型，仅启动一个主进程的服务为simple，需要启动若干子进程的服务为forking
ExecStart=/usr/local/nginx/sbin/nginx
#设置执行systemctl start nginx后需要启动的具体命令.
ExecReload=/usr/local/nginx/sbin/nginx -s reload
#设置执行systemctl reload nginx后需要执行的具体命令.
ExecStop=/bin/kill -s QUIT ${MAINPID}
#设置执行systemctl stop nginx后需要执行的具体命令.
[Install]
WantedBy=multi-user.target
3）修改Nginx配置文件，实现动静分离
修改配置文件，通过两个location实现动静分离，一个location匹配动态页面，一个loation匹配其他所有页面。
注意修改默认首页为index
.php!
[root@centos7 ~]# vim /usr/local/nginx/conf/nginx.conf 
...省略部分配置文件内容...
location / {
            root   html;
            index  index.php index.html index.htm;
        }
...省略部分配置文件内容...
location ~ \.php$ {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include        fastcgi.conf;
        }
...省略部分配置文件内容...
[root@centos7 ~]# /usr/local/nginx/sbin/nginx -s reload            #重新加载配置
4）配置数据库账户与权限
为网站提前创建一个数据库、添加账户并设置该账户有数据库访问权限。
[root@centos7 ~]# mysql
MariaDB [(none)]> create database wordpress character set utf8mb4;
MariaDB [(none)]> grant all on wordpress.* to wordpress@'localhost' identified by 'wordpress';
MariaDB [(none)]> grant all on wordpress.* to wordpress@'192.168.2.11' identified by 'wordpress';
MariaDB [(none)]> flush privileges;
MariaDB [(none)]> exit
提示：在mysql和mariadb中%代表匹配所有，这里是授权wordpress用户可以从任意主机连接数据库服务器，生产环境建议仅允许特定的若干主机访问数据库服务器。
步骤二：上线wordpress代码

1）上线PHP动态网站代码
[root@centos7 ~]# unzip wordpress.zip
[root@centos7 ~]# cd wordpress
[root@centos7 wordpress]# tar -xf wordpress-5.0.3-zh_CN.tar.gz
[root@centos7 wordpress]# cp -r  wordpress/*  /usr/local/nginx/html/
[root@centos7 wordpress]# chown -R apache.apache  /usr/local/nginx/html/
提示：动态网站运行过程中，php脚本需要对网站目录有读写权限，而php-fpm默认启动用户为apache。
2)初始化网站配置（使用客户端访问web服务器IP）
[root@client ~]# firefox http://192.168.2.11/
第一次访问服务器会自动进入config配置页面，效果如图-31所示。

图-31
开发人员在写代码的时候并不知道未来数据库服务器的IP、端口、数据库名称、账户等信息，该配置页面主要的作用就是动态配置数据库信息，根据前面步骤配置的数据库信息填空即可，效果如图-32所示。

图-32
点击提交即可完成数据库的初始化工作，php动态脚本会自动在wordpress数据库中创建若干数据表，后期网站的数据都会写入对并的数据表中。效果如图-33所示。

图-33
第一次使用Wordpress需要给你的网站设置基本信息，如网站标题、网站管理员账户与密码等信息，配置完成后点击安装wordpress即可，如图-34所示。

图-34
步骤三：网站后台管理

1）访问192.168.2.11服务器，进入并熟悉后台管理界面
通常情况下，开发人员会开发一个后台管理界面，当代码上线后，普通用户就可以管理和配置网站页面（需要使用网站的超级管理员身份才可以进入后台界面）。
[root@client ~]# firefox http://192.168.2.11                
访问首页后点击如图-35所示的登陆菜单，输入账户和密码进入后台管理界面。

图-35
或者直接在地址栏中输入后台管理界面的具体URL。
[root@client ~]# firefox  http://192.168.2.11/wp-login.php
输入管理员用户名和密码，效果如图-36所示。登陆后台管理界面效果如图-37所示。

图-36

图-37
2）修改网站主题
Wordpress主题会影响网站的整体外观，我们可以使用默认自带的若干主题。
后台修改网站主题的菜单为<外观>--<主题>，使用默认主题，点击启用即可，如图-38所示。

图-38
如果需要更多更新的主题，则可以去官网下载更多新的主题，默认下载的主题格式为zip压缩包。
官方网站主题链接：（https://cn.wordpress.org/themes/browse/popular/）。
将主题下载到服务器本地后，可以在后台管理界面添加主题，<外观>--<主题>--<添加>--<上传主题>--<浏览>--<现在安装>，如图-39所示。

图-39
部署新主题的另一种方法是，直接将下载的zip主题包拷贝到wordpress代码的特定目录，如/usr/local/nginx/html/wp-content/themes/目录，然后使用unzip解压主题即可，效果如图-40所示。

图-40
3）修改网站小工具
小工具是首页中的各种常用功能菜单，可以添加和删除。
首先可以删除一些不需要的小工具，如最近文章、最近评论等，如图-41所示。

图-41
Right、Legt、Header代表的是小工具的位置，使用鼠标拖动小工具可以移动位置，如图-42所示。

图-42
可以通过小工具为网站添加导航功能，使用鼠标将导航菜单拖动到合适的位置即可，默认没有导航菜单，需要自定义创建，如图-43所示。

图-43
创建导航菜单后，可以继续创建页面，并将页面添加到导航菜单中。<页面>--<新建页面>即可添加新的页面，如图-44和图-45所示。新的页面内容可以是段落、图像、列表、引语等（每个人根据自己的需要自由发挥）。

图-44

图-45
新的页面添加完成后，可以将其添加到菜单中使用，如图-46所示。访问网站首页即可查看导航菜单的效果，如图-47所示。

图-46

图-47


4）扩展其他问题
其他有关wordpress的使用方法与技巧，可以参考官方网站的文档资料，文档链接：https://codex.wordpress.org/zh-cn:Main_Page。
附加知识（常见面试题）




1）描述raid 0、1、5的特点和优点?
答：Raid0条带卷，可以高效读写，硬盘空间利用率100%，raid1是复制卷可以实现数据的高可靠读写，硬盘空间利率50%，raid5兼得以上两种优点，硬盘空间利用率N-1，仅可用损坏一块硬盘。
2）将目录/opt/bjca3打包备份排除/opt/bjca3/logs目录，传递到远程主机192.168.1.8的/backup目录下？
答：使用—exclude选项在打包时可用排除特定的目录，但是要注意，使用tar 的--exclude 排除打包的时候，不能加“/”，否则还是会把logs目录以及其下的文件打包进去。
错误写法：
tar -czvf bjca3.tar.gz --exclude=/opt/bjca3/logs/ /opt/bjca3
正确写法：
tar -czvf bjca3.tar.gz --exclude=/opt/bjca3/logs /opt/bjca3
3) 如何远程查看Linux服务192.168.1.7运行了多少时间？
答：ssh root@192.168.1.7 uptime
4）虚拟机常用有几种网络模式？请简述其工作原理或你个人的理解？
答：有桥接模式、隔离模式、NAT模式、路由模式，如图-48所示。

图-48
桥接模式：Guest与Host连接到同一个交换机上；通过桥接物理网卡，相当于直连到Host所在网络。
隔离模式：允许Guest访问同一虚拟交换机上的其他Guest；但是不能访问Host所在的外部网络。
NAT模式（默认）：将Guest虚拟机的默认网关指向Host物理机的virtbr0接口的IP地址；Guest共享真机的网络连接，以地址转换的方式访问外网。
路由模式：由Host物理机充当路由器，开启转发；需要额外设置外网与Guest虚拟机之间互访的路由条目，Guest以路由转发的方式访问外网（需要在真机配置iptables规则）。
5）在11月份内，每天的早上6点到12点中，每隔2小时执行一次 /usr/bin/httpd.sh，怎么实现？
答：0 6-12/2 * 11 * /usr/bin/httpd.sh
6）如何查看当前系统是否有监听6666端口？
答：netstat -untlp | grep 6666或者ss -nutlp | grep 6666
7) 如何显示CPU占用率最高的进程？
top，输入大写的P



1ppt.com----->下载ppt模板

yum -y install google-noto-sans-simplified-chinese-fonts.noarch     //虚拟机里如果没有中文解释(utf8)安装次软件即可

#########################################################################################################


Top
NSD Project1 DAY02

案例1：网站架构演变
案例2：LNP+Mariadb数据库分离
案例3：Web服务器集群
1 案例1：网站架构演变
1.1 问题

学习从单机架构到集群架构的演变之路：
单机版LNMP
独立数据库服务器
Web服务器集群与Session保持
动静分离、数据库集群
各种缓存服务器
业务模型
1.2 步骤

此案例主要是学习网站架构演变的过程，以拓扑图和理论为主，具体实现还需要结合具体的软件。
步骤一：单机版LNMP

单机版网站，拓扑如图-1所示。

图-1 单机版网站服务器
用户量少时使用，简单、成本低、存在单点故障。
步骤二：独立数据库服务器

独立数据库服务器是将网站静态文件、代码文件等资料与数据库分离的架构，当用户量增加时单机的处理能力有限，PHP或JAVA代码的执行需要消耗大量CPU资源，数据库的增删改查需要调用大量的内存资源，将两者分离可以减轻服务器的压力，其拓扑结构如图-2所示。

图-2 web服务器与数据库分离
Web服务器和数据库服务器的压力都可以得到有效改善，访问量有所增加。但是服务器依然存在单点故障问题。
步骤三：Web服务器集群与Session保持

我们可以通过Nginx、Haproxy代理服务器实现Web负载均衡集群，也可以使用LVS调度器实现Web负载均衡集群。部署完Web集群后还需要考虑如何进行Session会话保持，方法很多，如：根据源IP保持，代理服务器重写Cookie信息，共享文件系统保存session，使用数据库共享session等等。
该架构拓扑如图-3所示。

图-3
但是如果只有一台调度器依然会导致单点故障的问题，因此还需要使用Keepalived或Heartbeat之类的软件进行高可用配置，如图-4所示。

图-4
对于网站内容而言可以分离为动态页面和静态页面，静态页面就需要数据文件，动态页面则需要CPU解析代码，需要消耗大量的CPU资源，因此可以将静态和动态分离为两组服务器，动态页面有脚本代码组成，是一种基于网页的应用程序，因此这一组服务器也称为应用服务器，其架构如图-5所示。

图-5
步骤四：动静分离、数据库集群

随着服务器的增加，虽然性能与并发量得到了明显的提升，但是数据的一致性、管理的便利性成为了新的问题，因此就需要增加统一的存储服务器，实现数据的同步一致，可以使用NFS，GlusterFS、Ceph等软件实现该功能，其架构如图-6所示。

图-6
此时所有应用服务器都连接一台数据库服务器进行读写操作，而且后期随着数据库中的数据不断增加，会导致数据库成为整个网站的瓶颈！这就需要我们对数据进行分库分表，创建数据库主从或者数据库集群，实现读写分离，其拓扑如图-7所示。

图-7
步骤五：缓存服务器与业务模型

对于静态数据我们可以通过varnish、squid或者nginx进行缓存，将数据缓存到距离用户更近的位置，构建CDN（内容分发网络）架构。
对于传统的SQL数据库而言，我们也可以通过增加NoSQL数据库，实现数据缓存的功能，提升数据库的访问速度。
备注：数据库相关知识在第三阶段课程有详细介绍，第二阶段项目暂时不做数据库优化。
最后，基于前面的架构，我们还可以将网站按照公司的业务进行分离，每个业务都可以是一个独立的集群，如图-8所示。

图-8
2 案例2：LNP+Mariadb数据库分离
2.1 问题

部署LNP+Mariadb实现数据库与Web服务器分离，实现以下目标：
将旧的数据库备份，迁移到新的服务器
修改配置调用新的数据库服务器
2.2 方案

实验拓扑如图-9所示，做具体实验前请先配置好环境。

图-9
主机配置如表-1所示。
表-1

2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署数据库服务器

1）准备一台独立的服务器，安装数据库软件包
[root@database ~]# yum -y install mariadb mariadb-server mariadb-devel
[root@database ~]# systemctl start mariadb
[root@database ~]# systemctl enable mariadb
2)将之前单机版LNMP网站中的数据库迁移到新的数据库服务器。
登陆192.168.2.11主机，备份数据库并拷贝给新的服务器，关闭旧的数据库服务。
[root@centos7 ~]# mysqldump wordpress > wordpress.bak
[root@centos7 ~]# scp wordpress.bak 192.168.2.21:/root/
[root@centos7 ~]# systemctl stop mariadb
[root@centos7 ~]# systemctl disable mariadb
登陆192.168.2.21主机，使用备份文件还原数据库。
创建空数据库：
[root@database ~]# mysql
MariaDB [(none)]> create database wordpress character set utf8mb4;
MariaDB [(none)]> exit
使用备份文件还原数据：
[root@database ~]# mysql wordpress < wordpress.bak
重新创建账户并授权访问：
[root@database ~]# mysql
MariaDB [(none)]> grant all on wordpress.* to wordpress@'%' identified by 'wordpress';
MariaDB [(none)]> flush privileges;
MariaDB [(none)]> exit
3）修改wordpress网站配置文件，调用新的数据库服务器。
Wordpress在第一次初始化操作时会自动生产配置文件：wp-config.php，登陆192.168.2.11修改该文件即可调用新的数据库服务。
[root@centos7 ~]# vim /usr/local/nginx/html/wp-config.php
修改前内容如下：
define('DB_HOST', '192.168.2.11');
修改后内容如下：
define('DB_HOST', '192.168.2.21');
步骤二：客户端测试

1）客户端使用浏览器访问wordpress网站。
[root@client ~]# firefox http://192.168.2.11
3 案例3：Web服务器集群
3.1 问题

使用HAProxy部署Web服务器集群，实现以下目标：
部署三台Web服务器
迁移网站数据，使用NFS实现数据共享
部署HAProxy代理服务器实现负载均衡
部署DNS域名解析服务器
3.2 方案

实验拓扑如图-10所示，做具体实验前请先配置好环境。

图-10
备注：实际操作中DNS服务代理服务器部署在同一台主机上（节约虚拟机资源）。
主机配置如表-2所示。
表-2

3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署web2和web3服务器

1）安装LNP软件包
[root@web2 ~]# yum -y install gcc pcre-devel openssl-devel 
[root@web2 lnmp_soft]# tar -xf nginx-1.12.2.tar.gz
[root@web2 lnmp_soft]# cd nginx-1.12.2/
[root@web2 nginx-1.12.2]# ./configure \
--with-http_ssl_module \
--with-http_stub_status_module
[root@web2 nginx-1.12.2]# make && make instal
[root@web2 ~]# yum -y install php php-fpm php-mysql mariadb-devel
[root@web3 ~]# yum -y install gcc pcre-devel openssl-devel 
[root@web3 lnmp_soft]# tar -xf nginx-1.12.2.tar.gz
[root@web3 lnmp_soft]# cd nginx-1.12.2/
[root@web3 nginx-1.12.2]# ./configure \
--with-http_ssl_module \
--with-http_stub_status_module
[root@web3 nginx-1.12.2]# make && make instal
[root@web3 ~]# yum -y install php php-fpm php-mysql mariadb-devel
2）修改nginx配置实现动静分离（web2和web3操作）
web2修改默认首页index.php，配置两个location实现动静分离。
[root@web2 ~]# vim /usr/local/nginx/conf/nginx.conf
location / {
            root   html;
            index  index.php index.html index.htm;
        }
location ~ \.php$ {
            root            html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include         fastcgi.conf;
        }
web3修改默认首页index.php，配置两个location实现动静分离。
[root@web3 ~]# vim /usr/local/nginx/conf/nginx.conf
location / {
            root   html;
            index  index.php index.html index.htm;
        }
location ~ \.php$ {
            root            html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include         fastcgi.conf;
        }
3）启动相关服务
[root@web2 ~]# echo "/usr/local/nginx/sbin/nginx" >> /etc/rc.local
[root@web2 ~]# chmod +x /etc/rc.local
[root@web2 ~]# /usr/local/nginx/sbin/nginx
[root@web2 ~]# systemctl start  php-fpm                   #启动php-fpm服务
[root@web2 ~]# systemctl enable php-fpm
[root@web3 ~]# echo "/usr/local/nginx/sbin/nginx" >> /etc/rc.local
[root@web3 ~]# chmod +x /etc/rc.local
[root@web3 ~]# /usr/local/nginx/sbin/nginx
[root@web3 ~]# systemctl start  php-fpm                   #启动php-fpm服务
[root@web3 ~]# systemctl enable php-fpm
附加知识：systemd！！！
源码安装的软件默认无法使用systemd管理，如果需要使用systemd管理源码安装的软件需要手动编写服务的service文件（编写是可以参考其他服务的模板文件）。以下是nginx服务最终编辑好的模板。
Service文件存储路径为/usr/lib/system/system/目录。
[root@centos7 ~]# vim /usr/lib/systemd/system/nginx.service
[Unit]
Description=The Nginx HTTP Server
#描述信息
After=network.target remote-fs.target nss-lookup.target
#指定启动nginx之前需要其他的其他服务，如network.target等
[Service]
Type=forking
#Type为服务的类型，仅启动一个主进程的服务为simple，需要启动若干子进程的服务为forking
ExecStart=/usr/local/nginx/sbin/nginx
#设置执行systemctl start nginx后需要启动的具体命令.
ExecReload=/usr/local/nginx/sbin/nginx -s reload
#设置执行systemctl reload nginx后需要执行的具体命令.
ExecStop=/bin/kill -s QUIT ${MAINPID}
#设置执行systemctl stop nginx后需要执行的具体命令.
[Install]
WantedBy=multi-user.target
步骤二：部署NFS，将网站数据迁移至NFS共享服务器

1）部署NFS共享服务器
[root@nfs ~]# yum install nfs-utils
[root@nfs ~]# mkdir /web_share
[root@nfs ~]# vim /etc/exports
/web_share  192.168.2.0/24(rw,no_root_squash)
[root@nfs ~]# systemctl restart rpcbind
[root@nfs ~]# systemctl eanble rpcbind
NFS使用的是随机端口，每次启动NFS都需要将自己的随机端口注册到rpcbind服务，这样客户端访问NFS时先到rpcbind查询端口信息，得到端口信息后再访问NFS服务。
[root@nfs ~]# systemctl restart nfs
[root@nfs ~]# systemctl enable nfs
2）迁移旧的网站数据到NFS共享服务器
将web1（192.168.2.11）上的wordpress代码拷贝到NFS共享。
[root@web1 ~]# cd /usr/local/nginx/
[root@web1 nginx]# tar -czpf html.tar.gz html/
[root@web1 nginx]# scp html.tar.gz 192.168.2.31:/web_share/
登陆nfs服务器，将压缩包解压
[root@nfs ~]# cd /web_share/
[root@nfs web_share]# tar -xf html.tar.gz
3)所有web服务器访问挂载NFS共享数据。
[root@web1 ~]# rm -rf /usr/local/nginx/html/*
[root@web1 ~]# yum -y install nfs-utils
[root@web1 ~]# echo "192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0" >> /etc/fstab
[root@web1 ~]# mount -a
[root@web2 ~]# yum -y install nfs-utils
[root@web2 ~]# echo "192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0" >> /etc/fstab
[root@web2 ~]# mount -a
[root@web3 ~]# yum -y install nfs-utils
[root@web3 ~]# echo "192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0" >> /etc/fstab
[root@web3 ~]# mount -a
步骤三：部署HAProxy代理服务器

1）部署HAProxy
安装软件，手动修改配置文件，添加如下内容。
[root@proxy ~]# yum -y install haproxy 
[root@proxy ~]# vim /etc/haproxy/haproxy.cfg
listen wordpress *:80
  balance roundrobin
  server web1 192.168.2.11:80 check inter 2000 rise 2 fall 3
  server web2 192.168.2.12:80 check inter 2000 rise 2 fall 3
  server web3 192.168.2.13:80 check inter 2000 rise 2 fall 3
[root@proxy ~]# systemctl start haproxy
[root@proxy ~]# systemctl enable haproxy
步骤三：部署DNS域名服务器

1）安装DNS相关软件（192.168.4.5操作）。
 [root@proxy ~]# yum -y  install bind bind-chroot
2）修改主配置文件，添加zone。
[root@proxy ~]# vim /etc/named.conf
options {
        listen-on port 53 { any; };           #服务监听的地址与端口
        directory       "/var/named";         #数据文件路径
        allow-query     { any; };             #允许任何主机访问DNS服务
... ...
};
zone "lab.com" IN {                        #定义正向区域
        type master;
        file "lab.com.zone";
};
#include "/etc/named.rfc1912.zones";        #注释掉改行
#include "/etc/named.root.key";              #注释掉改行
[root@proxy ~]# named-checkconf /etc/named.conf            #检查语法
3）修改正向解析记录文件。
注意：保留文件权限。
[root@proxy named]# cp -p /var/named/named.localhost /var/named/lab.com.zone
[root@proxy named]# vim /var/named/lab.zone
$TTL 1D
@       IN SOA  @ rname.invalid. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
lab.com.       NS     dns
dns     A       192.168.4.5
www     A       192.168.2.11
4）启动服务
[root@proxy named]# systemctl start named
[root@proxy named]# systemctl enable named
5）客户端修改DNS解析文件
提示：做完实验修改回原始内容。
[root@room9pc01 data]# cat /etc/resolv.conf
# Generated by NetworkManager
search tedu.cn
nameserver 192.168.4.5
nameserver 172.40.1.10
nameserver 192.168.0.220
步骤四：修改wordpress配置文件

1）修改wp-config.php
在define('DB_NAME', 'wordpress')这行前面添加如下两行内容：
[root@web3 html]# vim /usr/local/nginx/html/wp-config.php
define('WP_SITEURL', 'http://www.lab.com');
define('WP_HOME', 'http://www.lab.com');

如果不添加这两行配置，浏览器访问网站某个子页面后，URL会固定到某一台后端服务器不轮询。
附加知识（常见面试题）

1) 什么是灰度发布：
答：灰度发布（又名金丝雀发布）是指在黑与白之间，能够平滑过渡的一种发布方式。
让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。灰度期：灰度发布开始到结束期间的这一段时间，称为灰度期。
2）DNS服务器有哪些种，其使用的端口为多少？
答：有 根DNS、一级DNS、二级DNS、三级DNS、缓存DNS
主DNS服务器、从DNS服务器
端口：53
3）从日志/opt/bjca3/logs/ca_access.log中截取14点到16点的日志，将截取的日志导入到/tmp/ca_access.txt中，日志格式如下：
答：awk '$4>"13:00:00"&&$4<="16:59:00"' ca_access.log
4）监控检查，使用ping命令编写脚本来查询一组IP地址同时检测他们是否处于活跃状态。要求（range：192.168.1.200-192.168.1.220，一个IP发送4个ping包，ping的过程不能输出信息到终端）？
答：
#!/bin/bash
for i in {200..220}
do
ping -c 4  -i 0.2  -W 1  192.168.1.$i &>/dev/null
if  [  $? –eq 0 ];then
    echo  "192.168.1.$i is up"
else
    echo  "192.168.1.$i is down"
fi
done
5）假设nginx的访问日志格式如下，统计访问页面前10位的IP数？
答：awk '{IP[$1]++} END{for(i in IP){print i,IP[i]}}' access.log |sort -n |tail -10
6) 请列举出10个以上的你所知晓的SQL语句？
参考答案：
insert  select   delete  update  create  show   drop   grant    revoke   load data   create view
7）如何切换到某个数据库，并在上面工作？
答：use 库名;
8）列出数据库内的所有表？
答：show tables;
9）如何删除表、删除数据库？
答：drop table 表名;drop database 库名;
10）如何列出表’xrt’内name域值为’tecmint’，web_address域值为’tecmint.com’的所有数据？
答：
select  *  from  xrt  where  name=”tecmint” and  web_address=”tecmint.com”;



###############################################################################################################


Top
NSD Project1 DAY03

案例1：Keepalived高可用
案例2：部署Ceph分布式存储
1 案例1：Keepalived高可用
1.1 问题

部署两台代理服务器，实现如下效果：
利用keepalived实现两台代理服务器的高可用
配置VIP为192.168.4.80
修改对应的域名解析记录
1.2 方案

实验拓扑如图-1所示，做具体实验前请先配置好环境。

图-1
备注：实际操作中DNS服务代理服务器部署在同一台主机上（节约虚拟机资源）。
主机配置如表-1所示。
表-1

1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置第二台代理服务器

1）部署HAProxy
安装软件，手动修改配置文件，添加如下内容。
[root@proxy2 ~]# yum -y install haproxy 
[root@proxy2 ~]# vim /etc/haproxy/haproxy.cfg
listen wordpress *:80
  balance roundrobin
  server web1 192.168.2.11:80 check inter 2000 rise 2 fall 3
  server web2 192.168.2.12:80 check inter 2000 rise 2 fall 3
  server web3 192.168.2.13:80 check inter 2000 rise 2 fall 3
[root@proxy2 ~]# systemctl start haproxy
[root@proxy2 ~]# systemctl enable haproxy
步骤二：为两台代理服务器配置keepalived

1）配置第一台代理服务器proxy（192.168.4.5）。
[root@proxy ~]# yum install -y keepalived
[root@proxy ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  router_id  proxy1                        //设置路由ID号
  vrrp_iptables                               //不添加任何防火墙规则
}
vrrp_instance VI_1 {
  state MASTER                         //主服务器为MASTER（备服务器需要修改为BACKUP）
  interface eth0                    //定义网络接口
  virtual_router_id 51                
  priority 100                     //服务器优先级,优先级高优先获取VIP（实验需要修改）
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                       //主备服务器密码必须一致
  }
  virtual_ipaddress {                   //谁是主服务器谁获得该VIP（实验需要修改）
192.168.4.80 
}    
}
[root@proxy ~]# systemctl start keepalived
！！！重要！！！
在全局配置global_defs{}中手动添加vrrp_iptables，即可解决防火墙的问题。
2）配置第二台代理服务器proxy（192.168.4.6）。
[root@proxy2 ~]# yum install -y keepalived
[root@proxy2 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  router_id  proxy2                        //设置路由ID号
vrrp_iptables                               //不添加任何防火墙规则
}
vrrp_instance VI_1 {
  state BACKUP                         //主服务器为MASTER（备服务器需要修改为BACKUP）
  interface eth0                    //定义网络接口
  virtual_router_id 51                
  priority 50                         //服务器优先级,优先级高优先获取VIP
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                       //主备服务器密码必须一致
  }
  virtual_ipaddress {                   //谁是主服务器谁获得该VIP
192.168.4.80 
}    
}
[root@proxy2 ~]# systemctl start keepalived
！！！重要！！！
在全局配置global_defs{}中手动添加vrrp_iptables，即可解决防火墙的问题。
步骤三：修改DNS服务器

1）修改网站域名对应的解析记录，解析到新的VIP地址。
192.168.4.5为DNS服务器。
[root@proxy ~]# vim /var/named/lab.com.zone
$TTL 1D
@       IN SOA  @ rname.invalid. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
@       NS      dns.lab.com.
dns     A       192.168.4.5
www     A       192.168.4.80
2）重启DNS服务
[root@proxy ~]# systemctl restart named
2 案例2：部署Ceph分布式存储
2.1 问题

部署Ceph分布式存储，实现如下效果：
使用三台服务器部署Ceph分布式存储
实现Ceph文件系统共享
将网站数据从NFS迁移到Ceph存储
2.2 方案

实验拓扑如图-2所示，做具体实验前请先配置好环境。

图-2
备注：实际操作中DNS服务代理服务器部署在同一台主机上（节约虚拟机资源）。
主机配置如表-2所示。
表-2

2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：准备实验环境

1）物理机为所有节点配置yum源服务器。
提示：ceph10.iso在/linux-soft/02目录。
[root@room9pc01 ~]# mkdir  /var/ftp/ceph
[root@room9pc01 ~]# mount ceph10.iso /var/ftp/ceph/
2）在node1配置SSH密钥，让node1可用无密码连接node1,node2,node3
[root@node1 ~]# ssh-keygen  -f /root/.ssh/id_rsa  -N  ''
[root@node1 ~]# for i in   41  42  43
do
ssh-copy-id  192.168.2.$i
done
3)修改/etc/hosts域名解析记录（不要删除原有的数据），同步给所有ceph节点。
[root@node1 ~]# vim /etc/hosts
192.168.2.41    node1
192.168.2.42     node2
192.168.2.43    node3
[root@node1 ~]# for i in 41 42 43
do
     scp /etc/hosts 192.168.2.$i:/etc
done
4）为所有ceph节点配置yum源，并将配置同步给所有节点
[root@node1 ~]# cat /etc/yum.repos.d/ceph.repo
[mon]
name=mon
baseurl=ftp://192.168.2.254/ceph/MON
gpgcheck=0
[osd]
name=osd
baseurl=ftp://192.168.2.254/ceph/OSD
gpgcheck=0
[tools]
name=tools
baseurl=ftp://192.168.2.254/ceph/Tools
gpgcheck=0
[root@node1 ~]# yum repolist                #验证YUM源软件数量
源标识            源名称                    状态
Dvd                redhat                    9,911
Mon                mon                        41
Osd                osd                        28
Tools            tools                    33
repolist: 10,013
[root@node1 ~]# for i in 41 42 43
do
     scp /etc/yum.repos.d/ceph.repo 192.168.2.$i:/etc/yum.repos.d/
done
5）所有节点主机与真实主机的NTP服务器同步时间。
提示：默认真实物理机已经配置为NTP服务器。
[root@node1 ~]# vim /etc/chrony.conf
… …
server 192.168.2.254   iburst
[root@node1 ~]# for i in 41  42  43
do
     scp /etc/chrony.conf 192.168.2.$i:/etc/
     ssh 192.168.2.$i "systemctl restart chronyd"
done
6）使用virt-manager为三台ceph虚拟机添加磁盘。
每台虚拟机添加3块20G的磁盘。
步骤二：部署ceph集群

1）给node1主机安装ceph-deploy，创建工作目录，初始化配置文件。
[root@node1 ~]# yum -y install ceph-deploy
[root@node1 ~]# mkdir ceph-cluster
[root@node1 ~]# cd ceph-cluster
[root@node1 ceph-cluster]# ceph-deploy new node1 node2 node3
2）给所有ceph节点安装ceph相关软件包
[root@node1 ceph-cluster]# for i in node1 node2 node3
do
     ssh $i "yum -y install ceph-mon ceph-osd ceph-mds"
done
[root@node1 ceph-cluster]# ceph-deploy mon create-initial
[root@node1 ceph-cluster]# ceph -s                    #查看结果
    cluster 9f3e04b8-7dbb-43da-abe6-b9e3f5e46d2e
     health HEALTH_ERR
     monmap e2: 3 mons at
 {node1=192.168.2.41:6789/0,node2=192.168.2.42:6789/0,node3=192.168.2.43:6789/0}
     
osdmap e45: 0 osds: 0 up, 0 in
3）准备磁盘分区，创建journal盘，并永久修改设备权限。
[root@node1 ceph-cluster]# for i in node1 node2 node3
do
     ssh $i "parted /dev/vdb mklabel gpt"
     ssh $i "parted /dev/vdb mkpart primary 1 50%"
     ssh $i "parted /dev/vdb mkpart primary 50% 100%"
 done
提示：下面的步骤在所有主机都需要操作（node1，node2，node3）
#临时修改权限：
[root@node1 ceph-cluster]# chown  ceph.ceph  /dev/vdb1
[root@node1 ceph-cluster]# chown  ceph.ceph  /dev/vdb2
#永久修改权限：
[root@node1 ceph-cluster]# vim /etc/udev/rules.d/70-vdb.rules
ENV{DEVNAME}=="/dev/vdb1",OWNER="ceph",GROUP="ceph"
ENV{DEVNAME}=="/dev/vdb2",OWNER="ceph",GROUP="ceph"
4）使用ceph-deploy工具初始化数据磁盘（仅node1操作）。
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node1:vdc   node1:vdd    
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node2:vdc   node2:vdd
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node3:vdc   node3:vdd  
5）初始化OSD集群。
[root@node1 ceph-cluster]# ceph-deploy osd create \
 node1:vdc:/dev/vdb1 node1:vdd:/dev/vdb2  
//创建osd存储设备，vdc为集群提供存储空间，vdb1提供JOURNAL缓存，
//一个存储设备对应一个缓存设备，缓存需要SSD，不需要很大
[root@node1 ceph-cluster]# ceph-deploy osd create \
 node2:vdc:/dev/vdb1 node2:vdd:/dev/vdb2
[root@node1 ceph-cluster]# ceph-deploy osd create \
 node3:vdc:/dev/vdb1 node3:vdd:/dev/vdb2 
[root@node1 ceph-cluster]# ceph -s                 #查看集群状态
cluster 9f3e04b8-7dbb-43da-abe6-b9e3f5e46d2e
health HEALTH_OK
     monmap e2: 3 mons at {node1=192.168.4.11:6789/0,node2=192.168.4.12:6789/0,node3=192.168.4.13:6789/0}
            election epoch 6, quorum 0,1,2 node1,node2,node3
     osdmap e45: 6 osds: 6 up, 6 in
            flags sortbitwise
      pgmap v25712: 64 pgs, 1 pools, 86465 kB data, 2612 objects
            508 MB used, 119 GB / 119 GB avail
                  64 active+clean
步骤三：部署ceph文件系统

1）启动mds服务
[root@node1 ceph-cluster]# ceph-deploy mds create node3
2）创建存储池（文件系统由inode和block组成）
[root@node1 ceph-cluster]# ceph osd pool create cephfs_data 128
[root@node1 ceph-cluster]# ceph osd pool create cephfs_metadata 128
[root@node1 ceph-cluster]# ceph osd lspools
0 rbd,1 cephfs_data,2 cephfs_metadata
3）创建文件系统
[root@node1 ceph-cluster]# ceph fs new myfs1 cephfs_metadata cephfs_data
[root@node1 ceph-cluster]# ceph fs ls
name: myfs1, metadata pool: cephfs_metadata, data pools: [cephfs_data ]
步骤四：迁移网站数据到ceph集群

1）卸载web1，web2，web3的NFS共享。
暂停服务防止有人实时读写文件。
[root@web1 ~]# /usr/local/nginx/sbin/nginx -s stop
[root@web2 ~]# /usr/local/nginx/sbin/nginx -s stop
[root@web3 ~]# /usr/local/nginx/sbin/nginx -s stop
[root@web1 ~]# umount /usr/local/nginx/html
[root@web2 ~]# umount /usr/local/nginx/html
[root@web3 ~]# umount /usr/local/nginx/html
[root@web1 ~]# vim /etc/fstab
#192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0
[root@web2 ~]# vim /etc/fstab
#192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0
[root@web3 ~]# vim /etc/fstab
#192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0
2）web服务器永久挂载Ceph文件系统（web1、web2、web3都需要操作）。
在任意ceph节点，如node1查看ceph账户与密码。
[root@node1 ~]# cat /etc/ceph/ceph.client.admin.keyring 
[client.admin]
    key = AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==
/etc/rc.local是开机启动脚本，任何命令放在该文件中都是开机自启。
[root@web1 ~]#  mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
-o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==
[root@web1 ~]# echo 'mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
-o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==' >> /etc/rc.local 
[root@web1 ~]# chmod +x /etc/rc.local
[root@web2 ~]#  mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
-o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==
[root@web2 ~]# echo 'mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
-o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==' >> /etc/rc.local 
[root@web2 ~]# chmod +x /etc/rc.local
[root@web3 ~]#  mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
-o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==
[root@web3 ~]# echo 'mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
-o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==' >> /etc/rc.local 
[root@web3 ~]# chmod +x /etc/rc.local
另一种解决方案，还可以通过fstab实现永久挂载。
提示：如果希望使用fstab实现永久挂载，客户端需要额外安装libcephfs1软件包。
[root@web1 ~]# yum -y install libcephfs1
[root@web1 ~]# vim /etc/fstab
… …
192.168.4.11:/ /usr/local/nginx/html/    ceph   defaults,_netdev,name=admin,secret=AQCVcu9cWXkgKhAAWSa7qCFnFVbNCTB2DwGIOA== 0 0
3)迁移NFS服务器中的数据到Ceph存储
登陆NFS服务器备份数据，将备份数据拷贝给web1或web2或web3，tar备份数据时注意使用-p选项保留文件权限。
[root@nfs ~]# cd /web_share/html/
[root@nfs html]# tar -czpf /root/html.tar.gz ./*
[root@nfs html]# scp /root/html.tar.gz 192.168.2.11:/usr/local/nginx/html/
登陆web1将数据恢复到Ceph共享目录
[root@web1 html]# tar -xf html.tar.gz
[root@web1 html]# rm -rf html.tar.gz
4）恢复web服务
[root@web1 ~]# /usr/local/nginx/sbin/nginx
[root@web2 ~]# /usr/local/nginx/sbin/nginx
[root@web3 ~]# /usr/local/nginx/sbin/nginx
附加知识（常见面试题）

1) 如何使用awk查看TCP连接状态？
答：ss -ant |awk '{print $1}'
netstat -ant |awk '{print $6}'
2) 有个txt文件内容如下：
http://a.domain.com/l.html
http://b.domain.com/l.html
http://c.domain.com/l.html
http://a.domain.com/2.html
http://b.domain.com/2.html
http://a.domain.com/3.html
要求：得到主机名（和域名），并统计每个网址出现的次数，并排序。可以 shell 或 C
得到的结果应该是：
答：
#！/bin/bash
awk -F"[/.]" '{print $3}' txt
awk -F"[/]" '{print $3}' txt |awk '{IP[$1]++} END {for(i in IP){print IP[i],i}}' |sort –n
3) 至少说出一种linux下实现高可用的方案名称？
答：keepalived，HeartBeat
4）简述下负载均衡与高可用的概念？
答：
LB : 多台数据平均响应客户端的多次连接请求。
HA : 主备模式，主服务器宕机后 备用服务器才接替工作。


######################################################################################################



Top
NSD Project1 DAY04

案例1：部署Git版本控制系统
案例2：优化Web服务器
1 案例1：部署Git版本控制系统
1.1 问题

部署Git版本控制系统，管理网站代码，实现如下效果：
基于SSH协议的服务器
基于Git协议的服务器
基于HTTP协议的服务器
上传代码到版本仓库
1.2 方案

生产环境应该有一台独立的Git服务器，这里为了节约主机资源，我们使用数据库主机同时做完Git服务器，如图-1所示。

图-1
主机配置如表-1所示。
表-1

1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署SSH协议的版本控制服务器

1）安装软件包，创建空仓库。
[root@database ~]# yum -y install git
[root@database ~]# mkdir /var/git/
[root@database ~]# git init --bare /var/git/wordpress.git            #创建空仓库
2）登陆web1服务器克隆git仓库，上传网站代码到git服务器。
[root@web1 var]# git config --global push.default simple
[root@web1 var]# git config --global user.email you@example.com
[root@web1 var]# git config --global user.name "Your Name"
[root@web1 var]# cd /var/
[root@web1 var]# git clone root@192.168.2.21:/var/git/wordpress.git
[root@web1 var]# cd /var/wordpress
[root@web1 wordpress]# cp -a /usr/local/nginx/html/*  ./
[root@web1 wordpress]# git add .
[root@web1 wordpress]# git commit -m "wordpress code"
[root@web1 wordpress]# git push
root@192.168.2.21's password:<输入192.168.2.21主机root的密码>
步骤二：部署Git协议的版本控制服务器

1）安装软件包（192.168.2.21操作）
[root@database ~]# yum -y install git-daemon
2）修改配置文件，启动Git服务
[root@database ~]# vim /usr/lib/systemd/system/git@.service
修改前内容如下：
ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/lib/git --export-all --user-path=public_git --syslog --inetd –verbose
修改后内容如下：
ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/git --export-all --user-path=public_git --syslog --inetd –verbose
[root@database ~]# systemctl start git.socket
[root@database ~]# systemctl status git.socket
3)客户端测试（使用web2做完客户端主机，192.168.2.12）
在web2执行clone等同于是把代码又备份了一份。
[root@web2 ~]# cd /var/
[root@web2 var]# git clone git://192.168.2.21/wordpress.git
步骤三：部署HTTP协议的版本控制服务器

1）安装软件包（192.168.2.21操作）
[root@database ~]# yum -y install httpd gitweb
2）修改配置文件
[root@database ~]# vim /etc/gitweb.conf
$projectroot = "/var/git";                        #添加一行
3）启动服务
[root@database ~]# systemctl start httpd
4）客户端验证
[root@room9pc01 ~]# firefox http://192.168.2.21/git
访问网页可以查看到wordpress仓库，点击tree菜单后可以看到如图-2所示的代码。

图-2
2 案例2：优化Web服务器
2.1 问题

优化Web服务器，实现如下效果：
自定义网站404错误页面
升级nginx至1.15.8版本，开启status模块
编写日志切割脚本，实现每周五备份日志
2.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：自定义404错误页面

1）优化前测试（客户端访问一个不存在的页面）。
[root@room9pc01 ~]# firefox http://www.lab.com/git
2) 修改Nginx配置文件，自定义错误页面
[root@web1 ~]# vim /usr/local/nginx/conf/nginx.conf         
error_page   404  /404.html;    //自定义错误页面
[root@web2 ~]# vim /usr/local/nginx/conf/nginx.conf         
error_page   404  /404.html;    //自定义错误页面
[root@web3 ~]# vim /usr/local/nginx/conf/nginx.conf         
error_page   404  /404.html;    //自定义错误页面
3） 重启nginx
[root@web1 ~]# /usr/local/nginx/sbin/nginx -s reload
[root@web2 ~]# /usr/local/nginx/sbin/nginx -s reload
[root@web3 ~]# /usr/local/nginx/sbin/nginx -s reload
步骤二：升级nginx版本，开启status模块

1）配置、编译新的nginx（web1、web2、web3做相同操作，下面以web1为例）
[root@web1 ~]# tar  -xf   nginx-1.15.8.tar.gz
[root@web1 ~]# cd  nginx-1.15.8
[root@web1 ~]# ./configure     \
--with-http_ssl_module         \
--with-http_stub_status_module
[root@web1 ~]# make
2) 备份老版本nginx，更新新版本nginx
[root@web1 ~]# mv /usr/local/nginx/sbin/nginx{,.bak}
[root@web1 ~]# cp objs/nginx  /usr/local/nginx/sbin/
3）修改配置文件
[root@web1 ~]# vim /usr/local/nginx/conf/nginx.conf
... ...
location /status {
                stub_status on;
                 allow 192.168.2.0/24;
                 deny all;
        }
... ...
4) 重启服务
[root@web1 ~]# killall nginx
[root@web1 ~]# /usr/local/nginx/sbin/nginx
步骤三：编写日志切割脚本

1）编写脚本（以web1为例）
[root@web1 ~]# vim /usr/local/nginx/logbak.sh
#!/bin/bash
date=`date +%Y%m%d`
logpath=/usr/local/nginx/logs
mv $logpath/access.log $logpath/access-$date.log
mv $logpath/error.log $logpath/error-$date.log
kill -USR1 $(cat $logpath/nginx.pid)
2）创建计划任务
[root@web1 ~]# crontab -e
03 03 * * 5  /usr/local/nginx/logbak.sh
附加知识（常见面试题）

1）Git的主要功能是什么。它的常用命令有哪些？
Git是一个分布式的版本控制软件，支持离线操作，主要功能为版本控制，支持日志、数据恢复等功能。
主要命令：
git clone、git add、git commit、git log、git branch、git checkout、git pull、git merge等。




####################################################################################


 

########################################################################################################

数据库


date 1

庞丽静  panglj@tedu.cn


/etc/my.cnf      # 主配置文件
/var/lib/mysql   # 数据存储目录
/var/log/mysqld.log   #数据库错误日志

[root@host50 ~]# systemctl start mysqld
[root@host50 ~]# systemctl enable mysqld

[root@host50 ~]# ss -plunt |grep 3306
 
[root@host50 ~]# netstat -plunt |grep 3306

ps -C mysql  #查看进程


DB --数据库  依照某种数据模型进行组织并存放到存储器的数据集合
DBMS --数据库管理系统  用来操纵和管理数据库系统的服务软件
DBS --数据库系统 :DB+DBMS 指带有数据库并整合了数据库管理软件的计算机系统
MySQL  特点  --适合于中小型规模 ,关系型数据库 
               --支持多平台操作系统
               --支持Python,Java,Perl,PHP 等编程语言
yum list | grep -i mariadb   #查看mariadb是否安装
rpm -qa |grep -i mysql       #查看mysql是否安装
systemctl start mysqld       #首次启动服务
ps - C mysqld                #ps - C查看指定进程 PID号:23262
netstart  -plunt |grep mysqld  #查看端口号:3306
文件                   说明
/etc/my.cnf       主配置文件
/var/lib/mysql    数据库目录
默认端口                3306
进程名                  mysqld
传输协议                  TCP
进程所有者               MySQL
进程所属组               MySQL
错误日志文件             /var/log/mysqld.log  

grep password /var/log/mysqld.log     #查看本机root的初始密码
mysql -hlocalhost -uroot -p'初始密码'    #-h 服务器 -u 用户身份 -p密码
#在MySQL里   输入help 或 \h 显示帮助       \c  结束命令
>alter user root@"localhost" identified by "123ppp...A";   #修改root密码(用alter user 修改)  注意修改密码是在MySQL里


       密码策略

策略名称                   验证方式
0 or LOW              长度
1 or MEDIUM(默认)      长度;数字,小写/大写,和特殊字符
2 or STRONG           长度;数字,小写/大写和特殊字符;字典文件
mysql>show variables like "%password%";          #模糊查询变量
mysql>set global validate_password_policy=0;     #修改密码策略
mysql>set global validate_password_length=6;     #修改密码长度
]# vim /etc/my.cnf    //永久配置
   [mysql]
  validate_password_policy=0
  validate_password_length=6
[root@host50 ~]# systemctl restart mysqld

mysql> alter user root@localhost identified by 'tarena'; #修改完配置文件后改密码


客户端连接MYSQL服务的方法:
1) 命令行
2) web页面
3) 安装图形软件
4) 编写脚本 (php,java,python...)

使用mysql命令
    mysql -h服务器IP -u用户名 -p密码 [数据库]  
    quit或exit

客户端把数据存储到数据库服务器上的步骤:
   1.连接数据库服务器     mysql -h服务器IP -u用户名 -p密码 [数据库]
   2.建库                 create database 库名; 
   3.建表                 create table 库名/表名(字段名1 类型(宽度))
   4.插入记录             insert into 库.表 values()
   5.断开连接             quit或exit
   
SQL命令使用规则:
不区分字母大小写(密码,变量值除外),每条命令以;结束,默认不支持tab键自动补齐,Ctrl+c 或\c 终止SQL命令

常用的SQL命令分类:
1.DDL 数据定义语言 如: create alter drop
2.DML 数据操作语言 如: insert update delete
3.DCL 数据控制语言 如: grant revoke
4.DTL 数据事物语言 如: commit rollback savepoint 


库 类似于文件夹,用来存储表
  select database();      #显示当前所在数据库(pwd命令一样)
  select user();          #显示链接用户
  show databases;         #显示已有用户
  use 库名;                     #切换库
  create database 库名;      #创建新库
  show tables;             # 显示已有的表
  drop database 库名;          #删除库
 mysql> drop database db1;drop database db2;drop database sdm;   //同时删除多个库

库名 命名规则
  仅可以使用数据,字母,下划线,不能纯数字
  区分字母大小写,具有唯一性
  不可以使用指令关键字,特殊字符

    创建表的格式:
  create table 库名/表名(
       字段名1 类型(宽度)
       字段名2 类型(宽度)
       ......
    ) default charset=utf8;     //默认为latin1 表内容不可以输入汉字


数据库是以文件的形式存放在/var/lib/mysql/目录里,有表文件(如:stuinfo.frm  stuinfo.ibd)
以.frm 结尾存放表结构信息,以.ibd结尾存放数据内容(index检索的信息也存在次文件)-->也叫表空间



mysql>create databasedb1.stuinfo(name char(15), homeaddr char(20));  //创建表(字段 类型char(长度))
mysql>desc db1.stuinfo;        //显示表字段结构
mysql>select * from db1.stuinfo;   //显示表所有内容
mysql>insert into db1.stuinfo values("bob","usa"),("lilei","china"); //插入表记录,类型要对应
mysql>update db1.stuinfo set homeaddr="beijing";    //修改字段记录
mysql>delete from db1.stuinfo;        //删除表内容
mysql>drop table db1.stuinfo;         //删除表
mysql>drop database db1;              //删除库
mysql>show create table stuinfo;      //查看新建表的命令(字符集)

         MySQL数据类型
1.字符类型
       定长:char 最多255个字符 默认 1个 ,如果输入的字符不够你定义的长度时右边用空格补全  浪费空间
       变长:varchar:最多65532个字符,按数据实际大小分配存储空间,超过时无法写入
                      大文本类型:text  blob      字符数大于65535存储时用

2.数值类型
   2(1) 整型类型          类型                有符合范围(负数)           无符号(正数)
        微小整数       tinyint(宽度默认4位) -128~127             0~255
        小整数          smallint          -32768~32767         0~65535
        中整型          mediumint         -2^23 ~ 2^23 -1      0~2^24 -1             
        大整型          int (宽度默认11位)  -2^31 ~ 2^31 -1      0~ 2^32 -1
        超大整型        bigint            -2^63 ~2^63 -1       0~2^64 -1
           unsigned     使用无符号存储范围
               一般都用int
    2(2) 浮点型
          格式1: 字段名 类型
          格式2: 字段名 类型(总宽度,小数位数)
              类型        名称           有符号范围   无符号范围
           float     单精度               0   ~ 2^32  -1    (负数也有)
	     double    双精度               0   ~ 2^64  -1    (负数也有)
  mysql> create table t5 (name char(5),gz float(7,2));
  mysql> insert into t5 values ("bob",10000.88);
         | bob  | 10000.88 |
  mysql> insert into t5 values ("bob",12432.119);
           bob  | 12432.12 

3日期时间类型(建表时设置字段的类型)
   日期时间 datetime     格式:yyyymmddhhmmss  范围:1000-01-01 00:00:00~9999-12-31 23:59:59
   日期时间 timestamp    格式:yyyymmddhhmmss  范围:1970-01-01 00:00:00 ~ 2038-01-19 00:00:00
   日期 date            格式:yyyymmdd        范围:0001-01-01~9999-12-31
   年 year              格式:yyyy            范围:1901~2155
   时间 time            格式:HH:MM:SS

MySQL服务内置命令(插入数据时可以获取时间)
  curtime()       获取当前的系统时间          mysql> select curtime();
  curdate()       获取当前的系统日期
  now()           获取当前的系统日期和时间     mysql> select now();
  year()          获取年                        mysql> select year(now());
  month()         获取月                        mysql> select month(curtime());
  day()           获取日                        mysql> select day(curdate());
  date()          获取日期                      mysql> select date(now());
  time()          获取时间                      mysql> select time(now());
mysql> insert into t7 values("ji",year(20190815),curtime(),curdate(),now());
mysql> insert into t7 values("bom",2000,curtime(),curdate(),now());

关于日期时间字段:
当未给timestamp字段赋值时,自动以当前系统时间赋值,而datetime值为NULL(空)

4枚举类型
  enum 单选  格式:  字段名 enum(值1,值2,值N)
  set 多选  格式:  字段名  set(值1,值2,值N)
######################################################################################
date 2
1,  表结构
        1.1  约束条件 : 作用是限制如何给字段赋值
create database db2;
create table db2.t1 (name char(10) not null default "",
age  tinyint unsigned default 31,
sex enum("m","w") not null default "m");

mysql> insert into t1 (name) values("yxx");    //只为name赋值,age可以为空,但有默认值31,sex 单选非空默认为m
         null       允许位空
         not null   不允许为空
         key        键值类型
         default    设置默认值,缺省为NULL
         extra      额外设置
   default 默认值:  不给字段赋值使用默认值赋值
               默认不定义时 是 null
               定义             default 值 (要与字段值类型匹配)
   extra  额外设置     默认都没有额外设置               

create table t9(name char(10) not null,homeaddr char(30) not null default "");
insert into t9(name) values("sdm");
| name | homeaddr |
+------+----------+
| job  | null     |
| sdm  |          |
+------+----------+
2 rows in set (0.00 sec)
                                                                      
        1.2 修改表结构                                   
      命令    alter table 库.表名 执行动作;
        执行动作:   
            a.添加新字段  add
				add 字段名  类型 [约束条件];
				add 字段名  类型 [约束条件] after 字段名;
				add 字段名  类型 [约束条件] first;
mysql> alter table db2.t1 add email varchar(50);
mysql> alter table db2.t1 add likes set("eat","drink","game","happy") not null
         修改                    添加  字段   多选                                        非空
 default "eat,drink" after age;
  默认值                          字段名
mysql> alter table db2.t1 add class char(7) default "nsd1907" first;

             b. 修改字段类型  modify 

                          modify 字段名 类型(宽度)  约束条件 [after 字段名 | first ];   //只能改类型 (宽度) 约束条件
 mysql> alter table db2.t1 modify age tinyint unsigned default 31 after class; 
 mysql> alter table db2.t1 modify name varchar (15) not null default "";


              c.修改字段名   change
 alter table 库.表名 change 源字段名 新字段名 类型(宽度) 约束条件;  //可以改字段名 也可以改类型(宽度) 约束条件

mysql> alter table db2.t1 change email mail varchar(50);

              d. 删除字段 drop
 alter table 库.表名 drop 字段名;

              e. 修改表名 rename

 alter table 库.表名 rename 库名.新表名;


修改表结构的命令可以集在一条命令上,用,号分开:
mysql> alter table db1.t1 
       add qq char(11), 
       add iphone char(11),
       modify class char(9),
       change name user varchar(15) not null default "", 
       drop xuexiao;


add       添加新字段,也可以改变字段位置
modify    修改字段类型,也可以改变字段位置,只能改类型 (宽度) 约束条件
change    修改字段名,可以改字段名 也可以改类型(宽度) 约束条件
drop      删除字段
rename    修改表名


2.  MySQL 键值
          普通索引  index (MUL)  *****
          唯一索引  unique
          主    键  primary key(PRI) *****
          外    键   foreign key *****
          全文索引  fulltext
          
索引  :  --类似与书的目录
         --对表中字段值进行排序
         --索引类型 : Btree ,B+tree , hash
*******
  优点  : --通过创建唯一性索引,可以保证数据库表中每一行数据的唯一性
          --可以加快数据的查询速度

  缺点  : --当对表中的数据进行增加,删除和修改的时候,索引也要动态的调整,降低了数据的维护速度
          --索引需要占领物理空间


普通索引
    普通索引使用规则:    -------一个表中可以有多个index字段
			  -------字段的值允许重复,且可以赋NULL值
			  --------通常把做为查询条件的字段设置为index 字段
 			 ---------index字段 标志是MUL				
    创建索引   :   1 建表时创建索引
                      create table 库名.表名 (
                                     字段列表,index(字段名),
                                     index(字段名));
                    2 在已有表里创建索引
                       create index 索引名 on 表名(字段名)
                    3 查看索引字段
                          基本查看    desc 表名 ; key 列
		          详细查看    show index from 表名 \G;
                                                               竖着显示
                    4 删除索引
                        drop index 索引名  on 库.表名;

mysql> create table db2.t2(name char(10),age int,class char(7),email char(30),index(name),index(age));   //建表时创建索引
mysql> show index from db2.t2 \G;     //以竖着的方式显示索引
mysql> drop index age on db2.t2;      //删除索引
mysql> show index from db2.t2 \G;
  
mysql> create index xxx on db2.stuinfo(name);
mysql> create index sex on db2.stuinfo(sex);
mysql> show index from stuinfo \G;
mysql> drop index xxx on db2.stuinfo;



主    键  primary 的使用
     1 使用规则    --字段值不允许重复,且不允许赋空值
                   --一个表中只能有一个primary key 字段
                   --多个字段都作为主键,称为复合主键,必须一起创建.
                   --主键字段的标示是PRI
                   --主键通常与auto_increment连用(auto_increment同shell里i=i+1   自增长)
                   --通常把表中唯一标识记录的字段设置为主键
                             [记录编号字段]
     2 创建主键  作用:字段值不能同时重复
             2.1 建表时创建主键:
  mysql> create table t4 (name char(10),age int,primary key(name));   //2种方法都可以
  mysql> create table t3(name char(10) primary key,age int );         
  mysql> desc t4;
             2.2 在已有表里创建主键
 alter table 库.表  add primary key (字段名);
 mysql> desc stuinfo;
 mysql> insert into stuinfo(name) values("WH");
 mysql> desc stuinfo;
           
             2.3 复合主键 :  ---表中多个字段一起做主键
                              --- 插入记录时复合主键字段的值不允许同时重复
alter table 表名 add primary key (字段名列表);  //已有表添加复合主键
create table 表名  primary key (字段名列表);  //创建表时添加复合主键

mysql> create table  db2.t6(
    -> class char(7),
    -> name  char(15),
    -> pay   enum("yes","no") default "no",
    -> primary key(class,name,pay)  //指定多个字段一起做主键
    -> );
Query OK, 0 rows affected (0.04 sec)
             
           2.4 删除主键
                 alter table 库.表 drop primary key;
                     mysql> alter table db2.t5 drop primary key;
           2.5 在已有表里创建主键
                     alter table 库.表 add primary key(字段名);
                     alter table 库.表 add primary key(字段名列);
mysql> alter table t5 add stu_num char(9) first;       
mysql> delete from t5;
mysql> select * from t5;
mysql> alter table db2.t5 add primary key (stu_num, class,name );   //将多个字段都创建为复合主键时先删除表里的内容
mysql> desc t5;
            2.6 主键与auto_increment 连用
                    作用:让字段的值自增长的方式赋值    类似i++ i=i+1
                    注意:字段自增长也可以命令赋值,只是不能与之前的值重复,后面如果继续不赋值的话,自增长会在上一条的基础上再加一

删除自增长和主键:(先删除auto_increment,再删除primary key主键)
mysql> alter table t3 modify id int not null;
mysql> alter table t3 drop primary key;


    创建新表
create table db2.t6(stu_num int primary key auto_increment,name char(10),age int);
mysql> insert into t6 (name ,age)  values("bob",19);
mysql> select * from t6;
mysql> insert into t6 (name ,age)  values("lisi",29);
mysql> insert into t6 (name,age) values("sdm",33);
mysql> select * from t6;
+---------+------+------+
| stu_num | name | age  |
+---------+------+------+
|       1 | bob  |   19 |
|       2 | lisi |   29 |
|       3 | sdm  |   33 |
+---------+------+------+
3 rows in set (0.00 sec)
mysql> delete from t6;
mysql> insert into t6 (name,age) values("yxx",24);  //表里内容删除之后插入内容,系统会记住之前auto_increment的数值,在次之上继续+1 而不会清零
mysql> insert into db2.t6 values (null,"lisi",18);   //赋空值时auto_increment会自动+1,而不是空值

      已有表更改
mysql> desc stuinfo;               //查看表是否有 主键  primary key
mysql> alter table db2.stuinfo drop primary key;        //删除主键  primary key
mysql> alter table db2.stuinfo add id int primary key auto_increment first;   //添加字段id 并设为主键 primary key  自增长 auto_increment 插入到首行

   
     3 foreign key 外建 

 作用(功能):限制字段赋值,向表中插入记录时,字段的值在另外一张表字段值里选择.

 外键规则 : ---- 表存储引擎必须是innodb
            ---- 字段类型要一致
            ----- 被参照字段必须要是索引类型的一种(primary key)    ( 值要唯一,且不能为空)
  创建外键规则的命令格式:
          create table 库.表(字段列表,foreign key(字段名) references 库.表(字段名) on update cascade[#同步更新]  on delete cascade[#同步删除]) engine=innodb;
                                                                    // 保持数据的一致性


  show create table gz \G;  #查看创建表(gz)的命令 \G竖着显示


建员工表:
 mysql> create table db2.ygb(yg_id int primary key auto_increment,name char(20),sex enum("boy","girl")) engine=innodb;
mysql> insert into db2.ygb(name,sex) values("bob","boy"); 
mysql> insert into db2.ygb(name,sex) values("lucy","girl"); 
mysql> select * from ygb;

建工资表:    以员工编号(gz_id)为外键
mysql> create table gzb(gz_id int,pay float(7,2),foreign key(gz_id) references ygb(yg_id) on update cascade on delete cascade)engine=innodb;
mysql> show create table gzb;  //查看外键
mysql> update ygb set yg_id=8 where yg_id=2;
mysql> select * from ygb;
mysql> select * from gzb;


alter table gzb  add primary key (gz_id);  #将工资(gz)表的gz_id字段设为主键防止输入空值和重复输入
                    删除外键
                         show create table gzb \G;               #查看创建表(gz)的命令 \G竖着显示
                         alter table gzb drop foreign key gzb_ibfk_1;   #gzb_ibfk_1外键名
                         show create table gzb \G;
insert into gzb values(8,20000);
insert into gzb values(7,20000);
####################################################################


  date 3
1  数据导入导出
         1.1数据导入与导出默认检索路径
                  查看
                     mysql> show variables like "%file%";       //查看变量
                     mysql> show variables like "%secure_file_priv%";   
                     mysql> system ls /var/lib/mysql-files;      //在MySQL里敲系统命令要加 system 即可
                                    默认导入路径/var/lib/mysql-files
                  修改
              vim /etc/my.cnf
                [mysqld]
                secure_file_priv="/myload"            //数据导入导出文件存放的位置
                :wq
                mkdir /myload
                chown mysql /myload
                systemctl restart mysqld
                ]# mysql -uroot -ptarena
                mysql>show variables like "secure_file_priv";
         1.2数据导入
                  什么数据导入:把系统文件内容存储到数据库服务器的表里
                  命令格式 (登录状态)mysql>
                  load data infile "目录/文件名" into table 库.表 fields terminated by "符号" lines terminated by "\n";                                                           列                                  行
                   例子  把系统用户信息/etc/passwd存储到db3 库下的t1 表里
                          数据导入步骤:
                             建库
                             建表 (表结构根据文件内容创建)
                             把系统文件拷贝到检索目录下
                             导入数据
mysql> create database db3;
mysql> system cp /etc/passwd /myload/;  
mysql> system ls /myload;
mysql> create table db3.t1(username char(50),password char(1),uid int,gid int,comment varchar(150),homedir char(150),shell char(50));
mysql> load data infile "/myload/passwd" into table db3.t1 fields     terminated by ":" lines terminated by "\n";
mysql> alter table db3.t1 add id int primary key auto_increment first;
mysql> select * from t1 where id=1;

           
         1.3数据导出
                  什么数据导出 ? 把数据库表里的记录,保存到系统文件里
                   命令格式 mysql>
                     select 查询命令 into outfile "目录名/文件名";
                     select 查询命令 into outfile "目录名/文件名" fields terminated by "符号";
                     select 查询命令 into outfile "目录名/文件名"  fields terminated by "符号" lines terminated by "\n" ;
                   例子                                                                 
mysql> select * from db3.t1 where id = 1 into outfile "/myload/user1.txt";    
mysql> system cat /myload/user1.txt;
mysql> select * from db3.t1 where id<=2 into outfile "/myload/user2.txt";
      
        1	root	x	0	0	root	/root	/bin/bash
        2	bin	x	1	1	bin	/bin	/sbin/nologin
mysql> select username,homedir,shell from db3.t1 where id<=2 into outfile "/myload/user3.txt" fields terminated by ":" lines terminated by "###";
mysql> system cat /myload/user3.txt; 
    
       root:/root:/bin/bash###bin:/bin:/sbin/nologin###mysql> 

2 管理表记录
      2.1  添加记录  insert into(新添加的记录追加在记录末尾)
              添加一条记录给所有列赋值 
 insert into 表名 values (字段值列表);
              添加多条记录给所有列赋值
 insert into 表名 values (字段值列表),(字段值列表),(字段值列表);
              添加一条记录给指定的列赋值
 insert into 表名(字段名列表) values (字段值列表);
              添加多条记录给指定的列赋值
 insert into 表名(字段名列表) values (字段值列表),(字段值列表);

 insert into db3.t1(username,password,uid,gid,comment,homedir,shell) values("yaya100","x",1000,1000,"","/home/yaya100","/bin/bash");



      2.2  查询记录  select 
             select 字段名列表 from 表名 [ where 条件] ;
             select * from 表名;

      2.3  更新记录  update(修改记录字段的值)
                 update 库.表 set 字段名=值,字段名=值 [where 条件];
                       update db3.t1 set password="A";
                       update db3.t1 set password="A" ,comment="student user";


      2.4  删除记录  delete(以行为单位删除)

                 delete from 库.表 ;    //删除所有行
                 delete from  库.表 [where 条件]  //删除指定行    

3 匹配条件    (适用于 select ,update ,delete 记录 操作 )
          3.1  基本匹配条件
                   数值比较   =  >  >=  <  <=  != 
mysql> select username,uid,gid from t1 where uid>gid;

                   字符比较   =  !=   is null   is not null
mysql> select uid,shell from t1 where shell!="/bin/bash";
mysql> select username from t1 where shell="/bin/bash";

                   范围比较  
 in (值列表)      在...里...
 not in (值列表)      不在...里... 
  mysql> select username,shell from db3.t1 where shell not in ("/bin/bash","/sbin/nologin");

 between 数据 and 数据    在...之间...
 distinct 字段名     去重显示
            mysql> select distinct shell from t1;

                   匹配空(null)    is null
insert into db3.t1 (username,uid) values(null,1001)
mysql>;  //给username赋空
                   匹配非空(不是null)     is not null
mysql>insert into db3.t1 (username,uid) values("null",1002);  //双引号括起来的不是给空值
mysql>insert into db3.t1 (username,uid) values("",1003);  //双引号括起来的不是给空值
 

mysql> select username,uid from db3.t1 where username="";    //查看username为空白的行
mysql> select username,uid from db3.t1 where username="null";  //查看username为null 的行
mysql> select username,uid from db3.t1 where username is not null;  //查看非空
mysql> select username,uid from db3.t1 where username is null;      //查看空值

                   逻辑匹配(多个匹配条件)
                       or   逻辑或   多个匹配条件,某一个条件成立即可 
                       and  逻辑与   多个匹配条件,必须同时成立
                              ! 或 not  逻辑非         取反 !=    not in     is not null
mysql> select username,uid from t1 where username="root" and uid=1;
mysql> select username,uid from t1 where username="root" or uid=1;
mysql> select username,uid,gid shell from t1 where username="root" or uid=1; //注意这里gid shell之间如果没有,号的话就是将前面的字段gid取一个别名shell显示出来
          3.2 高级匹配条件
                     模糊查询   like
                        where 字段名 like '表达式';
                                         _ 表示1个字符
                                         %  表示0~n 个字符
mysql>select username from db3.t1 where username like "____";   //模糊查询4个字符的字段
mysql>select username from db3.t1 where username like "___";    //模糊查询3个字符的字段
mysql>select username from db3.t1 where username like "%a%";    //模糊查询包含a的字段
mysql>select username from db3.t1 where username like "a%";      //模糊查询以a 开头的字段
mysql>select username from db3.t1 where username like "__%__";   //模糊查询4个字符以上的字段
                     正则匹配   regexp
                     where 字段名 regexp '正则表达式';
                           元字符  ^  $  .  [ ]   *   |
mysql> select username from db3.t1 where username regexp '^a|^t';    //查询字段username 以a或t开头的       
mysql> select username from db3.t1 where username regexp '[at]';     //查询字段username 包含a或t
mysql> select username from db3.t1 where username regexp '^[at]';    //查询字段username 以a或t开头的       
mysql> insert into db3.t1(username) values("yaya7"),("5yaya"),("ya8ya"); //插入多个username字段
mysql> select username from db3.t1 where username regexp '[0-9]';      // 查询字段username 包含数字的
mysql> select name,uid from user where uid regexp '^..$'               //查询字段uid为2位数的


                      四则运算  + - * %
mysql> select username,2019-age start_y, age from db3.t1;  //查询字段username 对age 进行运算(2019-age)并起名为start_y  
mysql> select username,uid from db3.t1 where uid <=5;   //查询字段username uid 而且uid<=5
mysql> update db3.t1 set uid=uid+1 where uid<=5;        //修改字段uid<=5的且进行+1运算
mysql> select username ,uid from db3.t1 where uid<=6;   //查询字段username uid 而且uid<=6
mysql> select username,uid,gid,(uid+gid)/2 pjz from db3.t1 where username="bin"; //查看字段 并且对字段uid,gid 求和后除以2 并命名为pjz 条件为username="bin"
mysql> select username ,uid from db3.t1 where uid%2=0;  //查看uid为偶数的用户(uid%2=0)
mysql> select username ,uid from db3.t1 where uid%2!=0; //查看uid为奇数的用户(uid%2=0)

          3.3 操作查询结果(对查询后的数据做处理)
                  3.3.1 聚集函数(mysql服务内置的对数据做统计的命令)
                    avg(字段名)          //统计字段平均值
                    sum(字段名)          //统计字段之和
                    min(字段名)          //统计字段最小值
                    max(字段名)          //统计字段最大值
                    count(字段名)        //统计字段值个数
mysql> select min(uid ) from t1;  //查看uid值最小的
mysql> select max(uid) from t1;   //查看uid值最大的
mysql> select uid from t1 where uid >=10 and uid<=20;  //查看uid在10到20之间的
mysql> select min(uid) from t1 where uid >=10 and uid<=20;  //查看uid在10到20之间最小的
mysql> select count(*) from t1;         //统计t1表中有多少行
mysql> select count(username) from t1 where shell="/sbin/nologin";  //统计字段username shell="/sbin/nologin" 的数量

                  3.3.2  查询结果排序 order by 字段名  asc(默认什序)|desc(降序)
mysql> select username,uid from t1 where uid<=1000;    
mysql> select username,uid from t1 where uid<=1000 order by uid;   
mysql> select username,uid from t1 where uid<=1000 order by uid desc;

                  3.3.3 查询结果分组  group by 字段名;
mysql> select shell from t1;
mysql> select shell from t1 where uid<=100;
mysql> select shell from t1 where uid<=100 group by shell;     //查询结果分组 不显示重复值,对结果进行分组,速度快
mysql> select distinct shell from t1 where uid <=100;          //查询结果不显示重复值,对表进行逐行查询,速度慢

                  3.3.4 查询结果过滤   having 条件;
mysql> select username,uid from t1 where username is not null;
mysql> select username,uid from t1 where username is not null and uid=3;  //逐行查询,速度慢
mysql> select username,uid from t1 where username is not null having uid=3;  //对结果进行筛选,速度快
                  3.3.5 限制查询结果显示行数  limit
                         1.只显示查询结果的前几行  limit 数字n (显示前n行);
                         2.只显示查询结果指定范围之间的行  limit 数字1,
                                     数字1  显示的起始行
                                     数字2  显示的总行数
                             limit 0,3;  //从第一行开始显示前3行
                             limit 3,3;  //从第4行开始显示后面3行
mysql> select username,uid from db3.t1 where  id<=10 limit 0,3;

4 MySQL管理工具
           4.1 连接MySQL服务的方式?
                 命令行,使用软件连接(提供图形界面),连接脚本(PHP,pythen,java)
           4.2 安装图形软件管理数据库服务
                  常用的图形软件有那些?
    [root@mysql ~]# yum -y install httpd php php-mysql
    [root@mysql ~]# systemctl start httpd
    [root@mysql ~]# systemctl enable httpd
    [student@room9pc01 ~]$ scp /linux-soft/03/mysql/phpMyAdmin-2.11.11-all-languages.tar.gz root@192.168.4.50:/root/
    [root@mysql ~]# tar -zvxf phpMyAdmin-2.11.11-all-languages.tar.gz 
    [root@mysql ~]# mv phpMyAdmin-2.11.11-all-languages /var/www/html/phpmyad
    [root@mysql phpmyad]# cd /var/www/html/phpmyad
    [root@mysql phpmyad]# cp config.sample.inc.php config.inc.php
    [root@mysql phpmyad]# sed -n '31p' config.inc.php
    [root@mysql phpmyad]# sed -n '17p' config.inc.php
    [root@mysql phpmyad]# vim +17 config.inc.php     //光标定义在17行
      17行:  $cfg['blowfish_secret'] = 'plj123'; /* YOU MUST FILL IN THIS FOR COOKIE AUTH!    //=号后面单引号里面随便写的什么
      31行:  $cfg['Servers'][$i]['host'] = 'localhost';     //默认是本机localhost,


 
    打开真机浏览器访问50主机软件的网址  http://192.168.4.50/phpmyad/
                     用户名 root
                     密码   tarena


练习:::::::::::::

+++++++++++++++++++++++++++++++++++++++++++++++++++
mysql> desc db2.user;


+---------+---------------------+------+-----+---------+----------------+
| Field   | Type                | Null | Key | Default | Extra          |
+---------+---------------------+------+-----+---------+----------------+
| name    | char(50)            | NO   |     | NULL    |                |
| sex     | enum('girl','boy')  | NO   |     | boy     |                |
| pay     | float(7,2)          | NO   |     | 5000.00 |                |
| age     | tinyint(3) unsigned | NO   |     | 21      |                |
| s_year  | year(4)             | NO   |     | 1990    |                |
| passwd  | char(1)             | NO   |     | NULL    |                |
| uid     | int(11)             | NO   |     | NULL    |                |
| gid     | int(11)             | NO   |     | NULL    |                |
| homedir | char(150)           | NO   |     | NULL    |                |
| shell   | char(50)            | NO   |     | NULL    |                |
| id      | int(11)             | NO   | PRI | NULL    | auto_increment |
+---------+---------------------+------+-----+---------+----------------+
11 rows in set (0.00 sec)



6 在name字段下方添加s_year字段 存放出生年份 默认值是1990
mysql> alter table user add s_year year default 1990 after name;

7 在name字段下方添加字段名sex 字段值只能是gril 或boy 默认值是 boy
mysql> alter table user add sex enum("girl","boy") default "boy" after name;

8 在sex字段下方添加 age字段  存放年龄 不允许输入负数。默认值 是 21
mysql> alter table user add age tinyint unsigned default 21 after sex;

9 把id字段值是10到50之间的用户的性别修改为 girl
mysql> update user set sex="girl" where id between 10 and 50;

10 统计性别是girl的用户有多少个。
mysql> select count(*) from user where sex="girl";

12 查看性别是girl用户里 uid号 最大的用户名 叫什么。
mysql> select name,uid from user where sex="girl" order by uid desc limit 1;


13 添加一条新记录只给name、uid 字段赋值 值为rtestd  1000
mysql> insert into user(name,uid) values("rtestd",1000);

   添加一条新记录只给name、uid 字段赋值 值为rtest2d   2000
mysql> insert into user(name,uid) values("rtest2d",2000);

14 显示uid 是四位数的用户的用户名和uid值。
mysql> select name,uid from user where uid like "____";

15 显示名字是以字母r 开头 且是以字母d结尾的用户名和uid。 
mysql> select name,uid from user where name like "r%d";

16  查看是否有 名字以字母a开头 并且是 以字母c结尾的用户。 
mysql> select name from user where name like "a%c";
Empty set (0.00 sec)


8  把gid  在100到500间用户的家目录修改为/root
mysql> update user set shell="/root" where gid between 100 and 500;

9  把用户是  root 、 bin 、  sync 用户的shell 修改为  /sbin/nologin
mysql> update user set shell="/sbin/nologin" where name in ("root","bin","sync");

10   查看  gid 小于10的用户 都使用那些shell
mysql> select shell from user where gid<=10;

12   删除  名字以字母d开头的用户。
mysql> delete from user where name like "d%";
或
mysql> delete from user where name regexp '^d';

13   查询  gid 最大的前5个用户 使用的 shell
mysql> select shell from user order by gid desc limit 0,5;

14   查看那些用户没有家目录
mysql> select name from user where homedir is null;

15  把gid号最小的前5个用户信息保存到/mybak/min5.txt文件里。 
[root@host50 ~]# mkdir /mybak
[root@host50 ~]# vim /etc/my.cnf
[root@host50 ~]# systemctl restart mysqld
mysql> select * from user order by gid limit 0,5 into outfile "/mybak/min5.txt";

    使用useradd 命令添加登录系统的用户 名为lucy 
    system useradd lucy
16  把lucy用户的信息 添加到user1表里
mysql> system grep lucy /etc/passwd
lucy:x:1000:1000::/home/lucy:/bin/bash
mysql> insert into user(name,passwd,uid,gid,comment,homedir,shell) values("lucy","x",1000,1000,"","/home/lucy","/bin/bash");

17  删除表中的 comment 字段 
mysql> alter table user drop comment;

18  设置表中所有字段值不允许为空
mysql> alter table user modify name char(50) not null;
mysql> alter table user modify sex enum("girl","boy") not null default "boy";
mysql> alter table user modify pay float(7,2) not null default 5000;
mysql> alter table user modify age tinyint unsigned not null default 21;
mysql> alter table user modify s_year year not null default 1990;
mysql> alter table user modify passwd char(1) not null;
mysql> alter table user modify uid int not null;
mysql> alter table user modify gid int not null;
mysql> alter table user modify homedir char(150) not null;
mysql> alter table user modify shell char(50) not null;

19  删除root 用户家目录字段的值
mysql> update user set homedir="" where name="root";

20  显示 gid 大于500的用户的用户名 家目录和使用的shell
mysql> select name,homedir,shell from user where gid >500;

21  删除uid大于100的用户记录
mysql> delete from user where uid >100;

22  显示uid号在10到30区间的用户有多少个。
mysql> select count(*) from user where uid between 10 and 30;

23  显示uid号是100以内的用户使用shell的类型。
mysql> select distinct shell from user where uid < 100;

24  显示uid号最小的前10个用户的信息。
mysql> select * from user order by uid limit 10;

25  显示表中第10条到第15条记录
mysql> select * from user where id>=10 and id <=15;

26  显示uid号小于50且名字里有字母a  用户的详细信息
mysql> select * from user where uid <50 and name like "%a%";

27  只显示用户 root   bin   daemon  3个用户的详细信息。
mysql> select * from user where name in ("root","bin","daemon");

28  显示除root用户之外所有用户的详细信息。
mysql> select * from user where name !="root";

29  统计username 字段有多少条记录
mysql> select count(username) from user;

30  显示名字里含字母c  用户的详细信息
  mysql> select * from user where name like "%c%";
 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
31  在sex字段下方添加名为pay的字段，用来存储工资，默认值    是5000.00
mysql> alter table user add pay float(6,2) default 5000 after sex;

32  把所有女孩的工资修改为10000
mysql> update user set pay=10000 where sex="girl";

33  把root用户的工资修改为30000
mysql> update user set pay=30000 where name="root";

34  查看所有用户的名字和工资
mysql> select name,pay from user;

35  查看工资字段的平均值
mysql> select avg(pay) from user;

36  查看工资字段值小于平均工资的用户 是谁。
mysql> select name from user where pay < 9062.5;

      查看女生里谁的uid号最大
mysql> select name from user order by uid desc limit 1;

38  查看bin用户的uid gid 字段的值 及 这2个字段相加的和  
mysql> select uid,gid from user where name="bin";
mysql> select sum(uid+gid) from user where name="bin";

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



information_schema   //默认虚拟库,不占内存空间

mariadb数据库里默认所有用户对test库有完全权限


#########################################################################################################################

  date 4


which mysql // 查看命令产生的路径

1 用户授权 
    1.1 什么是用户授权:在数据库服务器上添加新的连接用户,在添加用户时可以设置访问权限及连接密码.默认数据库管理员root用户本机登录有授权权限.
        撤销权限: 删除添加的用户对数据的访问权限
        删除用户: 把新添加的数据库删除
        授权库:  mysql库,保存新添加的用户信息和权限信息
    1.2 授权命令格式 mysql>
          grant 权限列表 on 库名 to 用户名@"客户端地址" identified by "密码"  [with grant option] ; //有授权权限,可选项 
    1.3 授权例子
mysql> grant all on *.* to mydba@"%" identified by "123qqq...A" with grant option;
    客户端使用授权用户连接数据库服务器
[root@mys ~]# mysql -h192.168.4.50 -umydba -p"123qqq...A"
mysql>
mysql>grant select,insert,update(password,uid) on db3.t1 to yaya@"localhost" identified by "123qqq...A"; 
    1.4 相关命令
       select user();  //获取当前登录的用户
       show grants;      //用户显示自身访问权限
       show grants for 用户名@"客户端地址";  //管理员查看已有授权用户权限
       set password=password("密码");    //授权用户连接后修改连接密码
       set password for 用户名@"客户端地址"=password("密码");  //管理员重置授权用户连接密码   
       drop user 用户名@"客户端地址";         //删除授权用户

password是一个加密函数(写的是明文密码,保存在授权库的时候是加密的,select password("密码")可以查看)

MySQL库 记录授权信息,主要表如下:
user表      记录已有的授权用户及权限
db表       记录已有授权用户对数据库的访问权限
tables_priv表  记录已有授权用户对表的访问权限
columns_priv表  记录已有授权用户对字段的访问权限
查看表记录可以获取用户权限,也可以通过更新记录,修改用户权限
 

    1.5 授权库MySQL(记录授权信息MySQL库的管理)
user表    记录已有的授权用户及权限
mysql> select host,user from mysql.user;
mysql> select * from mysql.user where host="%" and user="mydba"\G;
db表       记录已有授权用户对数据库的访问权限
mysql> desc mysql.db;
mysql> select host,db,user from mysql.db;
mysql> select * from mysql.db where host="localhost" and db="db3" and user="admin2" \G;
mysql> show grants for admin2@"localhost";

mysql> update mysql.db set Update_priv="N",Delete_priv="N" where host="localhost" and db="db3" and user="admin2";
mysql> select * from mysql.db where host="localhost" and db="db3" and user="admin2"\G;
mysql> flush privileges;      
mysql> show grants for admin2@"localhost";                         

tables_priv表  记录已有授权用户对表的访问权限
mysql> desc mysql.tables_priv;
mysql> select * from mysql.tables_priv;
mysql> select * from mysql.tables_priv where db="db3" and table_name="user"\G;
mysql> show grants for admin@192.168.4.%;
columns_priv表  记录已有授权用户对字段的访问权限
mysql> desc mysql.columns_priv;


    1.6 撤销权限  revoke 权限列表 on 库名.表 from 用户名@"客户端地址"

mysql> revoke grant option on *.* from mydba@"%";
mysql> show grants for mydba@"%";
mysql> revoke delete on *.* from mydba@"%";
mysql> show grants for mydba@"%";
mysql> revoke all on *.* from mydba@"%";
mysql> show grants for mydba@"%";





    1.7 删除授权用户drop user 用户@"客户端地址"
mysql> drop user mydba@"%";
mysql> select host,user from mysql.user;

在数据库服务器192.168.4.53上做如下:
1、修改数据库管理员从本机登录的密码为plj666, 数据库管理员使用新密码从本机连接数据库服务器
[root@host53 ~]# sed -i "10a validate_password_length=6\nvalidate_password_policy=0" /etc/my.cnf
[root@host53 ~]# systemctl restart mysqld
[root@host53 ~]# mysql -uroot -p123qqq...A 
mysql> alter user root@localhost identified by 'plj666';

2、查看当前登陆数据库服务器的用户是谁？
mysql> select user();
+----------------+
| user()         |
+----------------+
| root@localhost |
+----------------+

3、查看当前登陆数据库服务器用户的权限？
mysql> show grants for root@'localhost';

4、查看当前数据库服务器有哪些授权用户?
mysql> select host,user from mysql.user;

5、授权管理员用户root可以在网络中的192.168.4.254主机登录，对所有库和表有完全权限且有授权的权限 登陆密码tarena
mysql> grant all on *.* to root@'192.168.4.254' identified by 'tarena' with grant option;

6、不允许数据库管理员root在数据库服务器本机登录。
mysql> delete from mysql.user where user='root' and host='localhost';
mysql> flush privileges;

7、授权yaya108用户可以从网络中的任意主机访问数据库服务器，仅对对userdb库下的user表有查看记录、更新name字段的权限 ，  
   登录密码userweb888。
mysql> create database userdb;
mysql> create table userdb.user(name char(10),id int);
mysql> insert into user values("sdm",12);
mysql> grant update(name),select on userdb.user to yaya108@"%" identified by "userweb888";
mysql> show grants for yaya108@'%';
+-----------------------------------------------------------------+
| Grants for yaya108@%                                            |
+-----------------------------------------------------------------+
| GRANT USAGE ON *.* TO 'yaya108'@'%'                             |
| GRANT SELECT, UPDATE (name) ON `userdb`.`user` TO 'yaya108'@'%' |
+----------------------------------------

8、验证以上授权是否成功

[root@host53 ~]# mysql -uyaya108 -puserweb888
mysql> insert into user values("sdm",12);
ERROR 1142 (42000): INSERT command denied to user 'yaya108'@'localhost' for table 'user'
mysql> select * from user;
+------+------+
| name | id   |
+------+------+
| sdm  |   12 |
+------+------+
mysql> update user set name="AAA";
mysql> select * from user;
+------+------+
| name | id   |
+------+------+
| AAA  |   12 |
mysql> update user set id="100";
ERROR 1143 (42000): UPDATE command denied to user 'yaya108'@'localhost' for column 'id' in table 'user'



9、yaya108用户修改自己的登陆密码为123456,并验证能否使用新密码登陆
[root@host53 ~]# mysqladmin -uyaya108 -puserweb888 password '123456'
[root@host53 ~]# mysql -uyaya108 -p123456

10、 数据库管理员修改授权用户yaya的登录密码为654321，让授权用户yaya 使用新密码登陆数据库服务器。
[student@room9pc01 ~]$ mysql -h192.168.4.53 -uroot -ptarena
MySQL [(none)]> alter user yaya108@"%" identified by "654321";
[root@host53 ~]# mysql -uyaya108 -p654321

11、撤销授权用户yaya108 的所有授权并 使其不再能使用此用户连接数据库服务器。
MySQL [(none)]> revoke select,update(name) on userdb.user from yaya108@"%";
MySQL [(none)]> delete from mysql.user where user='yaya108';
MySQL [(none)]> flush privileges;

12、授权webadmin用户可以从网络中的所有主机登录，对bbsdb库拥有完全权限，且有授权权限，登录密码为 123456
MySQL [(none)]> grant all on bbsdb.* to webadmin@"%" identified by '123456' with grant option;

13、在客户端使用授权用户webadmin登录，把自己的权限授权给userone用户 ， 登录密码是  123456
[root@host53 ~]# mysql -uwebadmin -p123456
mysql> grant all on bbsdb.* to userone@"%" identified by '123456' with grant option;

14、撤销webadmin用户的授权权限。
MySQL [(none)]> revoke grant option on *.* from webadmin@"%";
MySQL [(none)]> flush privileges;

15、授权数据库管理员可以在本机连接数据库服务。
MySQL [(none)]> grant all on *.* to root@"%" identified by "plj666" with grant option;
16、不允许主机192.168.4.254使用root用户连接数据库服务器192.168.4.53
mysql> delete from mysql.user where host="192.168.4.254" and user="root";
mysql> flush privileges;

授权用户默认对下列（  C ）库，拥有完全权限    
A.所有新创建的库 
B.mysql 
C.test 
D.information_schema 

(单选题)（ C  ）记录,在查询缓存中，查到记录的的次数。
A.query_cache_min_res_unit 
B.query_cache_limit 
C.Qcache_hits 
D.Qcache_lowmem_prunes 
 

root密码忘了怎么办?
1.停止MYSQL服务程序   
2.跳过授权表启动MYSQL服务程序
3.修改root密码
4.以正常方式重启MYSQL服务程序

    1.8 管理root密码
          1.8.1 恢复密码
          1.8.2 修改密码(重置密码)
[root@mysql ~]# systemctl stop mysqld
[root@mysql ~]# vim /etc/my.cnf
    skip-grant-tables
   #validate_password_policy=0
   #validate_password_length=6
[root@mysql ~]# systemctl start mysqld
[root@mysql ~]# mysql
mysql> desc mysql.user;   //查询authentication_string
mysql> update mysql.user set authentication_string=password("A...qqq321") where host="localhost" and user="root";
mysql> flush privileges;            
mysql> exit
[root@mysql ~]# vim /etc/my.cnf
   #skip-grant-tables
    validate_password_policy=0
    validate_password_length=6
:wq
[root@mysql ~]#systemctl restart mysqld
 
[root@mysql ~]# mysqladmin -hlocalhost -uroot -p password "123456"
Enter password:输入旧密码
[root@mysql ~]#mysql -uroot -p123456
mysql>


2 数据完全备份     数据量少可以用物理备份,数据量大是用逻辑备份
   2.1 数据备份目的 ? 数据丢失或损坏,可以使用备份数据
   2.2 数据备份方式 ?
          物理备份  192.168.4.50
                 ]# cp -r /var/lib/mysql /root/mysql.bak
                 ]# tar -zcvf /root/mysql.tar.gz /var/lib/mysql/*
                 ]# scp -r /root/mysql.bak root@192.168.4.51:/opt/
          物理恢复 192.168.4.51
                netstat -plunt |grep :3306
                systemctl stop mysqld
                rm -rf /var/lib/mysql
                cp -r /opt/mysql.bak /var/lib/mysql
                chown -R mysql:mysql /var/lib/mysql
                ls -ld /var/lib/mysql
                ls -l /var/lib/mysql
                systemctl start mysqld
                netstat -plunt |grep :3306
                mysql -uroot -p123456
                mysql> show databases;
      192.168.4.51主机没有MySQL 提前安装:
[student@room9pc01 ~]$ scp -r /linux-soft/03/mysql/mysql-5.7.17.tar root@192.168.4.51:/root
[root@mys ~]# tar -xf mysql-5.7.17.tar
[root@mys ~]# yum -y install mysql-community-*.rpm
[root@mys ~]# systemctl start mysqld
[root@mys ~]# systemctl enable mysqld

          逻辑备份 : 使用软件自带的备份程序(备份命令)对数据做备份,在执行备份命令时,会根据已有的数据生成对应的命令,把命令存放到指定的备份文件里.恢复时,执行备份文件里的命令恢复数据.
          
   2.3 数据备份策略 ?
           完全备份 : 备份所有数据( 1张表,1个库,1 台服务器的所有数据,)
           只备份新数据 :
           增量备份 : 备份上次备份后,所有新产生的数据. (只备份新产生的数据)
           差异备份 : 备份完全备份后,所有新产生的数据.(每次备份时与完全备份比较,备份除完全备份外的所有数据)
           
                  文件  备份文件                                             
周一  完全备份    10    10                                                
周二  差异备份    20    20                        
周三  差异备份    3     23                          
周四  差异备份    5     28                          
周五  差异备份    1     29                          
周六  差异备份    2     31                          
周日  差异备份    3     34                         
    

                  文件  备份文件                                             
周一  完全备份    10    10                                                
周二  增量备份    20    20                        
周三  增量备份    3     3                          
周四  增量备份    5     5                          
周五  增量备份    1     1                          
周六  增量备份    2     2                          
周日  增量备份    3     3                         
   

逻辑备份
    2.4 完全备份------mysqldump命令
          备份命令格式
          ]# mysqldump -uroot -p密码 库名 > 目录/xxx.sql  (目录要提前创建,文件不需要)
            库名的表示方式 :
            --all-databases 或( -A )   //所有库
               数据库名                       //单个库  db3
               数据库名  表名                 //单张表 db3 user
               -B 数据库1  数据库2       //多个库 -B db1 db2 db3 
          恢复命令格式
          ]# mysql -uroot -p密码 库名 < 目录/xxx.sql

           什么时候不需要写库名,当备份文件上有建库的命令的时候
              ]# mysql -uroot -p密码  < 目录/all.sql(all是50主机上全部的备份文件)
当目标服务器上有和备份文件一样的库名的时候,服务器会先删除目标服务器的同名的数据库然后在恢复数据




备份 192.168.4.50
 mkdir /mybak
 mysqldump -uroot -p123456 -A > /mybak/sdm.sql
 mysqldump -uroot -p123456 db1 > /mybak/sdm1.sql
 cat /mybak/sdm1.sql
 mysqldump -uroot -p123456 db3 t1 > /mybak/sdm1_t1.sql
 mysqldump -uroot -p123456 db1 db3 > /mybak/mydb.sql
 ls /mybak/
 [root@host50 ~]# mysqldump -uroot -p123456 db4 > /mybak/db4.sql
 [root@host50 ~]#scp /mybak/db4.sql root@192.168.4.51:/root


   2.5 完全恢复------mysql命令
恢复  192.168.4.51 (逻辑恢复)

[root@host51 ~]#ls /root/db4.sql
mysql -uroot -p123456
mysql> drop database db1;
mysql> show databases;
mysql> exit;
]# mysql -uroot -p123456 db1 < /root/db4.sql
]#  mysql -uroot -p123456
mysql> show databases;




3 数据增量备份(使用mysql服务的binlog日志实现数据的增量备份与恢复)

什么是binlog日志?
在数据库记录除查询之外的所有SQL命令的日志文件.

     3.1  binlog日志的使用
          3.1.1 binlog日志介绍
                 ------ 也称做 二进制日志
             ----MySQL服务日志文件的一种
                 ------记录除查询之外的所有SQL命令
                 ------可用于数据备份和恢复
                 ------配置MySQL主从同步的必要条件
             3.1.2 启用binlog日志
                  vim /etc/my.cnf
                    [mysqld]
                   server_id=50       //指定id值
                    log_bin           //启用binlog日志
                     :wq  
                   systemctl restart mysqld 
[root@host50 ~]# mysql -uroot -p123456
mysql> show master status;  ////查看日志文件
mysql> exit
[root@host50 ~]# ls /var/lib/mysql/
[root@host50 ~]# ls /var/lib/mysql/host50
/var/lib/mysql/host50-bin.000001  /var/lib/mysql/host50-bin.index
[root@host50 ~]# cat /var/lib/mysql/host50-bin.index 
./host50-bin.000001
                  自定义日志存储目录和日志文件名
vim /etc/my.cnf
[mysqld]
server_id=50
log_bin=/mylog/sdm
:wq

[root@host50 ~]# mkdir /mylog
[root@host50 ~]# chown mysql /mylog
[root@host50 ~]#systemctl restart mysqld
[root@host50 ~]#mysql -uroot -p123456
mysql> show master status;       //查看日志文件


配置项                               用 途
server_id=数字               指定id值(1~255)
log_bin[=目录/文件名]      启用binlog日志 
max_binlog_size=数值m     指定日志文件容量,默认是1G


             3.1.3 手动创建新的binlog日志文件
a.重启数据库就会重新生成日志文件,(systemctl restart mysqld)  //此命令实际生产中少用(重启时需要时间,在此期间客户端无法访问)
b.在mysql> flush logs;  //刷新一次产生一个行的日志文件
c.]# mysql -uroot -p123456 -e "show databases "  //加 -e(mysql的选项) 在命令行下执行SQL命令
   ]# mysql -uroot -p123456 -e "flush logs" 
   ]# mysql -uroot -p123456 -e "show master status"
d.mysqldump -uroot -p123456 --flush-logs db2 > /mybak/db2.sql     //对db2库里的数据进行完全备份后生成新的日志文件 [-B db1 db2] -B 指定多个数据库

备份时备份几个库就会产生几个日志文件
当有多个日志文件的时候,且没有超过1G的时候,新产生的日志会存在最新的日志里(数字最大的日志)

             3.1.4 删除已有的binlog日志
                    a. 删除指定编号之前的binlog日志文件
                     mysql> system  ls /mylog;        //查看当前已有的日志文件
                     mysql> purge master logs to "sdm.000004";   //删除sdm.000004日志之前的所有日志
                     mysql> system  cat /mylog/sdm.index;  //查看索引文件,索引文件与日志文件同步一致
               
                     b.删除所有binlog日志,重建新日志
                     mysql> reset master;    

                     c.[root@host50 ~]# rm -rf /logdir/*      //同时删除日志文件和索引文件(索引文件与日志文件同步 )
                     
             3.1.5 查看binlog日志内容
                       3.1.5.1  查看binlog日志内容
                                 ]# mysqlbinlog  目录/binlog日志文件名

mysql> show master status;  //查看日志文件
[root@host50 ~]#ls /var/lib/mysql/
host50-bin.000001  host50-bin.index



mysql> insert into db2.t2(name,age,class)values("sdm",33,"nsd1907");
mysql> insert into db2.t2(name,age,class)values("yxx",25,"null");
mysql> insert into db2.t2(name,age,class)values("tc",23,null);
mysql> show master status;   //插入内容时日志文件 偏移量(编号) 会变化
mysql> select count(*) from t2;   //查看时日志文件 偏移量(编号) 不会变化
]# mysqlbinlog /mylog/sdm.000001
                      

                       3.1.5.2 使用binlog日志恢复数据
                              2.1  命令格式   mysqlbinlog  日志文件 | mysql -uroot -p密码
                              2.2 使用日志恢复数据练习
192.168.4.50:
[root@host50 ~]# ls /logdir      //存放日志的目录
[root@host50 ~]# mysqldump -uroot -p123456  db2 > /root/db2.sql  //将db2库完全备份
[root@host50 ~]# mysql -uroot -p123456         //db2库添加新的数据
            mysql> reset master;
            mysql> show master status; 
            mysql>create table db2.tea(name char(10));
            mysql>insert into db2.tea values("bob");
            mysql>insert into db2.tea values("tom"); 
            mysql>show master status;
            mysql>select * from db2.tea;

[root@host50 ~]#scp /root/db2.sql root@192.168.4.51:/root          //db2库完全备份数据传给51主机
[root@host50 ~]#scp /logdir/plj.000001 root@192.168.4.51:/root     //db2库新增的数据都记录在日志里,将该日志传给51主机

192.168.4.51:
[root@host51 ~]# mysql -uroot -p123456
            mysql> drop database db2;
            mysql> create database db2;
            mysql >exit 
[root@host51 ~]# mysql -uroot -p123456 db2 < /root/db2.sql
[root@host51 ~]# mysqlbinlog /root/plj.000001 |mysql -uroot -p123456
            mysql> use db2;
            mysql> show tables;



      3.2 使用binlog日志恢复指定范围内的数据
                    3.2.1  修改日志格式

[root@host50 ~]# vim /etc/my.cnf
[mysqld]
server_id=50
log_bin=/mylog/sdm
binlog_format="mixed"           // 1.statement 报表模式 2.row 行模式 3. mixed 混合模式
[root@host50 ~]# systemctl restart mysqld
[root@host50 ~]# mysql -uroot -p123456 

查看日志当前记录模式:                                               
mysql> show variables like "%binlog%";
mysql> show variables like "%binlog_format%";
| Variable_name | Value |
+---------------+-------+
| binlog_format | ROW   |
+---------------+-------+
1 row in set (0.00 sec)

mysql> reset master;   //重新加载日志文件
mysql> show master status;;  //查看日志文件
mysql> insert into db2.t2(name)values("sdm1111");
mysql> show master status;;  //查看日志文件
mysql> exit
[root@host50 ~]# mysqlbinlog /mylog/sdm.000001 |grep -i insert
insert into t2(name)values("sdm1111")

mysql> delete from db2.t2 where name="sdm1111";
[root@host50 ~]# mysqlbinlog /mylog/sdm.000001 |grep -i delete

                    3.2.2  日志文件如何区分记录的多条sql命令
                                  偏移量
                                  时间点
                    3.2.1 命令格式
                     ]# mysqlbinlog 选项 目录/日志文件名 |mysql -uroot -p密码
                            偏移量
                   --start-position=1054  --stop-position=2098
                            时间点
                   --start-datetime="yyyy-mm-dd hh:mm:ss"  --stop-datetime="yyyy-mm-dd hh:mm:ss"

                    3.2.2 使用日志恢复数据练习
[root@host50 ~]# scp /mylog/sdm.000001 root@192.168.4.51:/opt
[root@host51 ~]# mysqlbinlog /opt/sdm.000001   //查看日志没有加选项 从头看到尾
[root@host51 ~]# mysqlbinlog --start-position=296 --stop-position=438 /opt/sdm.000001 |mysql -uroot -p123456     

//注意如果选项只指了起始时间(或偏移量)没有指结束时间(或偏移量)的话,就会默认读到日志文件的末尾
注意如果选项只指了结束时间(或偏移量)没有指开始时间(或偏移量)的话,就会默认从头开始读日志文件
如果都没有指定时间或偏移量的话,就是恢复整个日志文件(mysqlbinlog  日志文件 | mysql -uroot -p密码)

[root@host51 ~]# mysql -uroot -p123456 -e "select name from db2.t1 "


###################################################################
date 5
 
常用的MySQL备份工具
   ---物理备份缺点
          1 跨平台性差
          2 备份时间长,冗余备份,浪费存储空间
   ---逻辑备份mysqldump备份缺点
          1 效率较低,备份和还原速度慢,锁表
          2 备份过程中,数据插入和更新操作被阻塞 
 
XtraBackup工具?
  ----一款强大的在线热备份工具
       ---备份过程中不锁库表,适合生产环境
       ---由专业组织Percona提供(改进MySQL分支)
  ----主要含2个组件
       ----xtraBackup:C程序,支持InnoDB/XtraDB
      ------innobackupex : 以Perl脚本封装XtraBackup,还支持MyISAM

1,   percona软件介绍
     1.1 percona软件介绍
       1.2 安装软件  192.168.4.50   192.168.4.51
[student@room9pc01 ~]$ scp /linux-soft/03/mysql/percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm root@192.168.4.50:/root/
[student@room9pc01 ~]$ scp /linux-soft/03/mysql/libev-4.15-1.el6.rf.x86_64.rpm root@192.168.4.50:/root/
[root@host50 ~]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm
[root@host50 ~]# yum -y install  percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm
[root@host50 ~]# rpm -qa |grep percona          //查看percona软件是否安装
[root@host50 ~]# rpm -ql percona-xtrabackup-24  //查看安装位置列表
 /usr/bin/innobackupex
/usr/bin/xbcloud
/usr/bin/xbcloud_osenv
/usr/bin/xbcrypt
/usr/bin/xbstream
/usr/bin/xtrabackup
......
[root@host50 ~]# innobackupex --help
[root@host50 ~]# man innobackupex

       1.3 命令格式
           ]# innobackupex <选项>
               命令常用选项:
                 --host                       主机名
                 --user                       用户名
                 --port                       端口号
                 --password                   密码
                 --databases                  数据库
                 --no-timestamp               不用日期命名备份文件存储的子目录名 
                 --redo-only                  日志合并
                 --apply-log                  准备恢复数据
                 --copy-back                  拷贝数据
                 --incremental 目录名             增量备份
                 --incremental-basedir=目录名   增量备份时,指定上一次备份数据存储的目录名
                 --incremental-dir=目录名        准备恢复数据时,指定增量备份数据存储的目录名
                 --export                     导出表信息
                   import                     导入表空间


               完全备份/恢复命令格式 
                         完全备份
]# innobackupex --user 用户名  --password 密码 备份目录名   //此命令可以创建目录
 eg: [root@host51 ~]# innobackupex --user root --password 123456 /allbak


                         完全恢复
]# innobackupex --apply-log 目录名    //准备恢复数据
]# innobackupex  --copy-back 目录名   //恢复数据

             
                      增量备份
]# innobackupex --user 用户名 --password 密码 --incremental 增量目录 --incremental-basedir=目录名 --no-timestamp
                      增量恢复
]# innobackupex --apply-log --redo-only 目录名 --incremental-dir=目录名 //准备恢复数据
   192.168.4.50 完全备份
[root@host51 ~]# rm -rf /allbak   //删除之前的备份
[root@host50 ~]# innobackupex --user root --password 123456 /allbak --no-timestamp  //完全备份
[root@host50 ~]# scp -r /allbak/ root@192.168.4.51:/root           //拷贝给51主机

     2    恢复数据,步骤如下 :
           1 停止数据库服务器
           2 清空数据库目录
           3 准备恢复数据
           4 拷贝数据
           5 修改数据库目录的所有者和组用户为MySQL
           6 启动服务
           7 管理员登录查看数据

  192.168.4.51 完全恢复
[student@room9pc01 ~]$scp /linux-soft/03/mysql/percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm root@192.168.4.51:/root/
[student@room9pc01 ~]$scp /linux-soft/03/mysql/libev-4.15-1.el6.rf.x86_64.rpm root@192.168.4.51:/root/

[root@host50 ~]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm
[root@host50 ~]# yum -y install  percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm 
[root@host51 ~]# systemctl stop mysqld      //停止数据库服务器
[root@host51 ~]# rm -rf /var/lib/mysql/*    //清空数据库目录
[root@host51 ~]# ls /var/lib/mysql/         //查看数据库目录
[root@host51 ~]# innobackupex --apply-log /root/allbak     //准备恢复数据
[root@host51 ~]# innobackupex --copy-back /root/allbak     //拷贝数据
[root@host51 ~]# ls -l /var/lib/mysql                      //查看数据库目录的属性权限
[root@host51 ~]# chown -R mysql:mysql /var/lib/mysql       //修改数据库目录的所有者和组用户为MySQL
[root@host51 ~]# systemctl start mysqld                    //启动服务
[root@host51 ~]# netstat -plunt |grep mysqld               //查看mysqld 服务端口号
[root@host51 ~]# mysql -uroot -p123456     //50主机数据库的密码登录
mysql> show databases;
mysql> select * from db5.a;

      在完全备份文件里,恢复单张表命令格式 ; 具体步骤如下 :
                    1 删除表空间   mysql> alter table 库.表名 discard tablespace;  (.ibd)
                    2 导出表信息   [root@host51 ~]# innobackupex --apply-log --export /root/allbak(数据完全备份目录)
                    3 拷贝表信息文件到数据库目录下
                  [root@host51 ~]# cp /root/allbak/db5/b.{cfg,exp,ibd} /var/lib/mysql/db5

                    4 修改表信息文件的所有者及组用户为MySQL
                  [root@host51 ~]# chown -R mysql:mysql /var/lib/mysql/db5/b.*

                    5 导入表空间   mysql> alter table 库名.表名 import tablespace;
                  mysql> alter table db5.b import tablespace;
                    6 删除数据库目录下的表信息文件(必须删除信息文件,否则对db5库操作时有问题)
                 [root@host51 ~]# rm -rf /var/lib/mysql/db5/b.{cfg,exp}
                    7 查看表记录
                  mysql> select * from db5.b;

  *表a的表结构存放在(/var/lib/mysql/db5/)a.frm里
  *表a的表空间存放在(/var/lib/mysql/db5/)a.ibd里 存储数据的文件
  *表a的表信息存放在(/var/lib/mysql/db5/)a.cfg里  
例子: 
[root@host51 ~]# mysql -uroot -p123456
mysql> use db5;
mysql> show tables;
mysql> select * from a;
mysql> select * from b;
mysql> delete from b;
mysql> select * from b;     //在51主机上提前删除b表所有内容,模拟一张表里数据丢失

恢复数据
[root@host51 ~]# mysql -uroot -p123456
mysql> alter table db5.b discard tablespace;
mysql> exit
[root@host51 ~]# innobackupex --apply-log --export /root/allbak
[root@host51 ~]# ls /root/allbak/db5/
[root@host51 ~]# cp /root/allbak/db5/b.{cfg,exp,ibd} /var/lib/mysql/db5
[root@host51 ~]# chown -R mysql:mysql /var/lib/mysql/db5/b.*
[root@host51 ~]# mysql -uroot -p123456
mysql> alter table db5.b import tablespace;
mysql> exit
[root@host51 ~]# rm -rf /var/lib/mysql/db5/b.cfg
[root@host51 ~]# rm -rf /var/lib/mysql/db5/b.exp 
[root@host51 ~]# mysql -uroot -p123456
mysql> select * from db5.b;


               增量备份/恢复命令格式



2,   innobackupex备份与恢复
               完全备份/恢复练习
               恢复单张表练习
               增量备份/恢复练习

             增量备份:备份上次备份后,所有新产生的数据

             增量备份/恢复练习
192.168.4.50
             首次备份 : 做完全备份
             ]# ls /allbak
             ]# cat /allbak/xtrabackup_checkpoints  // 当前备份文件的备份数据信息
                       backup_type = full-backuped  //显示完全备份类型
mysql> insert into db5.a values(344);
mysql> insert into db5.b values("sdm");
mysql> select count(*) from b;
mysql> select count(*) from a;
                增量备份
[root@host50 ~]# innobackupex --user root --password 123456 --incremental /new1dir --incremental-basedir=/allbak --no-timestamp
[root@host50 ~]# ls /new1dir
                  新插入数据
mysql> insert into db5.a values(344);
mysql> insert into db5.b values("sdm");
mysql> select count(*) from b;
mysql> select count(*) from a;
[root@host50 ~]# innobackupex --user root --password 123456 --incremental /new2dir --incremental-basedir=/new1dir --no-timestamp 
[root@host50 ~]# ls /new2dir
[root@host50 ~]# cat /allbak/xtrabackup_checkpoints
                  backup_type = full-backuped     //完全备份
                  from_lsn = 0                   //日志信息序列号
 [root@host50 ~]# scp -r /allbak root@192.168.4.51:/opt
 [root@host50 ~]# scp -r /new1dir root@192.168.4.51:/opt
 [root@host50 ~]# scp -r /new2dir root@192.168.4.51:/opt

                         恢复数据   192.168.4.51
[root@host51 ~]# innobackupex --apply-log --redo-only /opt/allbak   //恢复完全备份日志信息
[root@host51 ~]# cat /opt/allbak/xtrabackup_checkpoints backup_type = log-applied     // 完全恢复(完全备份变成 日志追加)
[root@host51 ~]# innobackupex --apply-log --redo-only /opt/allbak/ --incremental-dir=/opt/new1dir  // 恢复增量
[root@host51 ~]# innobackupex --apply-log --redo-only /opt/allbak/ --incremental-dir=/opt/new2dir  // 恢复增量

[root@host51 ~]# cat /opt/allbak/xtrabackup_checkpoints 
[root@host51 ~]# systemctl stop mysqld
[root@host51 ~]# rm -rf /var/lib/mysql
[root@host51 ~]# innobackupex --copy-back /opt/allbak/
[root@host51 ~]# ls /var/lib/mysql
[root@host51 ~]# chown -R mysql:mysql /var/lib/mysql
[root@host51 ~]# systemctl start mysqld
[root@host51 ~]# netstat -plunt |grep :3306
[root@host51 ~]# mysql -uroot -p123456
mysql> select * from db5.a;
mysql> select * from db5.b;


################################################################################################

  
DBA2_DAY01
一、MySQL 主从同步
1.1、什么是MySQL 主从同步 ： 实现数据自动同步的服务结构，结构中分为2种角色
			      主服务器：接收客户端访问的数据库服务器  (主服务器必须启binlog日志)
			      从服务器：自动从主库服务器同步数据到本机的数据库服务器()
主从同步的作用:
1.可以通过主从复制的方式来同步数据，然后通过读写分离提升数据库的并发处理能力。
2.数据备份,具有高可用性


 构建思路:
1.配置主服务器
   启用binlog日志,授权用户,查看binlog日志信息
2.配置从服务器
  a.设置server_id
  b. 确保与主机服务器数据一致
  c. 指定主库信息
  d. 启动slave程序
  e.查看状态信息
  


在Linux系统中，使用RPM方式安装MySQL-5.6数据库时，随机生成的
管理密码默认记录在 /root/.mysql_secret 文件内

1.2、MySQL 主从同步工作原理:
       主服务器binlog线程: 它记录了对数据库进行更新的事件
	IO线程 负责到主服务器的binlog日志里拷贝SQL命令到从服务器里的中继日志文件(relay-log),中继日志自动创建
	SQL线程 执行中继日志文件里的SQL命令,写到本机数据库里

1.3、配置MySQL 主从同步
	1.3.1 服务器角色
   		192.168.4.50 客户端（client）
   		192.168.4.51 主（master） 运行数据库服务器 管理员root 本机能够登陆
   		192.168.4.52 从 (slave)   运行数据库服务器 管理员root 本机能够登陆


配置主从服务器的步骤:

	1.3.2 配置主服务器 192.168.4.51
		1 启用binlog日志文件
			]# vim /etc/my.cnf			
				[mysqld]
				server_id=51            //指定服务器id
				log-bin=master51        //指定binlog日志文件
			:wq
			]# systemctl  restart mysqld

			]# ls /var/lib/mysql/master51.*
			]# mysql -uroot -pabc123 -e "show master status"

		2 用户授权
			]# mysql -uroot -p密码
			mysql> grant  replication slave on *.*  to  
				repluser@"%" identified  by "123qqq...A";      //仅授予复制SQL命令的权限

		3 产看binlog日志信息
			mysql> show master status;  
                      | master51.000001 |      441 |   
            
	1.3.3 配置从服务器 192.168.4.52
		1 指定server_id
			]# vim /etc/my.cnf
			[mysqld]
			server_id=52
			:wq
			]# systemctl  restart mysqld


         确保与主机服务器数据一致,在主服务器上:
     [root@host51 ~]# mysqldump -uroot -p123456 --master-data db5 > /root/db5.sql     // 备份主服务器上的数据,--master-data 记录当前备份数据对应的日志信息
     [root@host51 ~]# scp /root/db5.sql root@192.168.4.52:/root
         在从服务器52上:
     mysql> create database db5;
     [root@host52 ~]# mysql -uroot -p123qqq...A db5 < /root/db5.sql 
     [root@host52 ~]# mysql -uroot -p123qqq...A
     mysql> show tables;


		2 指定主服务器信息,在52从服务器上做(mysql> show master status;查看状态)
			]# mysql -uroot -p密码
			mysql> change master to  
				master_host="192.168.4.51" ,        //主库IP地址
				master_user="repluser",             //主库授权用户
    				master_password="123qqq...A",       //授权用户密码
				master_log_file="master51.000001",  //主库日志文件
				master_log_pos=441;                 //日志偏移量

master信息会自动保存到/var/lib/mysql/master.info 文件
排错 : 确保环境和主服务器没有错   后stop slave  在change ...  在start slave
Slave_IO_Running:Connecting
Last_IO_Error:此处提示报错信息   ----->mysql>stop slave;  ---->mysql>change master;.......>start slave; ------>show slave status \G;


还原:------------>将以下4个文件删除后重启服务, 即可还原成普通数据库服务器 
master.info               主库信息
relay-log.info            中继日志信息文件
主机名-relay-bin.xxxxxx     中继日志文件
主机名-relay-bin.index      索引文件




		3 启动slave 进程	
				mysql> start slave;
		4 查看进程信息
				mysql> show slave status\G;        //查看slave状态
                               Master_Host: 192.168.4.51    //主库IP地址
					Slave_IO_Running: Yes        //IO线程已运行
            		      Slave_SQL_Running: Yes       //SQL线程已运行  这2项必须同时都是yes,否则就错误

	从库相关文件cd /var/lib/mysql/
				master.info
				主机名-relay-bin.编号
				主机名-relay-bin.index
				relay-log.info

1.4、验证配置
	1  在主服务器添加访问数据的连接用户
		mysql> create database db7;
		mysql> grant all on db7.*  to webuser@"%" identified by "123qqq...A";

	2  在客户端连接主服务器 对数据做操作
		]# mysql -h192.168.4.51 -uwebuser -p123qqq...A
		mysql> show grants;
		mysql> use db7;
		mysql> create table db7.t1(id int);
		mysql>  insert into db7.t1 values(10101);		

	3  在从服务器本机查看是否和主服务器的数据一致。
		]# mysql -uroot  -p密码
	    mysql> select  * from  db7.t1;
		


二、MySQL主从同步模式
2.1 MySQL 主从同步结构模式
	一主一从
	一主多从  给当前主服务器51 再配置1台 从数据库服务器53
		  1 在服务器53 上运行mysql服务且管理员能够本机登陆
		  2 在没有配置为从服务器之前，要有主服务器上数据
			51]# mysqldump -uroot -pabc123  db7  > /root/db7.sql   //主服务器备份数据
			51]# scp  /root/db7.sql  root@192.168.4.53:/root/      //拷贝给从服务器53
			
			53mysql> create database db7;         在从服务器创建库      
			53mysql> use db7;
			53mysql> source /root/db7.sql

		  3 设置主机53的server_id
			]# vim /etc/my.cnf
				[msyqld]
				server_id=53
			:wq
			]# systemctl restart mysqld
		  4 指定主服务器信息,在从服务器53上操作
			]# mysql -h192.168.4.51 -urepluser -p123qqq...A
		    mysql> exit
			]# mysql -uroot -p123qqq...A
			mysql> change master to  
			        master_host="192.168.4.51",
				master_user="repluser",
    				master_password="123qqq...A",
				master_log_file="master51.000001",
    				master_log_pos=2072;
		  5启动slave进程
			mysql> start slave;
		  6 查看进程信息
			mysql> show slave status\G;
				Slave_IO_Running: Yes
            		Slave_SQL_Running: Yes
		  7 客户端测试
			1 在客户端50主机连接主数据库服务访问数据
				]# mysql -h192.168.4.51 -uwebuser -p123qqq...A
				mysql> insert into  db7.t1 values(888);
				mysql> create table db7.t2(name char(10));
				mysql>  insert into db7.t2 values("bob");
				mysql>  select  * from db7.t1;
				mysql>  select  * from db7.t2;
				
			2 分别在2台从服务器本机查看数据（可以看到和主服务器一样的数据）
				]#mysql -uroot -p密码
				mysql>  select  * from db7.t1;
                         mysql>  select  * from db7.t2;
 
   主从从      给当前的从服务器52 ，配置1台从服务器192.168.4.54
	   一:	1 配置52
			1.1 启用binlog日志
			    ]#vim /etc/my.cnf
				[msyqld]
				log-bin=master52
				log_slave_updates     //允许级联复制
				:wq
			    ]# systemctl restart mysqld
			    ]# mysql -uroot  -p密码
			    mysql> show slave status\G;

			1.2 用户授权
			    mysql> grant replication slave on  *.* to repluser@"%" 
				   identified by  "123qqq...A";

			1.3 查看binlog日志信息
			    mysql> show master status;	
							 
		2配置54
			52]# mysqldump -uroot -p123qqq...A  db7 > /root/db7.sql
			52]# scp /root/db7.sql  192.168.4.54:/root/
			54：
				2.0 使用备份文件恢复数据
					mysql> create database db7;
					mysql> use db7;
					mysql> source /root/db7.sql
		
				2.1 指定server_id
					]# vim /etc/my.cnf
					[mysqld]
					server_id=54
					:wq
					]# systemctl  restart mysqld

				2.2 指定主服务器信息
					]#mysql -h192.168.4.52 -urepluser -p123qqq...A
					mysql> exit
					]#mysql -uroot -p123qqq...A
					mysql> change master to 
						master_host="192.168.4.52",
						master_user="repluser",
						master_password="123qqq...A",
						master_log_file="master52.000001",
						master_log_pos=441;
				2.3 启动slave 进程
					mysql> start slave;
				2.4 查看进程信息
					mysql> show slave status\G;
						slave_IO_Running: Yes
						Slave_SQL_Running: Yes
		

		3测试配置    
			3.1 在客户端连接主服务器51 存数据
				host50 ~]# mysql -h192.168.4.51 -uwebuser -p123qqq...A
				MYSQL> insert into db7.t1 values(8989);

			3.2 在从服务器52 和 54 主机上都可以到和主服务器一样的数据
			mysql54 ~]# mysql -uroot -p123qqq...A -e "select  * from  db7.t1;"
			mysql52 ~]# mysql -uroot -p123qqq...A -e "select  * from  db7.t1;"

  二:数据库服务器53和54和55都没有其它数据,53主54从55从(54是55的主)------->主从从结构
  1. 53上配置:如果有数据就删除4个文件
       rm -rf master.info 
       rm -rf relay-log.info 
       rm -rf host53-relay-bin.*
       systemctl restart mysqld
       mysql -uroot -p123qqq...A
       vim /etc/my.cnf
           [mysqld]
            server_id=53
            log-bin=master53
       systemctl restart mysqld
       mysql -uroot -p123qqq...A
       mysql> show master status;
+-----------------+----------+--------------+------------------+-------------------+
| File            | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-----------------+----------+--------------+------------------+-------------------+
| master53.000001 |      441 |              |                  |                   |

  2.54上配置:  53为54的主,54为55的主
       vim /etc/my.cnf
          [mysqld]
          server_id=54             //指定服务器id
          log-bin=master54         //指定binlog日志文件
          log_slave_updates        //允许级联复制

       systemctl restart mysqld
       mysql -uroot -p123qqq...A
       mysql> grant replication slave on *.* to repluser@"%" identified by "123qqq...A";
       mysql> change master to      
               master_host="192.168.4.53",
               master_user="repluser",
               master_password="123qqq...A",
               master_log_file="master53.000001",
               master_log_pos=441;
               mysql> start slave;
               mysql> show slave status\G;
                   
               mysql> show master status;
+-----------------+----------+--------------+------------------+-------------------+
| File            | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-----------------+----------+--------------+------------------+-------------------+
| master54.000001 |      441 |              |                  |                   |


    3.55上配置从服务器:
    vim /etc/my.cnf
      [mysqld]
         server_id=55
    systemctl restart mysqld
    mysql -uroot -p123qqq...A
     mysql> change master to
             master_host="192.168.4.54",
             master_user="repluser",
             master_password="123qqq...A",
             master_log_file="master54.000001",
             master_log_pos=441;
             mysql> start slave;
             mysql> show slave status\G;

验证:在53服务器上创建授权用户:.............
mysql> grant all on gamedb.* to yaya88@"%" identified by "123qqq...A";
在50上
[root@host50 ~]# mysql -h192.168.4.53 -uyaya88 -p123qqq...A
mysql> create database gamedb;
mysql> insert into gamedb.t1 values(100);
在53,54数据库上都有   gamedb库新插入的数据

 
	主主结构 把数据库服务器55 和 56 配置为主主结构------>在55上配置55为主56为从,在56上配置56为主55为从

[root@host55 ~]# cat /var/lib/mysql/auto.cnf      //存放服务器UUID的文件
[auto]
server-uuid=233b218a-ee7e-11e9-bf48-525400051e16

2.2 MySQL主从同步复制模式 
	异步复制模式?    主库执行完一次事务后,立即将结果返给客户端,并不关心从库是否已经接受并处理
	全同步复制模式?  当主库执行完一次事务后,且所有从库都执行了该事务后才将结果返回给客户端
	半同步复制模式?   介于上2个之间,主库在执行完一次事务后,等待至少一个从库接受到并写到relay log(中继日志)中才将结果返回给客户端

   案例：修改数据库服务器52 的半同步复制模式
	步骤：
		1 查看是否允许动态加载模块
	        mysql> show  variables  like  'have_dynamic_loading';

		2 加载模块
		  mysql> INSTALL PLUGIN rpl_semi_sync_master SONAME "semisync_master.so";
		  mysql> INSTALL PLUGIN rpl_semi_sync_slave SONAME  "semisync_slave.so";
 

		3 查看加载信息
			mysql> SELECT  PLUGIN_NAME, PLUGIN_STATUS FROM INFORMATION_SCHEMA.PLUGINS  WHERE PLUGIN_NAME LIKE '%semi%';

		4启用模块
			mysql> SET GLOBAL rpl_semi_sync_master_enabled = 1;
			mysql> SET GLOBAL rpl_semi_sync_slave_enabled = 1;

		5 查看启用信息
			mysql> show  variables  like  'rpl_semi_sync_%_enabled';

		6 修改配置文件使其配置永久生效
			]# vim /etc/my.cnf
			[mysqld]
plugin-load = "rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
rpl-semi-sync-master-enabled = 1        //主服务器
rpl-semi-sync-slave-enabled = 1         //从服务器
:wq


2.3 MySQL主从同步常用配置选项（/etc/my.cnf）
	2.3.1 应用在主服务器的配置选项
		binlog_do_db=数据库名   //只允许同步的库
		binlog_ignore_db=数据库名 //不允许同步的库

	2.3.2 应用在从服务器的配置选项
		log_slave_updates //记录从库更新，允许链式复制
		replicate_do_db=数据库名 //仅同步的库
		replicate_ignore_db=数据库名 //只不同步的库
		relay_log=日志名 //自定义中继日志文件名
	


#################################################################################################



+++++++++++++++++++DBA2_DAY02
一、MySQL数据读写分离: 客户端访问数据的查询请求和写请求分别给不同的数据库服务器处理  
			查询    select			A数据库服务器 slave
			写	insert  update  delete	B数据库服务器 master

	为什么要数据读写分离？ 减轻单台数据库服务器的并发访问压力
			       提高机器硬件的利用率

	如何实现数据读写分离？ 通过程序实现（让程序员写代码实现）
			       通过安装软件提供的服务实现（中间件）
				Mycat  mysql-proxy   Maxscale  ....

	配置数据读写分离？(Maxscale + mysql一主一从同步)

				client50

			   	Maxscale (57主机) 代理软件------->由MYSQL的兄弟公司mariadb开发
                              下载地址:
                               https://downloads.mariadb.com/files/maxscale
		                   rpm -ivh  maxscale-2.1.2-1.rhel.7.x86_64.rpm
                       /etc/maxscale.cnf         // 主配置文件
                       /etc/maxscale.modules.d/   //加载模块配置文件
                       /etc/maxscale.cnf.template  //主配置文件模板文件
                       /var/log/maxscale/maxscale.log          //日志文件目录

             帮助文档:https://github.com/mariadb-corporation/MaxScale/blob/2.1/Documentation/Doc    umentation-Contents.md
                 https://github.com/mariadb-corporation/MaxScale/blob/2.1/Documentation/Get    ting-Started/Configuration-Guide.md

		mysql-server51(写)    mysql-server52(读)	
			Master		 slave

       配置步骤：
		1 部署mysql一主一从同步结构  
			1.1 配置主服务器51 ，具体配置如下：
					启用binlog日志 用户授权 查看binlog日志信息

			1.2 配置从服务器52 ，具体配置如下：
			      指定server_id  指定主服务器信息 启动slave进程 查看程序信息

		2 配置数据读写分离服务器57 
			2.1 拷贝软件包 到 57 主机
			]# scp /linux-soft/03/mysql/maxscale-2.1.2-1.rhel.7.x86_64.rpm  root@192.168.4.57:/root/

			2.2 安装软件
				]# rpm -ivh maxscale-2.1.2-1.rhel.7.x86_64.rpm 

			2.3 修改配置文件
				]# vim  /etc/maxscale.cnf
					 9 [maxscale]
 					10 threads=auto            //线程数量默认是1,auto是自动获取

					18 [server1]              //数据库服务器的名称
 					19 type=server            //
 					20 address=192.168.4.51    //数据库服务器的IP地址
 					21 port=3306                //数据库服务器的端口号
 					22 protocol=MySQLBackend    //
 
 					24 [server2]
 					25 type=server
 					26 address=192.168.4.52
 					27 port=3306
 					28 protocol=MySQLBackend


 35 [MySQL Monitor]               //名称(监视mysql)----->监视数据库服务器
 36 type=monitor
 37 module=mysqlmon
 38 servers=server1,server2      //监视server1,server2
 39 user=maxscalemon             //监视server1,server2的用户
 40 passwd=123qqq...A            //监视server1,server2的密码
 41 monitor_interval=10000

 52 #[Read-Only Service]         //提供只读服务
 53 #type=service
 54 #router=readconnroute
 55 #servers=server1
 56 #user=myuser
 57 #passwd=mypwd
 58 #router_options=slave

 63 [Read-Write Service]         //提供读写服务
 64 type=service
 65 router=readwritesplit          //读写服务调用的程序
 66 servers=server1,server2        //读写服务在server1,server2之间进行
 67 user=maxscalerouter            //代理服务器连接server1,server2的用户名
 68 passwd=123qqq...A              //代理服务器连接server1,server2的密码
 69 max_slave_connections=100%

 75 [MaxAdmin Service]          //Maxscale管理服务
 76 type=service                //管理方式
 77 router=cli
 
 85 #[Read-Only Listener]       //只读服务监听端口
 86 #type=listener
 87 #service=Read-Only Service
 88 #protocol=MySQLClient
 89 #port=4008

 91 [Read-Write Listener]        //读写分离服务的端口
 92 type=listener
 93 service=Read-Write Service
 94 protocol=MySQLClient
 95 port=4006

 97 [MaxAdmin Listener]          //Maxscale服务管理的端口
 98 type=listener
 99 service=MaxAdmin Service
100 protocol=maxscaled
101 socket=default
102 port=4016

如果配置文件写错,改完之后kill-9 maxscale 
[root@host57 ~]# maxscale -f /etc/maxscale.cnf


                        

			2.4 用户授权(根据配置文件的设置在2台数据库服务器上添加对应的用户)
				监控用户(有复制权限)
				mysql> grant replication slave,  replication client  
					on *.* to 
		       			scalemon@"%" identified by "123qqq...A";

                         replication slave   //监视主从服务器
                         replication client  //监控数据库服务的状态

				路由用户
				mysql> grant  select on mysql.* to 
				       maxscalerouter@"%" identified by "123qqq...A";

				查看用户
				mysql> select user,host from mysql.user where user in ("maxscalemon","maxscalerouter");
		            或者:			
                        [root@host52 ~]#mysql -uroot -p123qqq...A -e "select user,host from mysql.user where user like '%maxscale%'"
			2.5 启动服务（192.168.4.57）
				2.5.1 验证授权用户
					]# yum -y  install mariadb
					]# mysql -h192.168.4.51 -umaxscalemon -p123qqq...A
   					]# mysql -h192.168.4.52 -umaxscalemon -p123qqq...A
   					]# mysql -h192.168.4.51 -umaxscalerouter -p123qqq...A
   					]# mysql -h192.168.4.52 -umaxscalerouter -p123qqq...A

				2.5.2 启动服务
					]# maxscale -f /etc/maxscale.cnf
					]# ps -C maxscale
					]# netstat -utnlp  | grep maxscale
                                      如果配置文件写错,就
					]# killall -9 maxscale
					]# maxscale -f /etc/maxscale.cnf
		
		3 测试配置
			3.1 查看管理信息（在主机57 本机自己访问自己）
[root@host57 ~]# maxadmin  -uadmin -pmariadb -P4016
MaxScale> list servers
Servers.
-------------------+-----------------+-------+-------------+--------------------
Server             | Address         | Port  | Connections | Status              
-------------------+-----------------+-------+-------------+--------------------
server1            | 192.168.4.51    |  3306 |           0 | Master, Running
server2            | 192.168.4.52    |  3306 |           0 | Slave, Running
-------------------+-----------------+-------+-------------+--------------------
				

			3.2 测试数据读写分离 （客户端连接192.168.4.57 访问数据）
				3.2.1 在主数据库服务器上添加访问数据的用户(51主机)
					mysql> create database db8;
					mysql> create table db8.t1(id int);
					mysql> grant select,insert on  db8.* 
						to  yaya8@"%" identified by "123qqq...A";

				3.2.2 客户端50 ,连接57主机访问数据，测试数据读写分离
				]#mysql -h192.168.4.57 -P4006 -uyaya8 -p123qqq...A				
				mysql> select  * from db8.t1;
				mysql> insert into db8.t1 values(111);
				mysql> insert into db8.t1 values(222);
				mysql> exit
                               在52从服务器上gamedb.t1里写入数据,51主服务器不会有52写入的数据,当客户端50访问查看时可以看到52从服务器上新写入的数据,由此可以看出50客户机访问代理,代理实现数据读写分离,写入的数据存入51主服务器,查看的数据来自52从服务器.
		            mysql52 ~]# mysql -uroot -p密码  -e "insert into db8.t1 values(52)"

				]#mysql -h192.168.4.57 -P4006 -uyaya8 -p123qqq...A
				mysql> select  * from db8.t1;
				mysql> insert into db8.t1 values(333);

		mysql51 ~]# mysql -uroot -p密码 -e "show master status"

		 

二、MySQL多实例 （192.168.4.50）克隆一台新的虚拟机 eth0 192.168.4.58
		2.1 什么是多实例？ 在1台物理服务器上运行多个数据库服务

		2.2 为什么要使用多实例? 节约运维成本、提高硬件利用率

             每个实例要有独立的 : 数据库目录,端口,socket文件,pid文件,err错误日志文件



		2.3 配置多实例
			1 安装软件 
				]#tar -zxvf mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz
           [root@host58 ~]# yum -y install libaio
           [root@host58 ~]# grep mysql /etc/passwd
                         ]#useradd mysql
				]# mv mysql-5.7.20-linux-glibc2.12-x86_64 /usr/local/mysql
           [root@host58 ~]# PATH=/usr/local/mysql/bin/:$PATH
           [root@host58 ~]# vim /etc/bashrc 
                                 末行添加变量:export PATH=/usr/local/mysql/bin:$PATH
				]# cd /usr/local/mysql
				 
                     /var/lib/mysql/mysql.sock 套接字文件--------->传替数据的文件,服务器自己访问自己的时候传替数据,数据不出本机

			2 修改服务的主配置文件
				]#  systemctl stop  mysqld
				]#  systemctl disable  mysqld
				]#  mv /etc/my.cnf /root/  //此文件要重新写

	 			root@host58]# vim /etc/my.cnf
				[mysqld_multi]                                //定义多实例服务参数
				mysqld=/usr/local/mysql/bin/mysqld_safe       //指定进程文件路径,启用多实例服务就调用次程序,
				mysqladmin=/usr/local/mysql/bin/mysqladmin    //指定管理命令路径,修改数据库管理员密码
				user=root                                     //指定进程用户,操作系统的管理员用户

				[mysqld1]                                   //实例1
				datadir=/dir1                               //数据库目录,要手动创建,启动后初始存放目录
				port=3307                                   //端口
				log-error=/dir1/mysql3307.log               //错误日志文件位置
				pid-file=/dir1/mysql3307.pid                //进程PID号文件位置
				socket=/dir1/mysql3307.sock                 //指定sock文件的路径和名称

				[mysqld2]
				datadir=/dir2
				port=3308
				log-error=/dir2/mysql3308.log
				pid-file=/dir2/mysql3308.pid
				socket=/dir2/mysql3308.sock
				:wq

				]# mkdir /dir1
				]# mkdir /dir2
					
			3 启动服务

       注意::::  /usr/local/mysql/bin/ 已经存入$PATH里,后面敲命令时不需要加这个路径

	]# /usr/local/mysql/bin/mysqld_multi  start 1   ----->获取密码: xyuF?Q#l7<U&

	]# /usr/local/mysql/bin/mysql -uroot -p'xyuF?Q#l7<U&' -S  /dir1/mysql3307.sock     //注意:进入数据库后修改密码,此时数据库没有密码策略
	mysql> alter user root@"localhost" identified by "123456";
	mysql> show databases;
	mysql> exit
	
       ]# /usr/local/mysql/bin/mysql -uroot -p123456 -S  /dir1/mysql3307.sock			 mysql>
                   
       ]# /usr/local/mysql/bin/mysqld_multi  start 2   //启动编号是2 的 服务 ----->获取密码:xyuF?Q#l7<U&

        ]# /usr/local/mysql/bin/mysql -uroot -p'xyuF?Q#l7<U&' -S  /dir2/mysql3308.sock
        mysql> alter user root@"localhost" identified by "123456";
        mysql> show databases;
        mysql> exit

          退出后用新密码登录
        [root@localhost ~]# mysql -uroot -p123456 -S /dir1/mysql3307.sock
 

       ]# /usr/local/mysql/bin/mysql -uroot -p123456 -S  /dir2/mysql3308.sock
       mysql> 

      ]# netstat -utnlp  | grep  -i mysqld

			停止服务
	]# /usr/local/mysql/bin/mysqld_multi  --user=root --password=123456  stop 1
	]# /usr/local/mysql/bin/mysqld_multi  --user=root --password=123456  stop 2
	]# netstat -utnlp  | grep  -i  mysqld
	 

在一台数据库服务器上配置多台虚拟数据库也可以配置主从同步:
    在/etc/my.cnf里
主: 
server_id=3307
log_bin=master3307
从:
server_id=3308
 
然后在主服务器添加用户授权grant  replication slave on *.*  to repluser@"%" identified  by "123qqq...A"; 
     从服务器里change master to 时多加一项master_port=3307(主的端口号)





		2.4 验证配置
			2.4.1 访问多实例服务，对数据做操作
                 在

三、MySQL性能调优
	3.1 升级硬件 （cpu  内存  存储） 运维部
	3.2 优化数据库服务运行参数
	3.3 让程序员优化访问数据的sql命令
	3.4 网络带宽
	3.5 优化服务架构（网络架构是否有数据传输瓶颈）


	3.2 优化数据库服务运行参数
		mysql> show variables;
		mysql> show variables like "%关键字%";
		mysql> show variables like "%timeout%";
		mysql> show variables like "connect_timeout";

		mysql> set 【global] 变量名=值;
		mysql> set global connect_timeout=5;

		]# vim /etc/my.cnf
		[mysqld]
	  	 变量名=值
		:wq

		mysql> show status;
		mysql> show status like "%connect%";
		mysql> show status like "Connections";



	常用设置参数：

修改/etc/my.cnf在[mysqld]下添加以下内容


1. max_connections	 允许的最大并发连接数
      Mysql的最大连接数，如果服务器的并发请求量比较大，可以调高这个值，当然这是要建立在机器能够支撑的情况下，因为如果连接 数越来越多，mysql会为每个连接提供缓冲区，就会开销的越多的内存，所以需要适当的调整该值，不能随便去提高设值
      Max_connections=1024    //设置最大连接数为1024
		mysql>  show status like "Max_used_connections";

		最大并发连接/最大并发连接数 = 0.85 x  100% = 85%
		Max_used_connections/max_connections=0.85
2. back_log
        
3.wait_timeout和interactive_timeout
    interactive_timeoutz：指的是mysql在关闭一个交互的连接之前所需要等待的秒数
    wait_timeout 等待关闭连接的不活动超时秒数
 		connect_timeout	 等待连接超时，默认10秒，仅登录时有效
		

4.key_buffer_size	 用于MyISAM引擎的关键索引缓存大小

5.query_cache_size（查询缓存简称QC）
   
6.max_connect_errors
    是一个mysql中与安全有关的计数器值，它负责阻止过多尝试失败的客户端以防止暴力破解密码等情况，当超过指定次数，mysql服务器将禁止host的连接请求，直到mysql服务器重启或通过flush hosts命令清空此host的相关信息 max_connect_errors的值与性能并无太大关系。 eg : max_connect_errors=20

7.sort_buffer_size
     为每个要排序的线程分配此大小的缓存空间
  read_buffer_size   
     为顺序读取表记录保留的缓存大小
  table_open_cache
     为所有线程缓存的打开的表的数量

8.max_allowed_packet=32M
     mysql根据配置文件会限制，server接受的数据包大小。有时候大的插入和更新会受max_allowed_packet参数限制，导致写入或者更新失败，更大值是1GB，必须设置1024的倍数

9.join_buffer_size=2M
用于表间关联缓存的大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享

10.thread_cache_size=300	
      允许保存在缓存中被重用的线程数量

11.innodb_buffer_pool_size
     InnoDB使用该参数指定大小的内存来缓冲数据和索引

12. innodb_flush_log_at_trx_commit
     主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个
      0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的ACID；设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。

13.innodb_thread_concurrency = 0			 
    此参数用来设置innodb线程的并发数量，默认值为0表示不限制			 

14.innodb_log_buffer_size
    此参数确定些日志文件所用的内存大小，以M为单位
   
15. innodb_log_file_size = 50M

    此参数确定数据日志文件的大小，以M为单位，更大的设置可以提高性能.

16. innodb_log_files_in_group = 3

     为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3

17.read_buffer_size = 1M
      MySql 读入缓冲区大小
			 
18.read_rnd_buffer_size = 16M
      MySql 的随机读（查询操作）缓冲区大小

19.bulk_insert_buffer_size = 64M
      批量插入数据缓存大小，可以有效提高插入效率，默认为8M


	SQL查询优化
		优化服务查询缓存
			数据服务处理查询请求的过程?
			查看与查询缓存相关的变量
			show variables like  "query_cache%";
 			query_cache_size
			query_cache_type  oFF

			查看当前的查询缓存统计
			mysql> show  global status like  "qcache%";
				Qcache_hits      0
				Qcache_inserts   0
		 

		优化程序员优化访问数据的sql命令   
			查询日志: 记录在服务器上执行的所有命令
				]# vim /etc/my.cnf
					[mysqld]
					general-log
				:wq
				]# systemctl restart mysqld

				]#ls /var/lib/mysql/主机名.log

				]# tail -f /var/lib/mysql/mysql51.log	
				mysql> 执行的命令都会记录在mysql51.log 文件里

			慢查询日志:记录在服务器上执行的
			   	   录耗时较长或不使用索引select命令
				]# vim /etc/my.cnf
                			[mysqld]
					slow-query-log
					long-query-time=5
					log-queries-not-using-indexes
				:wq
				]#systemctl restart mysqld
				]# ls /var/lib/mysql/主机名-slow.log
				]# cat /var/lib/mysql/mysql51-slow.log
				]# tail -f /var/lib/mysql/mysql51-slow.log
		mysql> select  sleep(11);
		mysql> select  sleep(3);
		mysql> select user,host from mysql.user;
		]# mysqldumpslow /var/lib/mysql/mysql51-slow.log > /tmp/sql.txt
		]# vim /tmp/sql.txt



###################################################################################

++++++++++++++++++++ DAB2_DAY03  数据分片存储
一、什么是分库分表？ 
1.分库/分表:  将存放在一台数据库服务器中的数据,按照特定方式进行拆分,分散存放到多台数据库服务器中,以达到分散单台服务器负载的效果.

二、数据分片方式？
1.水平分割:  (横向切分)  按照表中指定字段的分片规则,将表记录按行切分,分散存储到多个数据库中
2.垂直分割:  (纵向切分)  将单个数据库的多个表按业务类型分类,分散存储到不同的数据库中

三、配置数据分片

mycat是基于Java的分布式数据库系统中间件,为高并发环境的分布式存储提供解决方案
   1.适合数据大量写入的存储需求
   2.支持MYSQL,Oracle,Sqlserver,Mongodb等
   3.提供数据读写分离服务
   4.提供数据分片服务
   5.基于阿里巴巴Cobar进行研发的开源软件

mycat支持提供10种分片规则
1.枚举法   sharding-by-intfile
2.固定分片  rule1
3.范围约定   auto-sharding-long
4.求模法   mod-long
5.日期列分区发   sharding-by-date
6.通配取模     sharding-by-pattern
7.ASCII码求模通配    sharding-by-prefixpattern
8.编码指定      sharding-by-substring
9.字符串拆分hash解析      sharding-by-stringhash
10.一致性hash     sharding-by-murmur

mycat 工作过程:
当mycat收到一个SQL命令时 1.解析SQL命令涉及到的表
                             2.然后看表的配置,如果有分片规则,则获取SQL命令里分片字段的值,并匹配分片函数,获得分片列表
                            3.然后将SQL命令发往对应的分片服务器去执行
                             4.最后收集和处理所有分片结果数据,并返回到客户端

ls /usr/local/mycat/
-bin      //mycat命令
-catlet   //扩展功能
-conf     //配置文件
-lib      //mycat使用的jar包
-logs      //mycat启动日志和运行日志
-wrapper.log  //mycat服务启动日志
-mycat.log    //记录SQL脚本执行后的报错内容


	3.1 环境准备
	3.2 配置mycat服务器 ---192.168.4.56
		3.2.1 配置分片服务器（192.168.4.56）
			1 装包
                    [student@room9pc01 mysql]$ scp Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz root@192.168.4.56:/root
                    [root@host56 ~]# yum list |grep openjdk
                    [root@host56 ~]# yum -y install java-1.8.0-openjdk.x86_64

		        [root@mycat56 ~]# which java
				           /usr/bin/java
                    [root@mycat56 ~]# java -version
                                    openjdk version "1.8.0_131"
                                    OpenJDK Runtime Environment (build 1.8.0_131-b12)
                                    OpenJDK 64-Bit Server VM (build 25.131-b12, mixed mode)
                    [root@host56 ~]# tar -zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz   //免安装,解压即可使用
                    [root@mycat56 ~]# mv mycat/ /usr/local/

                    [root@mycat56 ~]# rpm -qa | grep  -i  openjdk
                           java-1.8.0-openjdk-1.8.0.131-11.b12.el7.x86_64
                           java-1.8.0-openjdk-headless-1.8.0.131-11.b12.el7.x86_64
                    [root@mycat56 ~]#

	]#tar -zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz
	]#mv mycat /usr/local/

[root@mycat56 ~]# ls /usr/local/mycat/
bin  catlet  conf  lib  logs  version.txt   
[root@mycat56 ~]# ls /usr/local/mycat/logs/
                         wrapper.log   mycat.log


                          
			2 目录结构      
                conf/*.txt 分片规则对应函数的配置文件
                conf/*.properties 分片规则对应函数的配置文件
			3 配置文件说明
				rule.xml   分片规则文件
				schema.xml 配置数据分片 
				server.xml 设置连接账号及逻辑库
                             
			4 修改配置文件
				4.1  设置连账号
				]# vim /usr/local/mycat/conf/server.xml  
                               开启行号:
             80:<user name="root">                               //访问分片服务器时的用户
                  <property name="password">123456</property>      //密码是123456
                  <property name="schemas">TESTDB</property>        //显示逻辑库(默认虚拟库名)
                </user>					

               <user name="user">
                   <property name="password">user</property>
                   <property name="schemas">TESTDB</property>
                   <property name="readOnly">true</property>
                </user>
               :wq
				4.2  配置数据分片
         ]# cp  /usr/local/mycat/conf/schema.xml  /root/         //备份配置数据分片文件
         ]# sed  -i  '56,77d' /usr/local/mycat/conf/schema.xml
         ]# sed  -i  '39,42d' /usr/local/mycat/conf/schema.xml
         ]# sed  -i  '16,18d' /usr/local/mycat/conf/schema.xml
         ]# sed  -i  '45,47d' /usr/local/mycat/conf/schema.xml 
         ]# sed  -i  '43d' /usr/local/mycat/conf/schema.xml
         ]# cat /usr/local/mycat/conf/schema.xml |wc -l
                    44
         ]# vim  /usr/local/mycat/conf/schema.xml   ------>文件格式标签:
                  <mtcat....>
                       <schema ...>                 //定义分片信息   
                             <table>...</table>      //定义表名
                             <table.../>
                       </schema>
                       <dataNode  ..... />           //指定数据节点名
                       <dataHost....>                //数据库服务器主机名(ip)
                              <heartbeat>select user()</heartbeat>
                              <writeHost...>
                              </writeHost>  
                       </dataHost>
                   </mycat>
定义分片的表:
<schema ...>         </schema>        //定义分片信息 
<table>...</table>      //定义表名
name              //逻辑库名或逻辑表名
<dataNode  ..... />           //指定数据节点名
rule                          //指定使用的分片规则
type=global                   //数据不分片存储

定义数据节点:
 <dataNode  选项=值,..... />           //指定数据节点名
 name    //数据节点名
 datahost  //数据库服务器主机名
 database  //数据库名

定义数据库服务器IP地址及端口:
<dataHost  选项=值,....>                //数据库服务器主机名(ip)
name   //主机名(与datahost对应的主机名)
host   //主机名(与IP地址对应的主机名)
url    //数据库服务器IP地址及端口号
user   //数据库服务器授权用户
password //授权用户密码



                 修改schema.xml文件:   set nu 
               1.  7:dataNode="dn1,dn2,dn3" 12,16,18行里dataNode=""里没有dn3的加上dn3 --->数据节点
                    2.  33,34,35 修改主机名: <dataNode name="dn1" dataHost="mysql53" database="db1" />
                                    <dataNode name="dn1" dataHost="mysql54" database="db1" /> 
                                    <dataNode name="dn1" dataHost="mysql55" database="db1" />
                
                   3.   定义数据库服务器三台  分别指定主机名,IP,密码,授权用户等信息

            <dataHost name="mysql53" maxCon="1000" minCon="10" balance="0"
 37                           writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
 38                 <heartbeat>select user()</heartbeat>
 39                 <!-- can have multi write hosts -->
 40                 <writeHost host="hostM1" url="192.168.4.53:3306" user="plj"
 41                                    password="123qqq...A">
 42                         <!-- can have multi read hosts -->
 43                 </writeHost>
 44         </dataHost>

          <dataHost name="mysql54" maxCon="1000" minCon="10" balance="0"
 37                           writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
 38                 <heartbeat>select user()</heartbeat>
 39                 <!-- can have multi write hosts -->
 40                 <writeHost host="hostM1" url="192.168.4.54:3306" user="plj"
 41                                    password="123qqq...A">
 42                         <!-- can have multi read hosts -->
 43                 </writeHost>
 44         </dataHost>

          <dataHost name="mysql55" maxCon="1000" minCon="10" balance="0"
 37                           writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
 38                 <heartbeat>select user()</heartbeat>
 39                 <!-- can have multi write hosts -->
 40                 <writeHost host="hostM1" url="192.168.4.55:3306" user="plj"
 41                                    password="123qqq...A">
 42                         <!-- can have multi read hosts -->
 43                 </writeHost>
 44         </dataHost>






		3.2.2 配置数据库服务器（192.168.4.53/54/55）
			1 创建存储数据的库
			53mysql> create database db1;
			54mysql> create database db2;
			55mysql> create database db3;

			2 用户授权
			53mysql> grant  all  on  *.*  to plj@"%" 
			         identified by "123qqq...A";

			54mysql> grant  all  on  *.*  to plj@"%"
                                 identified by "123qqq...A";

			55mysql> grant  all  on  *.*  to plj@"%"
                                 identified by "123qqq...A";

	3.3 启动服务 ---192.168.4.56
		]# /usr/local/mycat/bin/mycat start
		]# netstat -utnlp  | grep  :8066


	3.4 客户端测试--192.168.4.50

    [root@host50 ~]# mysql -h192.168.4.56 -P8066 -uroot -p123456

           mysql> show databases;
                  +----------+
              | DATABASE |
                  +----------+
              | TESTDB   |
                  +----------+
           mysql> use TESTDB;
           mysql> show tables;
+------------------+
| Tables in TESTDB |
+------------------+
| company          |
| customer         |
| customer_addr    |
| employee         |
| goods            |
| hotnews          |
| orders           |
| order_items      |
| travelrecord     |
+------------------+

 
	3.5 添加新库/新表
	客户端连接分片服务器存取数据:
           - 连接
           - 选择库
           - 建表
           - 插入记录

    1.枚举法   sharding-by-intfile   ----->字段值必须在列举范围内选择
           vim /usr/local/mycat/conf/partition-hash-int.txt
                         10000=0   //数据存储到dn1库里
                         10010=1   // 数据存储到dn2库里              
                         10020=2   //数据存储到dn3库里
 
                          启服务:  先stop  后start
                     /usr/local/mycat/bin/mycat  stop
                     /usr/local/mycat/bin/mycat  start

	[root@host50 ~]# mysql -h192.168.4.56 -P8066 -uroot -p123456
                    mysql> use TESTDB;
                    mysql> show tables;
                    mysql> create table employee(ID int primary key auto_increment,sharding_id int,name char(10),sex enum("m","w"));
                    mysql> desc employee;
                    mysql> insert into employee(sharding_id,name) values(10000,"bob");
                             Query OK, 1 row affected (0.06 sec)

                    mysql> insert into employee(sharding_id,name) values(10010,"tom");
                             Query OK, 1 row affected (0.03 sec)

                    mysql> insert into employee(sharding_id,name) values(10020,"yohn");
                             Query OK, 1 row affected (0.02 sec)
                    分别查看53,54,55服务器:

                       [root@host53 ~]# mysql -uroot -p123qqq...A -e "use db1;select * from employee"
+----+-------------+------+------+
| ID | sharding_id | name | sex  |
+----+-------------+------+------+
|  1 |       10000 | bob  | NULL |
+----+-------------+------+------+


   2.求模法   mod-long  ---->根据字段值与设定的数字求模结果存储数据
    
                    vim schema.xml
           14   <table name="hotnews"  dataNode="dn1,dn2,dn3"   //删除primaryKey=""ID" autoIncrement="True"
                    vim rule.xml  //查看要有id字段

                        
                          启服务:  先stop  后start
                     /usr/local/mycat/bin/mycat  stop
                     /usr/local/mycat/bin/mycat  start

 38         <tableRule name="mod-long">
 39                 <rule>
 40                         <columns>id</columns>
 41                         <algorithm>mod-long</algorithm>
 42                 </rule>
 43         </tableRule>
             
         在50客户端:建表
[root@host50 ~]# mysql -h192.168.4.56 -P8066 -uroot -p123456
mysql> use TESTDB;
mysql> create table hotnews(id int,title char(20),worker char(15),comment varchar(50),fb_time timestamp);
mysql> desc hotnews;
                     
分别在53,54,55服务器上查看:
[root@host53 ~]# mysql -uroot -p123qqq...A -e "use db1;show tables;"
+---------------+
| Tables_in_db1 |
+---------------+
| employee      |
| hotnews       |
+---------------+
在客户端50上插入数据:(字段必须要加)
mysql> insert into hotnews(id,title,worker,comment,fb_time) values(3,"linux","nb","user mangemnt",now());  //id值=3与服务器的数量3取余为0就存入dn1数据库(对应53服务器),为1就存入dn2数据库(对应54服务器),为2就存入dn3数据库(对应55服务器)
[root@host53 ~]# mysql -uroot -p123qqq...A -e "use db1;select * from db1.hotnews"   //在数据库53上查看


   3.不分片存储(或全局存储) :(所有数据库都存入)--------->type="global"

    vim /usr/local/mycat/conf/schema.xml    //不要修改
           <table name="company" primaryKey="ID" type="global" dataNode="dn1,dn2,dn3" />

  在客户端50上创建新表:
   [root@host50 ~]# mysql -h192.168.4.56 -P8066 -uroot -p123456
   mysql> create table company(ID int primary key auto_increment,gname char(10),money int,people char(10),gaddr char(50));
   mysql> desc company;
   mysql> insert into company(gname,money,people,gaddr) values("tedu",1000000000,"sdm","shanghai");
   mysql> insert into company(gname,money,people,gaddr) values("tmooc",1000000000,"sdm","shanghai");
   mysql> insert into company(gname,money,people,gaddr) values("NFA",1000000000,"sdm","shanghai");


  在服务器53,54,55上都能查出表记录:
  [root@host53 ~]# mysql -uroot -p123qqq...A -e "use db1;select * from db1.company"
+----+-------+------------+--------+----------+
| ID | gname | money      | people | gaddr    |
+----+-------+------------+--------+----------+
|  1 | tedu  | 1000000000 | sdm    | shanghai |
|  2 | tmooc | 1000000000 | sdm    | shanghai |
|  3 | NFA   | 1000000000 | sdm    | shanghai |
+----+-------+------------+--------+----------+

添加新库新表: 在56上做

vim /usr/local/mycat/conf/server.xml
 82   <property name="schemas">TESTDB,BBSDB</property>    //添加新库BBSDB  用root用户连接时可以看到新库BBSDB
 97   <property name="schemas">TESTDB,BBSDB</property>

vim /usr/local/mycat/conf/schema.xml         //新添加库和表---->新添加schema定义数据库,在里面添加table定义表
     <schema name="BBSDB" checkSQLschema="false" sqlMaxLimit="100">
              <table name="hotnews2"  dataNode="dn1,dn2,dn3" rule="mod-long" />
              <table name="employee2" primaryKey="ID" dataNode="dn1,dn2,dn3" rule="sharding-by-intfile" />
     </schema>
重启服务:
[root@host56 conf]# /usr/local/mycat/bin/mycat stop
[root@host56 conf]# /usr/local/mycat/bin/mycat start
[root@host56 conf]# ss -plunt |grep :8066


在客户端50上验证:
[root@host50 ~]# mysql -h192.168.4.56 -P8066 -uroot -p123456
mysql> show databases;
mysql> use BBSDB;
mysql> show tables;
+-----------------+
| employee2       |   ------>
| hotnews2        |   ------>  虚拟表
+-----------------+

求模法存储
mysql> insert into hotnews2(id,title) values(7,"A"),(8,"B"),(9,"C");  //注意:字段也要加上
在服务器上分别查看  求模后余数0--->dn1(53主机),1--->dn2(54主机),2--->dn3(55主机)



########################################################################################

+++++DBA2_DAY04++++++++++++
部署mysql集群 使用“MHA软件+mysql主从同步” 实现 

一、什么是集群？ 多台服务器提供相同的服务（网站  数据库）
二、集群分类？ LB(负载均衡集群)    HA(高可用集群)   HPC(高性能)
三、为什么要使用集群？
四、配置集群？ 安装软件提供服务实现 （LVS  haproxy  nginx  keepalived）

五、部署MySQL高可用集群----->MHA
	5.2  MHA介绍？
       是一套优秀的实现MYSQL高可用的解决方案,数据库的自动故障切换能做到在0~30秒之内完成,MHA能确保在故障切换过程中最大限度保证数据的一致性,以达到真正意义上的高可用

MHA Manager (管理节点)
--管理所有数据库服务器
--可以单独部署在一台独立的机器上
--也可以部署在某台数据库服务器上

MHA Node (数据节点)
--存储数据的MYSQL服务器
--运行在每台MYSQL服务器上

MHA工作过程
由Manager(管理器)定时探测集群中的master节点,当master故障时,Manager自动将拥有最新数据的slave服务器提升为新的master



	5.1、MHA集群环境准备51,52,53数据库集群,57管理主机,50客户端,vip地址192.168.4.100
student@room9pc01 ~]$ scp -r /linux-soft/03/mysql/mha-soft-student root@192.168.4.57:/root
student@room9pc01 ~]$ scp -r /linux-soft/03/mysql/mha-soft-student root@192.168.4.51:/root
student@room9pc01 ~]$ scp -r /linux-soft/03/mysql/mha-soft-student root@192.168.4.52:/root
student@room9pc01 ~]$ scp -r /linux-soft/03/mysql/mha-soft-student root@192.168.4.53:/root		 
		 
             在57主机上配置:
			]# cd mha-soft-student
			]# yum -y install mha4mysql-node-0.56-0.el6.noarch.rpm    //必须先装此包
			]# tar -zxvf mha4mysql-manager-0.56.tar.gz
			]# cd mha4mysql-manager-0.56
                   ]# yum -y install perl-ExtUtils-*
                   ]# yum -y install perl-CPAN*
			]# perl Makefile.PL           //运行脚本

*** Module::AutoInstall version 1.03
*** Checking for Perl dependencies...
[Core Features]
- DBI                   ...loaded. (1.627)
- DBD::mysql            ...loaded. (4.023)
- Time::HiRes           ...loaded. (1.9725)
- Config::Tiny          ...loaded. (2.14)
- Log::Dispatch         ...loaded. (2.41)
- Parallel::ForkManager ...loaded. (1.18)
- MHA::NodeConst        ...loaded. (0.56)
*** Module::AutoInstall configuration finished.
Checking if your kit is complete...
Looks good
Writing Makefile for mha4mysql::manager
Writing MYMETA.yml and MYMETA.json

			]# make && make install
在57上配置秘钥,给51,52,53,实现57无密码连接51,52,53
ssh-keygen -f /root/.ssh/id_rsa -N ''      //创建密钥对
ssh-copy-id root@192.168.4.51              //拷贝公钥给目标主机
ssh-copy-id root@192.168.4.52
ssh-copy-id root@192.168.4.53              //拷贝公钥给目标主机
51,52,53无密码互联
ssh-keygen -f /root/.ssh/id_rsa -N ''   
for i in 52 53 ; do ssh-copy-id root@192.168.4.$i ; done	 

ssh-keygen -f /root/.ssh/id_rsa -N ''   
for i in 51 53 ; do ssh-copy-id root@192.168.4.$i ; done	

ssh-keygen -f /root/.ssh/id_rsa -N ''   
for i in 51 52 ; do ssh-copy-id root@192.168.4.$i ; done	

 
		51-55 恢复为独立的数据库服务器
		]# cd mha-soft-student
		]# rpm -ivh mha4mysql-node-0.56-0.el6.noarch.rpm

二、配置MHA集群
	2.1  配置mysql主从同步 (一主多从）
		2.1.1、配置主服务器51
			]# vim /etc/my.cnf
				[mysqld]
				server_id=51
				log-bin=master51
				plugin-load = "rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
				rpl-semi-sync-master-enabled = 1
				rpl-semi-sync-slave-enabled = 1
				relay_log_purge=off

			:wq
			]# systemctl restart mysqld

			]# mysql -uroot -p密码
			mysql> grant replication slave on  *.* to plj@"%" 
				identified by "123qqq...A";

			mysql> show master status;
			mysql> set  global  relay_log_purge=off; 

		2.1.2、配置从服务器52（备用主库）
			]# vim /etc/my.cnf	
				[mysqld]
                                server_id=52
                                log-bin=master52
                                plugin-load = "rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
                                rpl-semi-sync-master-enabled = 1
                                rpl-semi-sync-slave-enabled = 1
                                relay_log_purge=off
                        :wq
			]# systemctl  restart mysqld
			[root@mysql52 ~]# mysqll -uroot -p密码

			mysql> change master to master_host="192.168.4.51",master_user="plj",master_password="123qqq...A",master_log_file="master51.000001",master_log_pos=436;
Query OK, 0 rows affected, 2 warnings (0.28 sec)

			mysql> start slave;
				Query OK, 0 rows affected (0.02 sec)

			mysql> show slave status\G;
				Master_Host: 192.168.4.51
				Slave_IO_Running: Yes
        			Slave_SQL_Running: Yes

		2.1.3、配置从服务器53（备用主库）
			]# vim  /etc/my.cnf
			[mysqld]
server_id=53
log-bin=master53
plugin-load = "rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
rpl-semi-sync-master-enabled = 1
rpl-semi-sync-slave-enabled = 1

relay_log_purge=off
:wq
			]# systemctl  restart mysqld
			]# mysql -uroot  -p密码

			mysql> change master to master_host="192.168.4.51",master_user="plj",master_password="123qqq...A",master_log_file="master51.000001",master_log_pos=436;

                        mysql> start slave;
                                Query OK, 0 rows affected (0.02 sec)
                        mysql> show slave status\G;
                                Master_Host: 192.168.4.51
                                Slave_IO_Running: Yes
                                Slave_SQL_Running: Yes

		2.1.4、配置从服务器54（纯从库）
			]# vim /etc/my.cnf   
[mysqld]
server_id=54
plugin-load = "rpl_semi_sync_slave=semisync_slave.so"
rpl-semi-sync-slave-enabled = 1
relay_log_purge=off

			]# systemctl restart mysqld
			]# mysql -uroot -p密码
mysql> change master to master_host="192.168.4.51",master_user="plj",master_password="123qqq...A",master_log_file="master51.000001",master_log_pos=436;
			mysql> start slave;
			mysql> show slave status\G;
 



	2.2 配置管理主机192.168.4.57
		2.2.1  编写配置文件
			]# mkdir /etc/mha 
			]# cd mha4mysql-manager-0.56
			]# cp samples/conf/app1.cnf  /etc/mha/
			]# vim  /etc/mha/app1.cnf
[server default]    //管理服务的默认配置
manager_workdir=/etc/mha   //工作目录
manager_log=/etc/mha/manager.log   //日志文件
master_ip_failover_script=/etc/mha/master_ip_failover   //故障切换脚本
ssh_user=root            //访问ssh的服务用户
ssh_port=22              //ssh服务端口
repl_user=repluser       //主服务器数据同步授权用户
repl_password=123qqq...A  //授权密码
user=root                 //监控用户
password=123qqq...A       //监控用户的密码
[server1]                 //指定第1台数据库服务器
hostname=192.168.4.51     //服务器IP地址
candidate_master=1        //竞选主服务器
[server2]                 //指定第2台数据库服务器
hostname=192.168.4.52     //服务器IP地址
candidate_master=1        //竞选主服务器
[server3]
hostname=192.168.4.53
candidate_master=1
 
:wq

		2.2.2  创建故障切换脚本
			]# cd mha-soft-student
			]# cp master_ip_failover  /etc/mha/
			]# vim +35 /etc/mha/master_ip_failover
			   my $vip = '192.168.4.100/24';  # Virtual IP   //60---->100(vip地址)
			:wq
			]# chmod  +x  /etc/mha/master_ip_failover

		2.2.3  把vip地址部署在当前的主库上(192.168.4.51)
			[root@mysql51 ~]# ifconfig  eth0:1 192.168.4.100/24   //临时部署vip地址
			[root@mysql51 ~]# ifconfig  eth0:1
eth0:1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.100  netmask 255.255.255.0  broadcast 192.168.4.255
        ether 74:52:09:07:51:01  txqueuelen 1000  (Ethernet)

			[root@mysql51 ~]# ifconfig  eth0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.51  netmask 255.255.255.0  broadcast 192.168.4.255
        inet6 fe80::5c9:7cc1:9663:574  prefixlen 64  scopeid 0x20<link>
        ether 74:52:09:07:51:01  txqueuelen 1000  (Ethernet)
        RX packets 676632  bytes 1050900208 (1002.2 MiB)
        RX errors 0  dropped 60  overruns 0  frame 0
        TX packets 128153  bytes 31563247 (30.1 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

         在所有数据库服务器上安装mha_node 包
~]# cd mha-soft-student/
]# yum -y install mha4mysql-node-0.56-0.el6.noarch.rpm

         在所有数据库服务器上做授权用户(在51主服务器上执行就可以--->同步其它服务器)
[root@host51 ~]# mysql -uroot -p123456 -e "grant all on *.* to root@'%' identified by '123qqq...A'"   //设置监控用户
[root@host53 ~]#  mysql -uroot -p123qqq...A -e "show grants for root@'%'"        


		2.2.4  用户授权（根据配置文件）
		  2.2.4.1 给从服务器同步数据的连接用户repluser(51/52/53)--->如果51dug了,52,53有可能成为主服务器,所以也要有app1.cnf指定的授权用户
			  52mysql> grant replication slave on *.* to repluser@"%"
				   identified by  "123qqq...A";			
			  53mysql> grant replication slave on *.* to repluser@"%"
				   identified by  "123qqq...A";
			
		  2.2.4.2 管理主机57监视数据库服务器状态的连接用户root(51-53)
			   51mysql> grant all  on *.* to   root@'%'  
				    identified  by  "123qqq...A";

              配置主服务器,修改数据库服务运行参数 ,启用51主机的半同步复制及禁止自动删除中继日志文件和启服务
             vim /etc/my.cnf  ----->51,52,53都要改
plugin-load="rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"  //加载模块
rpl-semi-sync-master-enabled = 1     //启用master模块
rpl-semi-sync-slave-enabled = 1      //启用slave模块
relay_log_purge=0                 //禁止自动删除中继日志文件

[root@host51 ~]# systemctl restart mysqld


    


三、测试配置(192.168.4.56)
	3.1 测试ssh无密码登陆
	[root@host57 ~]# masterha_check_ssh  --conf=/etc/mha/app1.cnf

Wed May 15 17:56:13 2019 - [info] All SSH connection tests passed successfully.

	3.2 测试mysql主从同步
[root@host57 ~]# masterha_check_repl  --conf=/etc/mha/app1.cnf			
MySQL Replication Health is OK.

	3.3 启动管理服务
		host57 ~]# masterha_manager --conf=/etc/mha/app1.cnf \
			   --remove_dead_master_conf  --ignore_last_failover

		host57 ~]# masterha_check_status --conf=/etc/mha/app1.cnf

		host57 ~]# ls /etc/mha 

masterha_check_ssh      //检查MHA的ssh配置状况
masterha_check_repl     //检查MYSQL复制状况
masterha_manager        //启动MHA
masterha_check_status   //检测MHA运行状态
masterha_stop           //停止MHA

	3.4 测试mysql服务高可用
		3.4.1 在主数据库51上添加访问数据的连接用户yaya99  123qqq...A
			mysql> create database db9;
			mysql> create table db9.t1 (id int);
			mysql> grant select ,insert on db9.* to 
				yaya99@"%" identified by "123qqq...A";

		3.4.2 在客户端50 连接vip地址访问数据库服务
			50]# mysql  -h192.168.4.100 -uyaya99  -p123qqq...A
			mysql> insert into  db9.t1 values(100),(200),(300);
			mysql> select  * from  db9.t1;
			在51的所有从服务器上都可以看到同样的数据

		3.4.3 停止主数据库51 的数据库服务，50主机依然可以访问到数据
		       51]# systemctl  stop mysqld

		 
		
		思考：
			1 当前的52 也坏掉的时候 53 会不会 成为主库？
			
			2 如何把坏掉的51 和 52 服务器 再添加到集群里？
				2.1  启动51 和 52 主机的数据库服务
				2.2  把51 和 52 主机 配置为的当前主服务器的从服务器
				2.3  把主机51 和 52 添加app1.cnf文件里
					]#vim /etc/mha_manager/app1.cnf
						[server1]
						candidate_master=1
						hostname=192.168.4.51

						[server2]
						candidate_master=1
						hostname=192.168.4.52
					:wq	
	
				2.4  在主机57上运行管理服务，并查看服务状态
				]# masterha_check_repl --conf=/etc/mha_manager/app1.cnf
				]# masterha_manager --conf=/etc/mha_manager/app1.cnf

配置数据节点总结：
		1安装mha-node软件
		2在主服务器51 主机手动设置vip地址 192.168.4.100
		3添加监控用户root  123qqq...A
		4在从服务器52和53主机添加repluser  123qqq...A
		5在主服务器启用半同步复制模式 禁用自动删除中继日志文件
		6在从服务器52和53 启用半同步复制模式 禁用自动删除中继日志文件并启用binlog日志文件
		7重启mysql服务
		8查看从服务器的状态



#############################################################################################################

++++++++++++DBA2_DAY05++++++++++++++++++++++++++
PXC
环境准备:192.168.4.71,    192.168.4.72,  192.168.4.73

pxc  : 是一套免费开源的高可用集群解决方案
官网 http://galeracluster.com

pxc特点:
1.数据强一致性,无同步延迟
2.没有主从切换操作,无需使用虚拟IP
3.支持innodb存储引擎
4.多线程复制
5.部署使用简单
6.支持节点自动加入,无需手动拷贝数据

服务端口:
3306  数据库服务端口
4444  SST端口--->全量同步
4567  集群通信端口
4568  IST端口--->增量同步
 
操作步骤:

创建3台虚拟机作为pxc服务器
echo -e "192.168.4.71 host71\n192.168.4.72 host72\n192.168.4.73 host73" > /etc/hosts
                    scp /etc/hosts root@192.168.4.72:/etc;
                    scp /etc/hosts root@192.168.4.73:/etc;

在真机上拷贝软件给3台服务器:
scp -r /linux-soft/03/PXC  root@192.168.4.71:/root
scp -r /linux-soft/03/PXC  root@192.168.4.72:/root
scp -r /linux-soft/03/PXC  root@192.168.4.73:/root

分别在3台服务器上安装软件:  注意顺序不要改变有依赖关系
                    rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm;   //依赖包
                    yum -y install percona-xtrabackup-24-2.4.13-1.el7.x86_64.rpm;  //在线热备程序
                    rpm -ivh qpress-1.1-14.11.x86_64.rpm;                 //剃归压缩程序
                    tar -xf Percona-XtraDB-Cluster-5.7.25-31.35-r463-el7-x86_64-bundle.tar;   
                    yum -y install Percona-XtraDB-Cluster-*.rpm           //集群服务程序
查看工作目录:
[root@host71 PXC]# ls /etc/percona-xtradb-cluster.conf.d/
mysqld.cnf           //数据库服务运行参数配置文件
mysqld_safe.cnf      //Percona Server 5.7配置文件 
wsrep.cnf            //PXC集群配置文件



[root@pxcnode71 ~]# vim /etc/percona-xtradb-cluster.conf.d/mysqld.cnf (文件内容解释)
[mysqld]
server-id=71                      //server-id 不允许重复
datadir=/var/lib/mysql                  //数据库目录
socket=/var/lib/mysql/mysql.sock         //socket文件
log-error=/var/log/mysqld.log        //日志文件
pid-file=/var/run/mysqld/mysqld.pid    //pid文件
log-bin                    //启用binlog日志
log_slave_updates            //启用链式复制
expire_logs_days=7            //日志文件保留天数

修改配置文件

修改配置文件:3台都要改
[root@host71 PXC]#vim +7 /etc/percona-xtradb-cluster.conf.d/mysqld.cnf
server-id=1----->改为 server-id=71

[root@host71 PXC]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf 
 8 wsrep_cluster_address=gcomm://192.168.4.71,192.168.4.72,192.168.4.73    //服务器集群列表
25 wsrep_node_address=192.168.4.71             //本机IP地址
 27 wsrep_cluster_name=pxc-cluster   //集群名称,3台必须相同
 30 wsrep_node_name=host71          //本机名称
39 wsrep_sst_auth="sstuser:123qqq...A"       //SST数据同步授权用户


[root@host72 PXC]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf
 8 wsrep_cluster_address=gcomm://192.168.4.71,192.168.4.72,192.168.4.73    //服务器集群列表
25 wsrep_node_address=192.168.4.72             //本机IP地址
 27 wsrep_cluster_name=pxc-cluster   //集群名称
 30 wsrep_node_name=host72         //本机名称
39 wsrep_sst_auth="sstuser:123qqq...A"       //SST数据同步授权用户

[root@host73 PXC]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf
 8 wsrep_cluster_address=gcomm://192.168.4.71,192.168.4.72,192.168.4.73    //服务器集群列表
25 wsrep_node_address=192.168.4.73             //本机IP地址
 27 wsrep_cluster_name=pxc-cluster   //集群名称
 30 wsrep_node_name=host73          //本机名称
39 wsrep_sst_auth="sstuser:123qqq...A"       //SST数据同步授权用户


启动服务:在71上

[root@host71 PXC]#  systemctl  start mysql@bootstrap.service

[root@host71 PXC]# grep root@localhost /var/log/mysqld.log
2019-10-21T02:38:34.357705Z 1 [Note] A temporary password is generated for root@localhost: S4iRXf%94)iQ

[root@host71 PXC]#ss -plunt |grep 3306
tcp    LISTEN     0      80       :::3306                 :::*                   users:(("mysqld",pid=26873,fd=32))
[root@host71 PXC]# ss -plunt |grep 4567
tcp    LISTEN     0      128       *:4567                  *:*                   users:(("mysqld",pid=26873,fd=11))

[root@host71 PXC]#mysqladmin -uroot -p'S4iRXf%94)iQ' password '123456'    //修改初始密码
[root@pxcnode71 ~]#mysql –uroot –p123456 //使用修改后的密码登录
Mysql> garnt reload, lock tables,replication client,process on *.*  to sstuser@"localhost” identified by  “123qqq…A”; //添加授权用户

启动服务:在72上
[root@host72 PXC]# systemctl start mysql
[root@pxcnode72 ~]# netstat -utnlp  | grep :3306
[root@pxcnode72 ~]# netstat -utnlp  | grep :4567

启动服务:在73上
[root@host72 PXC]# systemctl start mysql
[root@pxcnode73 ~]# netstat -utnlp  | grep :3306
[root@pxcnode73 ~]# netstat -utnlp  | grep :4567

mysql> show status like"%wsrep%";    //查看服务器集群信息

在50主机上测试:
在任意一台数据库服务器上添加客户端连接的用户 
[root@host71 PXC]# mysql -uroot -p123456 -e "grant all on *.* to plj@'%' identified by '123456' " //任意一台添加用户
[root@host71 PXC]# mysql -uroot -p123456 -e "show grants for plj@'%'"           //任意一台查看权限

[root@host50 ~]# mysql -h192.168.4.71 -uplj -p123456
[root@host50 ~]# mysql -h192.168.4.72 -uplj -p123456
[root@host50 ~]# mysql -h192.168.4.73 -uplj -p123456




存储引擎
mysql> show create table db10.t1;   //查看建表的命令
mysql> show engines;    //查看引擎
mysql> create table db1.t1(name char(19))engines=innodb;  //engines=指定存储引擎,
[root@host50 ~]# vim /etc/my.cnf  //修改配置文件将默认引擎改为Myisam
default-storage-engine=存储引擎

在生产环境下常用的存储引擎Innodb,Myisam
Myisam特点:大量数据查询操作较优
支持表级锁
不支持事物,事物回滚,外键

表文件:
表名.frm  //表结构
表名.MYI  //索引
表名.MYD  //数据


Innodb特点:大量数据更新操作较优
支持行级锁定
支持事物,事物回滚,外键

表文件:
表名.frm  //表结构
表名.ibd  //数据

事物日志文件:
ibdata1
ib_logfile0
ib_logfile1


mysql锁机制

锁粒度(加锁的范围)
表级锁:对整张表加锁
行级锁:仅对被访问的行分别加锁

锁类型:
读锁(共享锁) : 支持并发读
写锁(互斥锁,排它锁) : 是独占锁,上锁期间其它线程不能读表或写表

查看当前锁状态
show status like "table_lock%";


事物特性(ACID)
Atomic : 原子性  --->事物的整个操作是一个整体,不可分割,要么全部成功,要么全部失败
Consistency : 一致性 ------>事物操作的前后,表中的记录没有变化
Isolation : 隔离性-------->事物操作是相互隔离不受影响
Durability : 持久性------->数据一旦提交,不可改变,永久改变表数据

相关命令:
mysql>show variables like "autocommit";//查看提交状态
mysql>set autocommit=off; //关闭自动提交
mysql> rollback;     //数据回滚
mysql> commit;     //数据提交

#####################################################################################################
环境准备 
192.168.4.55
使用数据导入，把/etc/passwd文件的内容存储到 db9库下的user 表里 

mysql> create database db9;
mysql> create table db9.user(
name char(50),
password  char(1),
uid int,
gid int,
comment char(150),
homedir char(150),
shell  char(50)
);

mysql> system  cp /etc/passwd  /var/lib/mysql-files/

mysql> load data infile "/var/lib/mysql-files/passwd" into table 
      db9.user fields terminated by ":" lines terminated by "\n";

mysql> alter table db9.user add id  int primary key auto_increment first;

mysql> select  * from db9.user;

一、mysql视图
	2.1 视图介绍（什么是视图）
	2.2 为什么要使用视图（视图的优点）
	2.3 视图使用规则（创建和使用视图时，要满足规则要求）
	2.4 视图基本使用
			2.4.1 创建视图
				mysql> create view  db9.v1  as   
					select name ,uid from db9.user;

				mysql> create view db9.v2(a ,b ,c )  as  
					select  name,uid,shell from db9.user;

				mysql> show tables;

				mysql> desc  db9.v2;

				mysql> desc  db9.v1;

				mysql> grant select,insert,update,delete on  db9.v1 to 
				  	 yaya10@"%" identified by "123qqq...A";	
 
			2.4.2 验证视图特点
				  50]# mysql -h192.168.4.55 -uyaya10 -p123qqq...A
				mysql> show  grants;
				mysql>  对数据做操作验证特点：
					更新视图的数据，就是更新基表的数据
					更新基表数据，视图的数据也会跟着改变


			2.4.3 查看视图
				mysql> use db9;
				mysql> show  table  status  where  comment="view" \G;

				mysql> show create view v2 \G;


			2.4.4 删除视图
				mysql> drop  view  db9.v1;

			休息到 15：27

	2.5 视图进阶
		2.5.1 创建视图时，定义字段别名
		
	
mysql> create  table  t2  select  name ,uid ,shell from user limit 3;
 
mysql> create  table  t3  select  name ,uid , password , homedir from user limit 5;

mysql> create  view  v4  as select  *  from  t2 left join t3 on  t2.uid = t3.uid ; 报错

查询时定义字段别名
mysql> create view v4
    -> as
    -> select  a.name x1 , a.uid x2 , a.shell x3 ,
    ->  b.name x4 ,b.uid x5 ,b.password x6,
    -> b.homedir x7 
    -> from
    -> t2 a  left join t3 b on a.uid = b.uid;

	    2.5.2 OR REPLACE 强制覆盖创建新视图
		mysql> create view v4 as  select uid,gid,name from user;
			ERROR 1050 (42S01): Table 'v4' already exists

		mysql> create  or replace view v4 as  select uid,gid,name from user;
		mysql> select  * from v4;

	   2.5.3 算法（ALGORITHM）访问视图时，mysql服务的处理方式
			ALGORITHM=算法

			MERAGE，替换方式
			TEMPTABLE，具体化方式
			UNDEFINED，未定义

		mysql> create  ALGORITHM=TEMPTABLE view v5 
			as  select uid,gid,name from user;	

	 2.5.4 with check option 限制视图操作
		1 LOCAL 对视图操作时，必须满足视图自身的限制。

		2 CASCADED 对视图操作时,既要满足视图自身的限制
			   又要满足基表的限制 


mysql> create table  t5 
       select name,uid,gid,shell from user where gid >=20 and  gid <=1000;

mysql> select  * from t5;


	mysql> create view v7 as select * from t5 where gid<=500
		with local check option;

	mysql> select  * from v7;

        mysql> update v7 set gid=501 where name="games";
	       ERROR 1369 (HY000): CHECK OPTION failed 'db9.v7'

	mysql> update v7 set gid=499 where name="games";

	mysql> select  * from v7 where name="games";
	mysql> select  * from t5 where name="games";

	mysql> create view v9 as select  * from user user 
	       where gid<=100 with CASCADED check option;

	mysql> update v9 set gid=101 where name="root";

	mysql> create view v10 as select  * from t5
               where gid>=100 with CASCADED check option;

	mysql>  update v10 set gid=99 where name="games";

	mysql> create view v7 as select * from t5 where gid<=500
                with local check option;

	mysql> create view v11 as select  * from v7 where gid>30
    		with CASCADED check option;
	
	mysql> update v11  set gid=20 where name="nobody";报错

	mysql> update v11  set gid=501 where name="nobody";报错

	mysql> update v11  set gid=31 where name="nobody";正确

二、mysql存储过程
	2.1 存储过程介绍（什么是存储过程） 是mysql服务里的脚本
	2.2 存储过程的优点（为什么要使用存储过程）
	2.3 使用存储过程
		2.3.1 基本使用
			1 创建存储过程
				delimiter //
				create  procedure  库名.名称()
				begin
					功能代码
					select  * from db9.user;
				end
				//
				delimiter ;	
			

			2 执行存储过程
				call  库名.名称() ;

			3 查看存储过程
				3.1  查看服务器上已有存储过程
				     mysql> desc mysql.proc;
				     mysql> select db,name from mysql.proc 
					    where type="PROCEDURE";

				3.2  查看存储过程代码
				     mysql> select db,name,body from 
					    mysql.proc where 
		       			    type="PROCEDURE" 
					    and name="存储过程名";

				     mysql> select db,name,body from 
   mysql.proc where name="ps_setup_save" and type="PROCEDURE"\G;

			4 删除存储过程
				mysql> drop procedure  库名.名称;


		2.3.2 进阶
			1、变量(变量类型)
			      会话变量
				mysql> show session variables;
				mysql>  set session sort_buffer_size = 40000;						 
			      全局变量
				mysql> show global variables; 
				mysql> show global variables like  "%hostname%";
				mysql> select  @@hostname;
				mysql> show global variables like  "%version%";
				mysql> select  @@version;

			     用户变量
				mysql> set  @x = 99 ;
				mysql> set  @name = "bob" ;
				mysql> select  @x  , @name ;

			     局部变量 (在存储过程里定义)
				declare  变量名 类型；
				set 变量名 = 值；
				select  变量名 ;

delimiter //
create procedure db9.p2()
begin
	declare x int ;
	declare y int;
	set x = 99 ;
	set y = 11 ;
	select x , y ; 
end
//
delimiter ;	
call  db9.p2() ;


			     使用查询结果给变量赋值
			     mysql> select count(name) into 变量名 from db9.user;
			     mysql> select count(name) into @x from db9.user;
			     mysql> select @x;
delimiter //
create procedure db9.p3()
begin
        declare x int ;
        declare y int;
        select count(name) into x from db9.user where gid<=1000;
	
        select count(name) into y from db9.user where gid>1000;
        select x , y ;
end
//
delimiter ;
call  db9.p3() ;

		练习到 11：35 

			2、存储过程参数
				参数作用？
				参数类型：
					 in类型  给存储过程传值
						 in  变量名 数据类型

					 out类型 接收存储过程处理结果
						 out 变量名 数据类型

					 inout类型 2者的结合
						 inout 变量名 数据类型

delimiter //
create procedure db9.p4(参数列表)
begin
	代码
end
//
delimiter ;

delimiter //
create procedure db9.p9(in  username char(10))
begin
        select  * from db9.user where name=username;
end
//
delimiter ;

call db9.p9("root");
call db9.p9("adm");
call db9.p9("lucy");

delimiter //
create procedure db9.p10(in x int , in y int , out z int)
begin
        set  z = x + y ; 
	select z;
end
//
delimiter ;

call  db9.p10(19,37,@i);
select  @i;

call  db9.p10(9,7,@i)
select @i;


delimiter //
create procedure db9.p11(in  uid_num  int , in  shell_name  char(50) , out  x  int)
begin
	declare i int;
	declare j int;
	select count(shell) into j from db9.user where shell = shell_name;
        select count(uid) into i   from db9.user where uid <= uid_num ;
	
	set x  = i + j ;
	select x;
end
//
delimiter ;

call  db9.p11(6,"abc",@w);
select @w;

call  db9.p11(11,"/bin/bash",@xx);
select @xx;

delimiter //
create procedure db9.p12( inout x  char(30) )
begin
	select  name  from db9.user where name=x;

	select  count(*) into x from  db9.user ;
	
	select x;
end
//
delimiter ;

set @i="root" ;
call  db9.p12(@i);
select  @i

set @j="adm";
call db9.p12(@j);
select  @j;

			3、四则计算  +  -  *  /  DIV  %
delimiter //
create procedure db9.p4()
begin
        declare x int ;
        declare y int;
        declare z int;
        select count(name) into x from db9.user where gid<=1000;
        select count(name) into y from db9.user where gid>1000;
	set z = x  + y ;
        select x , y  , z ;
end
//
delimiter ;


			4、条件判断（是给流程控制使用的）
				数值比较符号  字符比较符号 空 非空
				范围内比较    逻辑比较  正则匹配 模糊匹配


			5、流程控制（控制代码的执行顺序）
			   1 if 选择结构(根据条件判断执行操作)
				格式1

					if  条件测试 then  
        					代码 .. ..
       						 .. ..
					end  if ;


				格式2
					if  条件测试 then  
        					代码1 .. ..
        					.. ..
					else
        					代码2 .. ..
        					.. ..
					end  if;

delimiter //
create procedure db9.p13( in line_num int)
begin

	if  line_num  >  10  then
		select * from db9.user where id >= line_num;

	else
		select * from db9.user where id <= line_num;
	end if;

end
//
delimiter ;

call  db9.p13(2);
call  db9.p13(7);
call  db9.p13(12);


			   2 循环结构（需要重复执行的代码放在循环结构里）
				循环结构1 while
					while 条件 do
					  循环体
        				  .. ..
					end   while ;


delimiter //
create procedure db9.p15()
begin
	declare x  int;
	set x =  1;

	while x <= 10   do
		select  x;		
		set x = x + 1 ;
	end while ;
end
//
delimiter ;

call  db9.p15;
			成都中心断网了 等15分钟 到 11：52 

				循环结构2 loop
					 loop
					     循环体
					     .....
					 end loop ;
delimiter //
create procedure db9.p16()
begin
	loop
		select  * from  db9.user limit 1 ;
	end loop ;
end
//
delimiter ;
call db9.p16(); 
				循环结构3 repeat	
				 	repeat
        					循环体
        					.. ..
        					until   条件判断   
					end   repeat ;
			

delimiter //
create procedure db9.p17()
begin
	declare x  int ;
	set x = 10;

	repeat
		select  x ;
		set  x  =  x + 1 ;
		until   x  > 20  
	end   repeat ;
end
//
delimiter ;

call db9.p17();
				2.5 流程控制函数（控制循环结构执行的命令）
					          while  loop  repeat
					LEAVE    结束循环
                                        ITERATE  结束本次循环，并开始下次循环
				
delimiter //
create procedure db9.p20()
begin
	abc:while  1 = 1 do
		select name from db9.user where name="root"; 
		LEAVE abc;
	    end while ;
end
//
delimiter ;

call  db9.p20() ;

delimiter //
create procedure db9.p21()
begin
        declare x  int ;
        set x = 1;
   plj:repeat
		if  x = 3 or x = 5  then
		   set  x  =  x + 1 ;		
                   ITERATE plj;
		else
		   select x ;
                end if ;

                set  x  =  x + 1 ;
                until   x  > 10
        end   repeat ;
end
//
delimiter ;
call  db9.p21();         休息到 15：05

delimiter //
create procedure db9.p1()
begin
	select count(*) from db9.user where shell != "/bin/bash";
	select count(*) from db9.user where shell = "/bin/bash";
end
//
delimiter ;

call  db9.p1() ;

select  db,name from mysql.proc where type="procedure" and name="p1";

select body  from mysql.proc where type="procedure" and name="p1"\G;


delimiter //
create procedure db9.p30( in line_num int)
begin
	if  line_num is not null then
		select  * from db9.user  limit line_num;
	else
		select   * from db9.user  limit 1;
	end if;
end
//
delimiter ;

call db9.p30(4);
call db9.p30(2);

set @x = null ;
call db9.p30(@x);

set @x =6 ;
call db9.p30(@x);




####################################################################################################


 NOSQL DAY01

RDBMS

关系型数据库管理系统: 按照预先设置的组织结构,将数据库存储在物理介质上,数据之间可以做关联操作
主流的RDBMS软件如: Mysql,mariadb,oracle,DB2,sql server(微软)

非关系型数据库:不需要预先定义数据存储结构,每条记录可以有不同的数据类型和字段个数
主流软件:memcached,redis,mongodb,couchdb,neo4j,flockdb

NoSQL (Not Only SQL)
--意思是 '不仅仅是SQL'
--泛指非关系型数据库
--不需要预先定义数据存储结构
--每条记录可以有不同的数据类型和字段个数

redis 介绍:
---远程字典服务器
---是一款高性能的分布式内存数据库
---支持数据持久化
---支持多种数据类型string(字符类型),list(列表类型),hash
---支持master-salve 模式数据备份
---中文网站www.redis.cn


源码编译安装redis
[student@room9pc01 redis]$ scp /linux-soft/03/redis/redis-4.0.8.tar.gz root@192.168.4.51:/root
[root@host50 ~]# yum -y install gcc
[root@host50 ~]# tar -xf redis-4.0.8.tar.gz 
[root@host50 ~]# cd redis-4.0.8/
[root@host50 redis-4.0.8]# make && make install
[root@host50 redis-4.0.8]# ./utils/install_server.sh       //初始化
[root@host50 redis-4.0.8]# netstat -plunt |grep 6379
[root@host50 redis-4.0.8]# redis-cli            //默认连接本机的redis服务

配置服务运行参数:
/etc/redis/6379.conf   //主配置文件
/var/log/redis_6379.log  //日志文件
/var/lib/redis/6379      //数据库目录
/usr/local/bin/redis-server  //服务启动程序
/usr/local/bin/redis-cli     //命令行连接命令


管理服务:
]# /etc/init.d/redis_6379 stop    //停止服务
]# /etc/init.d/redis_6379 start   //启动服务
]# ps -C redis-server             //查看进程
]# ss -plunt |grep 6379           //查看端口


常用命令:
set key名 key值           //存储1个key值
mset key名列表            //存储多个key值
get key名                 //获取key值
mget key名列表           //获取多个key值
select 数据库编号0~15    //切换库
keys *                //显示所有key名  *---->任意多个字符
keys a?               //显示指定以a开头且只有2个字符的key名 ?----->单个任意字符
exists key名              //查看key名是否存在 1为存在,0为不存在
ttl  key名                 //查看key生存时间  -1表示永久
type key名                 //查看key类型 string字符类型,list列表类型
move key名 库编号          //移动key到指定库
expire key名 数字          //设置key有效时间
del key名                    //删除指定的key
flushall                //删除内存里所有key
flushdb                 //删除所在库里的所有key
save                    //保存所有key到硬盘
shutdown                //停止服务
exit                    //断开连接
auth 密码                    //输入密码


常用配置:
/etc/redis/6379.conf    redis主配置文件
数字单位:----->1k与1kb不一样 m,mb 也不一样
port 6379         //端口
bind 127.0.0.1    //IP地址
daemonize yes     //守护进程方式运行
databases 16      //数据库个数
maxclients 10000  //并发连接数量
dir /var/lib/redis/6379   //数据库目录
logfile /var/log/redis_6379.log  //日志文件

内存管理
内存清除策略:
volatile-lru          //最近最少使用(针对设置了TTL的key)
allkeys-lru           //删除最近最少使用的key(针对所有的key)
allkeys-lfu           //从所有的key中清除使用频率最少的key
volatile-lfu          //从所有配置了过期时间的key中清除使用频率最少的key
volatile-random       // 在设置了TTL的key里随机移除
allkeys-random        //随机移除key
volatile-ttl          //移除最近过期的key
noeviction            //不删除




优化设置:
maxmemory          //最大内存
maxmemory-policy   //定义使用策略
maxmemory-samples  //选取key模板的个数(针对lru和ttl策略)



修改配置文件:vim /etc/redis/6379.conf
70 bind  192.168.4.50                //设置服务使用的ip
93 port 6350                         //更改端口号
501 requirepass 123456                //设置密码
:wq


[root@host50 redis-4.0.8]# /etc/init.d/redis_6379 stop
[root@host50 redis-4.0.8]# /etc/init.d/redis_6379 start
[root@host50 redis-4.0.8]# ss -plunt |grep 6350
tcp    LISTEN     0      128    192.168.4.50:6350                  *:*                   users:(("redis-server",pid=4651,fd=6))


验证配置:
[root@host50 ~]# redis-cli    //本地连接失败
Could not connect to Redis at 127.0.0.1:6379: Connection refused
Could not connect to Redis at 127.0.0.1:6379: Connection refused

[root@host50 ~]# redis-cli -h 192.168.4.50 -p 6350   //连接时加上IP和新改的端口号
192.168.4.50:6350> ping         //ping不同 有密码的
(error) NOAUTH Authentication required.
192.168.4.50:6350> auth 123456    //输入密码
192.168.4.50:6350> ping
PONG
192.168.4.50:6350> keys *         //显示所有key名
1) "as"
2) "z"
3) "y"
4) "name"
192.168.4.54:6354> cluster info    //查看集群信息,是否启集群配置

[root@host50 ~]# redis-cli -h 192.168.4.50 -p 6350 -a 123456 shutdown   //停止服务,修改完策略后要这样停服务,脚本停服务的话是默认连接6379端口,可以改脚本源代码
[root@host50 ~]# vim +43 /etc/init.d/redis_6379  //修改配置文件可以使用脚本停服务
43  $CLIEXEC -p $REDISPORT shutdown------>$CLIEXEC -h 192.168.4.50 -p 6350 -a 123456 shutdown
[root@host50 ~]# /etc/init.d/redis_6379 stop              //停服务
[root@host50 ~]# /etc/init.d/redis_6379 start             //开启服务


lnmp+redis

新创虚拟机192.168.4.60 在上面
搭建lnmp:
[student@room9pc01 ~]$ scp -r /linux-soft/03/redis/lnmp/ root@192.168.4.60:/root
[root@lnmp60 ~]# 
yum -y install gcc pcre-devel zlib-devel (openssh-devel)
tar -xf nginx-1.12.2.tar.gz 
cd nginx-1.12.2/            
 ./configure 
make && make install
yum -y install php php-fpm php-mysql
systemctl start php-fpm
systemctl enable php-fpm
ss -plunt |grep 9000
/usr/local/nginx/sbin/nginx
vim /usr/local/nginx/conf/nginx.conf
             location ~ \.php$ {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include        fastcgi.conf;
        }

vim /usr/local/nginx/html/test.php
        <?php
$school = "tarena";
echo $school;
?>
/usr/local/nginx/sbin/nginx -s reload
 firefox http://192.168.4.60/test.php------>测试

[root@lnmp60 ~]# php -m     //查看PHP支持的模块
[root@lnmp60 ~]# php -m |grep -i redis    //查看PHP是否支持redis

 在60上配置支持redis 

[root@lnmp60 lnmp]# yum -y install php-devel autoconf automake 
[root@lnmp60 lnmp]# tar -xf php-redis-2.2.4.tar.gz
[root@lnmp60 lnmp]# cd phpredis-2.2.4/
[root@lnmp60 phpredis-2.2.4]# phpize     //生产配置文件php-config及configure命令
[root@lnmp60 phpredis-2.2.4]# ./configure --with-php-config=/usr/bin/php-config
[root@lnmp60 phpredis-2.2.4]# make && make install


 [root@lnmp60 phpredis-2.2.4]# vim +728 /etc/php.ini
 728 ; extension_dir = "./"-------->extension_dir = "/usr/lib64/php/modules/"
 
 730 ; extension_dir = "ext"------->extension = "redis.so"
:wq

[root@lnmp60 lnmp]# systemctl restart php-fpm
[root@lnmp60 lnmp]# php -m |grep -i redis       //查看已加载模块是否有redis

redis

测试::::
[root@lnmp60 ~]# vim /usr/local/nginx/html/test2.php
[root@lnmp60 ~]# cat /usr/local/nginx/html/test2.php
<?php
$redis = new redis();
$redis->connect("192.168.4.50","6350");
$redis->auth("123456");
$redis->set("username","sdm");
echo "ok";
?>

50端查看:
[root@host50 ~]# redis-cli -h 192.168.4.50 -p 6350 -a 123456
192.168.4.50:6350> get username
"sdm"

总结:lnmp+redis
1.在主机192.168.4.60上部署lnmp环境
2.配置PHP支持redis
3.编写网站脚本,把数据存储到redis服务器192.168.4.50

练习:在192.168.4.51部署lnmp环境,网站服务nginx把数据存储在本机内存里
1.部署lnmp环境
2.配置PHP 支持redis
3.在192.168.4.51本机运行redis
4.编写PHP脚本把数据存储在本机redis服务里

在本机部署lnmp和redis步骤如下:
[student@room9pc01 ~]$ scp -r /linux-soft/03/redis/lnmp/ root@192.168.4.51:/root
yum -y install gcc pcre-devel zlib-devel
cd lnmp/
tar -xf nginx-1.12.2.tar.gz
cd nginx-1.12.2/
./configure
make && make install
vim /usr/local/nginx/conf/nginx.confg
                      location ~ \.php$ {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include        fastcgi.conf;
        }

/usr/local/nginx/sbin/nginx
ss -plunt |grep 80
cd ..
tar -xf php-redis-2.2.4.tar.gz
cd phpredis-2.2.4/
yum -y install php php-fpm php-mysql
systemctl start php-fpm
systemctl enable php-fpm
ss -plunt |grep 9000
php -m |grep -i redis
yum -y install php-devel autoconf automake
phpredis-2.2.4]# phpize 
./configure --with-php-config=/usr/bin/php-config
make && make install
vim +728 /etc/php.ini
 728 ; extension_dir = "./"-------->extension_dir = "/usr/lib64/php/modules/"
 
 730 ; extension_dir = "ext"------->extension = "redis.so"
:wq
systemctl restart php-fpm
php -m |grep -i redis   
vim /usr/local/nginx/html/test.php
<?php
$redis = new redis();
$redis->connect("127.0.0.1","6379");  //注意此为本机配置,在主配置文件/etc/redis/6379.conf里有默认IP和端口
$redis->set("username","sdm");
echo "ok";
?>
Firefox http://localhost/test.php

######################################################################################################

NOSQL DAY02



一.在192.168.4.57上做管理主机:

也可以部署在任意一台redis服务器上
1.部署ruby脚本运行环境
2.创建管理集群脚本

ruby脚本
redis-3.2.1.gem 用来让57主机连接redis服务器的连接程序
redis-trib.rb 管理集群的脚本


[student@room9pc01 ~]$ scp /linux-soft/03/redis/redis-4.0.8.tar.gz root@192.168.4.57:/root
[student@room9pc01 ~]$ scp /linux-soft/03/redis/redis-3.2.1.gem root@192.168.4.57:/root
root@host57 ~]# yum -y install rubygems    //安装提供gem命令的软件
gem  install redis-3.2.1.gem               //安装redis-3.2.1.gem的连接程序
mkdir /root/bin                            //创建命令检索目录
tar -xf redis-4.0.8.tar.gz                
cd redis-4.0.8/src            
cp redis-trib.rb /root/bin                 //创建管理集群的脚本,放在$PATH路径下,这样可以直接敲命令了
chmod +x /root/bin/redis-trib.rb           //给执行权限
redis-trib.rb help                         //查看管理集群脚本的帮助信息

2.启用集群配置:
(51----56已配置redis服务)

[root@host53 ~]# vim +815 /etc/redis/6379.conf 
 815 # cluster-enabled yes----->去掉#
823 # cluster-config-file nodes-6379.conf----->去掉#
829 # cluster-node-timeout 15000----->去掉#,15000改5000毫秒,

redis-cli -h 192.168.4.52 -p 6352 shutdown
/etc/init.d/redis_6379 start

for循环部署
for i in {51..56}
> do
>   ssh root@192.168.4.$i "sed -i \"815s/#//;823s/#//;829s/#//;829s/15000/5000/\" /etc/redis/6379.conf;redis-cli -h 192.168.4.$i -p 63$i shutdown;/etc/init.d/redis_6379 start"
> done


[root@host52 ~]# ss -plunt |grep redis-server
tcp    LISTEN     0      128    192.168.4.52:16352  *:*   users:(("redis-server",pid=1077,fd=8))  //集群通讯端口,默认+10000
tcp    LISTEN     0      128    192.168.4.52:6352   *:*   users:(("redis-server",pid=1077,fd=6))

[root@host55 ~]# redis-cli -h 192.168.4.55 -p 6355  
192.168.4.55:6355> cluster info                      //查看集群信息
cluster_state:fail
cluster_slots_assigned:0
cluster_slots_ok:0
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:1
cluster_size:0
cluster_current_epoch:0
cluster_my_epoch:0
cluster_stats_messages_sent:0
cluster_stats_messages_received:0
192.168.4.55:6355> 

192.168.4.51:6351> info replication           //查看主机角色(复制信息)
role:master                                   //角色为主服务器(已还原为独立的服务器)


创建集群:
replicas 1 ---->设定从服务器为1

[root@host57 ~]# redis-trib.rb create --replicas 1 192.168.4.51:6351 192.168.4.52:6352 192.168.4.53:6353 192.168.4.54:6354 192.168.4.55:6355 192.168.4.56:6356   ---->回车后 Can I set the above configuration? (type 'yes' to accept):  (输入:) yes
[OK] All 16384 slots covered.


[root@host57 ~]# redis-trib.rb info  IP地址:端口    //查看集群信息
[root@host57 ~]# redis-trib.rb check  IP地址:端口   //查看集群主机角色(详细信息)

[root@host57 ~]# redis-trib.rb info 192.168.4.51:6351
[root@host57 ~]# redis-trib.rb check 192.168.4.52:6352



排错:槽分配出错,可以做以下操作:slot(槽)
[root@host55 ~]# rm -rf /var/lib/redis/6379/nodes-6379.conf     //删除存储集群信息文件
[root@host55 ~]# redis-cli -h 192.168.4.55 -p 6355 shutdown     //关闭服务
[root@host55 ~]# /etc/init.d/redis_6379 start                   //启服务

在客户端访问集群存储数据/取数据:
[root@host50 ~]# redis-cli -c -h 192.168.4.51 -p 6351   //-c 集群模式,连接客户端

工作原理:
只有主服务器有hash槽,从服务器没有,hash 槽(slot)只有16384个
槽的作用是确定数据存储在哪一台服务器上---->算法CRC16



二.管理集群

[root@host57 ~]# redis-trib.rb help //查看帮助信息
create           //创建集群
check            //检查集群
info             //查看集群信息
reshard          //重新分片
del-node         //删除主机
add-node --slave //添加slave主机
add-node         //添加master主机
rebalance        //平均分配hash slots(槽)


故障切换测试:
停止master主机的redis服务,master宕机后对应的slave自动被选举为master
原master启动后,会自动配置为当前master的slave

添加新的master服务器到集群
 添加时不指定主机角色,默认新主机被选为master
 添加的master主机,需手动配置hash槽    
[root@host57 ~]# redis-trib.rb add-node 192.168.4.58:6358 192.168.4.51:6351  //新添加的主机默认为master,后边随便定义一个集群里的IP和端口
[root@host57 ~]# redis-trib.rb info 192.168.4.58:6358

192.168.4.58:6358 (81ef9c5c...) -> 0 keys | 0 slots | 0 slaves.
192.168.4.53:6353 (52064863...) -> 3 keys | 5461 slots | 1 slaves.
192.168.4.55:6355 (53c8f199...) -> 1 keys | 5461 slots | 1 slaves.
192.168.4.52:6352 (887c9107...) -> 2 keys | 5462 slots | 1 slaves.

新添加的master主机没有hash槽需手动添加---->命令reshard
重新分片: 
  1.移出hash槽个数
  2.接受hash槽主机ID
  3.移出hash槽主机ID
[root@host57 ~]# redis-trib.rb check 192.168.4.58:6358----->查看58主机id
M: 81ef9c5c1364b7fa7e044c0c1fc38a601d51ec05 192.168.4.58:6358
[root@host57 ~]# redis-trib.rb reshard 192.168.4.51:6351    //重新分片,集群中任意一台主机IP和端口 
4096---->81ef9c5c1364b7fa7e044c0c1fc38a601d51ec05------>all----->yes
 
新添加slave从服务器
添加192.168.4.59运行redis服务并启用集群配置
redis-trib.rb add-node --slave 192.168.4.59:6359 192.168.4.55:6355
redis-trib.rb check 192.168.4.59:6359

删除集群中的redis服务器:(在管理服务器上做)
1.删除master服务器
释放占用的hash槽
[root@host57 ~]# redis-trib.rb reshard 192.168.4.51:6351
4096----->53c8f199f216e459bc8db1e38af155cea128a4f4(分配给谁的ID)---->81ef9c5c1364b7fa7e044c0c1fc38a601d51ec05(把谁的槽给移出ID)---->done---->yes

[root@host57 ~]# redis-trib.rb rebalance 192.168.4.51:6351    //平均分配槽

2.删除slave服务器
[root@host57 ~]# redis-trib.rb del-node 192.168.4.56:6356 f097ffd18c96d4ba09ae5425ccaa57cd08d5ecce

把移出的主机再添加到集群里58master,
1.[root@host58 ~]# /etc/init.d/redis_6379 start

2.[root@host58 ~]# rm -rf /var/lib/redis/6379/nodes-6379.conf 
     或
  [root@host58 ~]# redis-cli -h 192.168.4.58 -p 6358
         192.168.4.58:6358> cluster reset   //重置集群信息这样就不需要删除集群信息文件
            192.168.4.58:6358> flushall      //删除所有key
3.[root@host57 ~]# redis-trib.rb add-node 192.168.4.58:6358 192.168.4.51:6351   //添加master服务器
  [root@host57 ~]# redis-trib.rb check 192.168.4.58:6358----->查看58主机id
  [root@host57 ~]# redis-trib.rb reshard 192.168.4.51:6351    //重新分片,集群中任意一台主机IP和端口 
         4096---->81ef9c5c1364b7fa7e044c0c1fc38a601d51ec05------>all----->yes


把集群中
1.停服务
2.清空数据库服务器下的文件 rm -rf /var/lib/redis/6379/*
3.修改配置文件
vim +815  /etc/redis/6379.conf   //把下面3项注释掉
    815  cluster-enabled yes                 
    823  cluster-config-file nodes-6379.conf
    829  cluster-node-timeout 5000
4.重启服务
[root@host54 ~]# redis-cli -h 192.168.4.54 -p 6354 shutdown
[root@host54 ~]# /etc/init.d/redis_6379 start

#########################################################################################################

 Nosql date 3

 
配置从库:
slaveof  主服务器IP  端口   //设置主(临时)
slaveof  no one          //还原(临时)
info replication         //查看复制信息

[root@host52 ~]# redis-cli -h 192.168.4.52 -p 6352
192.168.4.52:6352> slaveof 192.168.4.51 6351            //设置52为51的从库(临时)
OK
192.168.4.52:6352> info replication
# Replication
role:slave
master_host:192.168.4.51
master_port:6351
master_link_status:up

192.168.4.52:6352> slaveof no one                  //将从库恢复为独立的主服务器
OK
192.168.4.52:6352> info replication
# Replication
role:master
connected_slaves:0

vim /etc/redis/6379.conf
slaveof 192.168.4.51 6351    //永久设置为51的从服务器


主从复制工作原理:
master------> slave  1.完全同步
                           2. 增量同步
1.slave向master发送sync命令
2.master启动后台存盘进程,并收集所有修改数据命令
3.master完成后台存盘后,传送整个数据文件到slave
4.slave接受数据文件,加载到内存中完成首次完全同步
5.后续有新数据产生时,master继续收集数据修改命令依次传给slave,完成同步


51上:
vim +501 /etc/redis/6379.conf(主服务器设置密码)
           requirepass 123456
redis-cli -h 192.168.4.51 -p 6351 shutdown  //关闭服务
/etc/init.d/redis_6379 start           //重启服务


52上:
vim +289 /etc/redis/6379.conf (从服务器)
           slaveof 192.168.4.51 6351  //指定主服务器IP和端口
           masterauth 123456    //指定主服务器连接密码
redis-cli -h 192.168.4.52 -p 6352 shutdown  //关闭服务
/etc/init.d/redis_6379 start           //重启服务

53上: 在命令行用config set 配置项 来配置 (配置从服务器时这2中方法都可以用,这个方法简单,且不需重启服务)
[root@host53 ~]# redis-cli -h 192.168.4.53 -p 6353
192.168.4.53:6353> config get masterauth                //查看选项的值
192.168.4.53:6353> config set masterauth 123456         //设置选项的值
192.168.4.53:6353> config rewrite                       //写进配置文件,永久生效



将54设为53的从,51--->53---->54 主--从--从
[root@host54 ~]# redis-cli -h 192.168.4.54 -p 6354
192.168.4.54:6354> config get slaveof
1) "slaveof"
2) ""
192.168.4.54:6354> slaveof 192.168.4.53 6353  //注意这时因为slaveof和config都是命令,不能一起用
192.168.4.54:6354>  config rewrite            //写进配置文件,永久生效


验证:50上
[root@host50 ~]# redis-cli -h 192.168.4.51 -p 6351   
192.168.4.51:6351> auth 123456    //在命令行没有加 -a 密码时 ,这里可以输入密码

53上:查看主从信息
192.168.4.53:6353> info replication       //查看复制信息
# Replication
role:slave                           //角色:从   
master_host:192.168.4.51             //主库IP地址,51为本机的主
master_port:6351                     //主库端口号
master_link_status:up                //与主库连接状态:开启
    ....
connected_slaves:1                   //本机有一个从服务器
slave0:ip=192.168.4.54,port=6354,state=online,offset=3374,lag=1   //本机的从服务器IP和端口
    ....

哨兵服务
介绍:监视master服务器,发现master宕机后,将从服务器升级为主服务器,主配置文件 sentinel.conf 模板文件:redis-4.0.8/sentinel.conf
将53,54还原为独立主服务器
192.168.4.54:6354> slaveof no one       //命令行临时设置,还原为独立主服务器
OK
192.168.4.54:6354> config rewrite       //写进配置文件,永久生效
OK

192.168.4.53:6353> slaveof no one
OK
192.168.4.53:6353> config rewrite
OK

只剩51主52从了,在57上配置哨兵服务用来监视主服务器,如果主服务器宕机了,将从服务器升级为主服务器
57:
[student@room9pc01 ~]$ scp /linux-soft/03/redis/redis-4.0.8.tar.gz root@192.168.4.57:/root
[root@host57 ~]# yum -y install gcc
[root@host57 ~]# tar -xf redis-4.0.8.tar.gz
[root@host57 ~]# cd redis-4.0.8
[root@host57 ~]# make && make install

生成主配置文件:
[root@host57 redis-4.0.8]# vim sentinel.conf
[root@host57 redis-4.0.8]# vim /etc/sentinel.conf
           bind 0.0.0.0
           port 26379
           sentinel monitor server51 192.168.4.51 6351 1
           sentinel auth-pass server51 123456
[root@host57 redis-4.0.8]# redis-sentinel /etc/sentinel.conf    //启动哨兵服务
             ......
4273:X 25 Oct 11:43:16.316 # +monitor master server51 192.168.4.51 6351 quorum 1    //监视信息
             ......



数据持久化------>2种方式RDB与AOF

一.RDB --->redis数据库文件,全称Redis DataBases
   --数据持久化方式之一
   --数据持久化默认方式
   --按照指定的时间间隔,将内存中的数据集快照写入硬盘
   --快照术语叫Snapshot
   --恢复时,将快照文件直接读入内存
定义RDB文件名  ------>dbfilename  "dump.rdb"    //文件名(配置文件里dbfilename定义数据存储在哪里)
[root@host50 ~]# redis-cli -h 192.168.4.50 -p 6350 -a 123456
192.168.4.50:6350> keys *
1) "z"
2) "class"
3) "username"
4) "y"
5) "as"
6) "name"
192.168.4.50:6350> shutdown                //停止时会自动创建dump.rdb文件,并存入数据
[root@host50 ~]# ls /var/lib/redis/6379/dump.rdb      //数据库目录下的文件,RDB指的就是数据库目录下的dump.rdb文件
[root@host50 ~]# /etc/init.d/redis_6379 start
[root@host50 ~]# redis-cli -h 192.168.4.50 -p 6350 -a 123456
192.168.4.50:6350> keys *
(empty list or set)
192.168.4.50:6350> set name sdm
192.168.4.50:6350>flushall         //清空数据后数据库目录下的dump.rdb文件存在,且会将数据清空



优化设置
数据从内存保存到硬盘的频率
vim +219 /etc/redis/6379.conf
 219 save 900 1               //15分钟且有1个key改变
 220 save 300 10              //5分钟且有10个key改变
 221 save 60 10000            //1分钟且有10000个key改变

手动存盘
save   //阻塞写存盘
dbsave //不阻塞写存盘

备份数据
cp 数据库目录/dump.rdb  备份目录

恢复数据
cp 备份目录/dump.rdb  数据库目录/
操作步骤:   停服务--->删除文件--->拷贝目标文件--->重启服务

eg:
[root@host50 ~]# cp /var/lib/redis/6379/dump.rdb /root/dump.rdb    //50主机上备份数据

[root@host55 ~]# redis-cli -h 192.168.4.55 -p 6355 shutdown        //先停掉本机的redis服务
[root@host55 ~]# rm -rf /var/lib/redis/6379/dump.rdb               //删除本机没有数据的dump.rdb文件
[root@host55 ~]# scp root@192.168.4.50:/root/dump.rdb /var/lib/redis/6379/   //拷贝目标服务器的dump.rdb文件
[root@host55 ~]# /etc/init.d/redis_6379 start                                //重启服务
[root@host55 ~]# redis-cli -h 192.168.4.55 -p 6355                     //登录查看



RDB优缺点:

优点 
1.高性能的持久化实现-------创建一个子进程来执行持久化,先将数据写入临时文件,持久化过程结束后,再用这个临时文件替换上次持久化好的文件,过程中主进程不做任何IO(读写)操作
2.比较适合大规模数据恢复,且对数据完整性要求不是非常高的场合

缺点
意外宕机时,丢失最后一次持久化的所有数据


二.AOF
Append Only File
1.追加方式记录写操作的文件
2.记录redis服务所有写操作
3.不断的将新的写操作,追加到文件的末尾
4.默认没有启用
5.使用cat命令可以查看文件内容

启用AOF
 config set appendonly yes   //启用
 config rewrite              //写进配置文件

备份数据
cp 数据库目录/appendonly.aof  备份目录

恢复数据
拷贝备份文件到数据库目录 
cp 备份目录/appendonly.aof 数据库目录
重启redis服务    /etc/init.d/redis_端口  start 

优化配置
定义文件名 
appendonly yes    //启用AOF,默认no
appendfilename "appendonly.aof"   //指定文件名
AOF文件记录写操作的方式
appendfsync   always       //时时记录,并完成磁盘同步
appendfsync   everysec     //每秒记录一次,并完成磁盘同步
appendfsync   no           //写入AOF,不执行磁盘同步
日志文件会不断增大,合适触发日志重写?
auto-aof-rewrite-min-size 64mb   //首次重写触发值
auto-aof-rewrite-percentage 100   //再次重写,增长百分比(增长100%时重写) 
修复AOF文件
把文件恢复到最后一次的正确操作
redis-check-aof --fix appendonly.aof


eg:
[root@host55 ~]# redis-cli -h 192.168.4.55 -p 6355
192.168.4.55:6355> config set appendonly yes          //开启appendonly
192.168.4.55:6355> config rewrite                     //写入配置文件
192.168.4.55:6355> shutdown                           //关掉服务
[root@host55 ~]# rm -rf /var/lib/redis/6379/appendonly.aof   //删除appendonly.aof文件


[root@host50 6379]# scp appendonly.aof root@192.168.4.55:/var/lib/redis/6379/  //拷贝目标服务器appendonly.aof文件到本地服务器
 
[root@host55 ~]# /etc/init.d/redis_6379 start                   //开启服务



AOF优缺点
优点:
1.可以灵活设置持久化方式
2.出现意外宕机时,仅可能丢失1秒的数据
缺点:
1.持久化文件的体积通常会大于RDB方式
2.执行fsync策略时的速度可能会比RDB方式慢
 



数据类型

1.String字符串
set key value [EX seconds] [PX milliseconds] [NX|XX]
      设置key值,过期时间可以使用秒或毫秒为单位,NX存在就不赋值,XX存在就赋值(替换)
setrange key offset value
      从偏移量开始复写key的特定位的值
     set name 123456789
     setrange name 3 ABC     //修改变量值第3位开始的后面改为ABC其它不变,变量值从第0位开始
     get name 
        123ABC789
strlen key ,统计子串长度
append key value  存在则追加,不存在则创建key及value,返回key长度

setbit key offset value
对key所存储子串,设置或清除特定偏移量上的位(bit)
value值可以为1或0,offset为0~2^32之间
key不存在,则创建新key
eg:setbit bit 0 1    //设置变量bit第0位为1
   setbit bit 1 0    //设置变量bit第1位为0
bitcount key   //统计字符串中被设置为1的比特位数量
备注:1k=1024字节(bytes),1字节=8位

decr key   //将key值减1,不存在则先初始化为0,再减1
decrby key decrement  //将key值减去decrement  eg:set test 10
get key    //返回key存储的字符串值,若key不存在则返回null,若key值不是字串,则返回错误,get只能处理字串
getrange key start end  //返回字符串中的子字串,截取范围为start和end,负数偏移量表示从末尾开始计数,-1表示最后一个
incr key    //将key的值加1,如果不存在则初始值为0,主要应用为计数器
incrby key increment   //将key的值加increment
incrbyfloat key increment   //为key中所储存的值加上浮点数增量increment
mget key [key...]           //获取一个或多个key的值,空格分开,具有原子性
mget key value [key value...]  //设置多个key及值,空格分隔.具有原子性



list列表
redis 的list是一个字符队列,先进后出,一个key可以有多个值

lpush key value [value...]    //一个变量存多个值就是列表,key没有就创建,key有的话就在现有值的前面按'先进后出'的方式追加值
lrange key start stop     //从开始的位置读取key的值到stop结束 eg: lrange id 0 2     //从0位开始,读到2位为止
                                                              lrange id 0 -1   //从开始读到结束为止
                                                              lrange id 0 -2   //从开始读到倒数第2位为止
lpop key            //移除并返回列表头元素数据,key不存在则返回nil
llen key            //返回列表key的长度
lindex key index    //返回列表中第index个值
lset key index value   //将key中index 位置的值修改为value
rpush key value[value...] //将value插入到key的末尾
rpop key    //删除并返回key末尾的值


hash表

redis hash 
1.是一个string类型的field和value的映射表
2.一个key可对应多个field,一个field对应一个value
3.将一个对象存储为hash类型,较于每个字段都存储成string类型更能节省内存

hset key field value   //将hash表中field值设置为value
hget key field         //获取hash表中的field的值
hmset key field value[field value...]    //同时给hash表中多个field赋值
hmget key field [field...]               //返回hash表中多个field的值
hkeys key                                //返回hash表中所有的field的名称
hgetall key                              //返回hash表中所有field及值
hvals key                                //返回hash表中所有field的值
hdel key field [field...]                //删除hash表中多个field的值



########################################################################################################################


                        监控与安全         IDC 监控岗位
date1

自动化监控系统
1.Cacti-->基于SNMP协议的监控软件,强大的绘图能力
2.Nagios-->基于Agent监控,强大的状态检查与报警机制,插件极多,自己写监控脚本潜入到Nagios非常方便
3.Zabbix -->基于多种监控机制,支持分布式监控,

Zabbix简介:
是一个高度集成的监控解决方案,可以实现企业级的开源分布式监控,通过C/S(客户端/服务端)模式采集监控数据,通过B/S(浏览器/服务端)模式实现web管理



[root@svr5 ~]# iostat                             //获取当前磁盘的读写信息
[root@svr5 ~]# traceroute                         //路由追踪

一,部署zabbix服务

在主机192.168.2.5上部署zabbix服务,默认端口10051

[student@room9pc01 ~]$ scp -r /linux-soft/03/Zabbix root@192.168.2.5:/root

1. 在主机zabbix上先准备LNMP环境:
yum -y install gcc pcre-devel zlib-devel openssl-devel
tar -xf nginx-1.12.2.tar.gz
 cd nginx-1.12.2/
./configure --with-http_ssl_module
make && make install
 yum -y install php php-fpm php-mysql
 yum -y install mariadb  mariadb-server mariadb-devel
 systemctl start mariadb
 systemctl enable mariadb
 systemctl start php-fpm
 systemctl enable php-fpm
 /usr/local/nginx/sbin/nginx
 vim /usr/local/nginx/conf/nginx.conf
           location ~ \.php$ {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include        fastcgi.conf;
        }

 echo -e "<?php\n\$i=AAAAAA;\necho \$i;\n?>" > /usr/local/nginx/html/test.php 
 ss -plunt |grep 3306
 ss -plunt |grep 80
 ss -plunt |grep 9000
 curl 192.168.2.5/test.php

2. 源码部署Zabbix:
 cd Zabbix/
yum -y install net-snmp-devel curl-devel libevent-devel
tar -xf zabbix-3.4.4.tar.gz
cd zabbix-3.4.4/
 ./configure --enable-server --enable-proxy --enable-agent --with-mysql=/usr/bin/mysql_config --with-net-snmp --with-libcurl
make install
// --enable-server安装部署zabbix服务器端软件(监控服务)
// --enable-agent安装部署zabbix被监控端软件
// --enable-proxy安装部署zabbix代理相关软件
// --with-mysql配置mysql_config路径
// --with-net-snmp允许zabbix通过snmp协议监控其他设备
// --with-libcurl安装相关curl库文件，这样zabbix就可以通过curl连接http等服务，测试被监控主机服务的状态
3.初始化准备:
a.创建数据库与数据库账户:
[root@zabbix zabbix-3.4.4]# mysql
MariaDB [(none)]> create database zabbix character set utf8;
MariaDB [(none)]> grant all on zabbix.* to zabbix@"localhost" identified by 'zabbix';
MariaDB [(none)]> exit
[root@zabbix ~]# cd /root/Zabbix/zabbix-3.4.4/database/mysql
[root@zabbix mysql]# ls
data.sql  images.sql  schema.sql
按顺序还原数据:
[root@zabbix mysql]# mysql -uzabbix -p'zabbix' zabbix < schema.sql 
[root@zabbix mysql]# mysql -uzabbix -p'zabbix' zabbix < images.sql 
[root@zabbix mysql]# mysql -uzabbix -p'zabbix' zabbix < data.sql 

b.上线zabbix页面
[root@zabbix ~]# cd /root/Zabbix/zabbix-3.4.4/frontends/php/
[root@zabbix php]# cp -a * /usr/local/nginx/html/            //-a保持权限不变
[root@zabbix php]# chmod -R 777 /usr/local/nginx/html/

c.修改nginx服务的运行配置,满足PHP页面的运行要求
[root@zabbix php]# vim /usr/local/nginx/conf/nginx.conf
http{
… …
    fastcgi_buffers 8 16k;                        //缓存php生成的页面内容，8个16k
    fastcgi_buffer_size 32k;                      //缓存php生产的头部信息
    fastcgi_connect_timeout 300;                  //连接PHP的超时时间
    fastcgi_send_timeout 300;                     //发送请求的超时时间
    fastcgi_read_timeout 300;                     //读取请求的超时时间
location ~ \.php$ {      

[root@zabbix php]# /usr/local/nginx/sbin/nginx -t     //-t选项,检测配置是否正确
[root@zabbix php]# /usr/local/nginx/sbin/nginx -s stop   //修改完配置文件后先停掉服务
[root@zabbix php]# /usr/local/nginx/sbin/nginx           //后启动服务

d.安装依赖的软件
[root@zabbix php]# yum -y install php-gd php-xml php-ldap php-bcmath php-mbstring

e.修改PHP配置文件
vim /etc/php.ini 默认;为注释
878 ;date.timezone =  ----->date.timezone = Asia/shanghai     //设置时区
384 max_execution_time = 30 ------->max_execution_time = 300  //最大执行时间,秒
672 post_max_size = 8M  -------->post_max_size = 32M          //POST数据最大容量
394 max_input_time ------>max_input_time=300                  //服务器接受数据的时间限制
    memory_limit = 128M                                       //内存容量限制

[root@zabbix php]# systemctl restart php-fpm

4.初始化
http://192.168.2.5/index.php
cat /usr/local/nginx/html/conf/zabbix.conf.php  

5.登录web页面
用户:admin
初始密码:zabbix

6.启动zabbix_server服务
]# vim /usr/local/etc/zabbix_server.conf
85 # DBHost=localhost         //数据库主机
95  DBName=zabbix            //设置数据库名称
111 DBUser=zabbix            //设置数据库账户
119 DBPassword=zabbix        //设置数据库密码
 38 LogFile=/tmp/zabbix_server.log  //设置日志

]# useradd zabbix           //不创建用户无法启动服务
]# zabbix_server            //启动服务
]# ss -plunt |grep :10051   //查看端口
]# killall -9 zabbix_server //停服务


二,配置监控服务器
1.修改页面语言为中文,管理员admin密码
2.查看已监控的主机有那些
3.监控配置
   a. 配置被监控端(客户端) 192.168.2.100
          安装zabbix软件
          [student@room9pc01 ~]$scp -r /linux-soft/03/Zabbix/zabbix-3.4.4.tar.gz root@192.168.2.100:/root
          [root@web100 ~]# yum -y install gcc pcre-devel
          [root@web100 ~]# tar -xf zabbix-3.4.4.tar.gz 
          [root@web100 ~]# cd zabbix-3.4.4/
          [root@web100 zabbix-3.4.4]# ./configure --enable-agent
          [root@web100 zabbix-3.4.4]# make install
          修改配置文件
          [root@web100 zabbix-3.4.4]# vim /usr/local/etc/zabbix_agentd.conf
       93 Server=127.0.0.1-----> Server=127.0.0.1,192.168.2.5   //允许访问服务器列表             
       134 ServerActive=192.168.2.5:10051                       //监控服务器IP地址
       30 LogFile=/tmp/zabbix_agentd.log                        //日志文件
                             
          启动服务,运行zabbix_agentd服务---->产生10050端口(10051端口连接10050端口)
           ]# useradd zabbix   //添加用户
           ]# zabbix_agentd    //启服务
           ]# netstat -plunt |grep :10050   //查看zabbix_agentd(客户端端口)
           ]# killall -9 zabbix_agentd      //停服务
 ]# ls /usr/local/etc/
zabbix_agentd.conf  zabbix_agentd.conf.d

 ]# ls /usr/local/bin/
eip  setip  zabbix_get  zabbix_sender

 ]# ls /usr/local/sbin/
zabbix_agentd


/usr/local/etc/zabbix_agentd.conf   ----->主配置文件



       b.配置监控服务器 192.168.2.5
            添加监控主机
               配置-->主机--->创建主机--->主机名称 web100,可见的名称web100,新的群组 webgroup,IP地址 192.168.2.100,DNS名称     ,---->添加
              二级菜单 主机---->web100---->模板--->链接指示器 ,选择Template App HTTP Service,Template OS Linux --->更新
              监测中---->最新数据---->主机群组,webgroup,主机,web100 --->

          
4.自定义监控(在客户端定义命令,给监控服务器使用)          
a.配置客户端 192.168.2.100

启用自定义命令设置
指定定义命令文件路径
定义监控命令 count.line.passwd
重启zabbix_agentd服务
验证定义命令

[root@web100 zabbix-3.4.4]# vim /usr/local/etc/zabbix_agentd.conf
280 # UnsafeUserParameters=0------>UnsafeUserParameters=1  //是否允许自定义key
264 Include=/usr/local/etc/zabbix_agentd.conf.d/          //加载配置文件目录

[root@web100 zabbix-3.4.4]# cd /usr/local/etc/zabbix_agentd.conf.d/
[root@web100 zabbix_agentd.conf.d]# vim count.line.passwd.conf
        UserParameter=count.line.passwd,wc -l /etc/passwd |awk '{print $1}'
   //自定义key语法格式
   //UserParameter=自定义key名称,命令
[root@web100 zabbix_agentd.conf.d]# killall -9 zabbix_agentd   //关闭服务
[root@web100 zabbix_agentd.conf.d]# zabbix_agentd              //重启服务

验证:[root@web100 ~]#  zabbix_get -s 127.0.0.1 -k count.line.passwd

b.配置监控服务器 192.168.2.5
在web页面上做如下操作
 1).创建新的监控模板 (如Atmp1)
 2).创建应用集 (如monuser)
 3).创建监控项 (如mon_user_num) 对应命令,自定义创建的命令count.line.passwd
 4).监控主机192.168.2.100时使用新创建的监控模板 Atmp1
 5).查看监控信息




#########################################################################################################################


date 2
一 .监控报警
支持报警方式:
发邮件 ***
发即时消息
发短信
配置要求:监控2.100系统的用户总量 大于22个的时候 发送邮件给监控服务器本机的zabbix@localhost 邮箱

1.在2.5zabbix上配置发送邮件的postfix服务和账号
yum -y install postfix         //安装邮件服务软件
systemctl start postfix        //起服务
systemctl enable postfix       //开机自启动
ss -plunt |grep 25             //查看邮件服务端口
grep zabbix /etc/passwd        //查看本机是否有接受邮件的zabbix用户账号
echo "127.0.0.1 zabbix" >> /etc/hosts   //添加zabbix用户本机映射,使本机主机名与本机回环地址绑定
yum -y install mailx           //安装mail命令的软件
which mail                     //查看是否安装mail命令
mail -s "T" zabbix < /etc/passwd //以本机root身份给zabbix用户发送邮件
mail -u zabbix                 //查看邮件
exit                           //退出邮件

2.在zabbix监控页面做如下配置:
怎么实现2.100总用户数大于22就发邮件报警
检测-->仪表盘   ()
a.先建触发器(名:cfq1  表达式:):
配置-->模板-->触发器-->创建触发器-->名称 cfq1 -->表达式 添加-->选择-->功能  最新的T值>N N值(22) 插入-->添加   

验证触发器 : 检测中-->触发器-->任何,任何,隐藏所有,名称(cfq1),应用 -->在2.100添加用户,过会后触发器会变成红色状态,表示已经触发,删除用户后,过会会变成绿色正常状态

b.设置邮件
1).指定邮件服务器
管理-->报警媒介类型-->邮件(Email)--> SMTP服务器 localhost ,SMTP电邮 root@localhost  -->更新
2).为账户添加收件人Media
管理-->用户-->Admin-->报警媒介-->添加-->收件人 zabbix@localhost -->添加 -->更新
3).添加动作Action(行为) 名dz1
配置-->动作-->创建动作-->名称 dz1 ,新的触发条件 触发器名称 cfq1 添加-->添加-->操作 -->新的-->默认接收人
 big22,-->新的 操作细节 0(无穷大) ,步骤持续时间 60秒,发送到用户 添加 admin 仅送到 Email 添加 -->添加
4).测试配置
让触发器被触发查看用户是否收到邮件
2.100添加用户-->在2.5上切换用户进入zabbix用户查看邮件(su - zabbix ---->mail,问题没有解决每隔60秒发一封邮件给zabbix)

 
二 . 监控进阶操作
1.自动发现
a.创建自动发现规则
配置-->自动发现-->创建发现规则-->名称 gz1,IP范围 192.168.2.6-254  更新间隔 1m(分钟) ,新的 检查类型 http  端口 80 添加 -->添加

b.创建动作Action 名dz2
配置-->动作-->创建动作旁的 自动发现 点击创建动作--> 名称 dz2 新的触发条件  192.168.2.6-254 添加-->操作-->新的-->操作类型 添加到主机群组: webgroup -->新的 链接到模板: Template OS Linux, Template App HTTP Service 添加-->更新 
c.查看
配置-->主机

2.主被动监控
克隆新的虚拟机192.168.2.201
1).被监控主机配置192.168.2.201上
a.安装zabbix软件
[student@room9pc01 ~]$ scp -r /linux-soft/03/Zabbix/ root@192.168.2.201:/root
yum -y install gcc pcre-devel
cd Zabbix/
tar -xf zabbix-3.4.4.tar.gz 
cd zabbix-3.4.4/
./configure --enable-agent
make install

b.修改配置文件
vim /usr/local/etc/zabbix_agentd.conf
93 Server=127.0.0.1----->#Server=127.0.0.1
118 # StartAgents=3------>StartAgents=0               //禁止被动监控(有服务进程没有端口)
134 ServerActive=127.0.0.1------>ServerActive=192.168.2.5    //监控服务器IP一定要取消127.0.0.1
145 Hostname=Zabbix server----->Hostname=web201              //告诉监控服务器,是谁发的数据信息一定要和zabbix服务器配置的监控主机名称一致(后面设置)
183 # RefreshActiveChecks=120----->RefreshActiveChecks=120      //单位秒客户端向服务器发送请求检测时间
30 LogFile=/tmp/zabbix_agentd.log        //日志文件,不需修改

useradd zabbix            //创建用户
zabbix_agentd             //启动服务
ps -C zabbix_agentd      //查看进程 没有端口

2).监控服务器配配置192.168.2.5
登录web页面做如下配置:
a.克隆已有模板  名Btmp2
配置-->模板-->搜索(Template OS Linux)点击Template OS Linux-->全克隆-->模版名称 Btmp2 可见的名称 Btmp2 ,Templates 更新-->  添加

 
b.修改模板监控项的模式为主动模式
配置-->模板-->Btmp2,监控项-->Wizard 名称-->批量更新-->类型 Zabbix客户端(主动式)-->更新-->类型什序排列-->Zabbix 客户端(非主动式) 已启用改为停用的(3项)
		
c.添加监控主机201
配置-->主机-->创建主机-->主机名称 web201 可见的名称 web201   群组 webgroup  -->agent代理程序的接口 ip地址0.0.0.0 端口 0 -->添加
web201 点击--> 模板--> 链接指示器 选择 Btmp2 -->添加-->更新



d.调用克隆的






3.聚合图形和拓扑图
检测中-->拓扑图-->创建拓扑图-->td1--更新


检测中-->聚合图形-->创建聚合图形-->名称 jhtx1 列数 2 行 2 添加-->构造函数-->第一个更改 ,选择 ,群组主机webgroup 主机web100 CPU load 添加-->宽 200 高 80 左侧 顶部  添加-->   第二个更改 选择 ,群组主机webgroup 主机web100 Memory usage添加-->宽 200 高 80 左侧 底部  添加-->




三 .监控案例

如何让监控服务器调用客户端的脚本 监控主机
1.监控nginx服务的状态


配置-->主机-->web100 ,已启用关闭掉-->Template App HTTP Service 取消连接并清理 -->更新

[root@web100 ~]# systemctl stop httpd
[root@web100 ~]# systemctl disable httpd

[student@room9pc01 ~]$ scp /linux-soft/03/Zabbix/nginx-1.12.2.tar.gz root@192.168.2.100:/root
[root@web100 ~]# yum -y install zlib-devel gcc pcre-devel
tar -xf nginx-1.12.2.tar.gz
cd nginx-1.12.2/
 ./configure --with-http_stub_status_module
 make && make install
vim /usr/local/nginx/conf/nginx.conf
              server {
                    ....
    location /status {
            stub_status on;
          }

/usr/local/nginx/sbin/nginx

curl 192.168.2.100/status

Active connections: 1              //实时连接数
server accepts handled requests    //描述信息
 3 3 2                                      //历史累计连接数量,处理了多少,处理请求的数量
Reading: 0 Writing: 1 Waiting: 0   //读请求的数量,当前服务器正在写响应信息的数量 ,等待网站处理的数量

在192.168.2.100上写查看网站状态的脚本
vim /root/nginx_status.sh

#!/bin/bash
case $1 in
Active)
curl -s http://192.168.2.100/status |awk 'NR==1{print $3}' ;;
accepts)
curl -s http://192.168.2.100/status |awk 'NR==3{print $1}' ;;
Waiting)
curl -s http://192.168.2.100/status |awk 'NR==4{print $6}' ;;
esac

[root@web100 ~]# chmod +x /root/nginx_status.sh

把脚本定义为zabbix_agentd服务可以使用的命令

[root@web100 ~]#mv /root/nginx_status.sh /usr/local/bin/    //把脚本放入zabbix可以执行的路径
[root@web100 ~]#chmod +x /usr/local/bin/nginx_status.sh     //添加执行权限确保zabbix可以执行
[root@web100 ~]#cd /usr/local/etc/zabbix_agentd.conf.d/     //修改定义zabbix_agentd命令的文件将脚本定义zabbix_agentd命令
[root@web100 ~]#vim count.line.passwd.conf
      UserParameter=count.line.passwd,wc -l /etc/passwd |awk '{print $1}'
      UserParameter=nginx_status[*],/usr/local/bin/nginx_status.sh $1
[root@web100 ~]#killall -9 zabbix_agentd                    //停zabbix_agentd服务
[root@web100 ~]#zabbix_agentd                               //启动zabbix_agentd服务
[root@web100 ~]#netstat -plunt |grep 10050                  //查看zabbix_agentd端口
[root@web100 ~]#zabbix_get -s localhost -k nginx_status[Waiting]    //命令行验证

配置监控服务器,在web页面做如下配置:
1).创建新的监控模板 名Atmp2
2).创建应用集  名nginx
3).创建监控项 关联监控命令
   sum_link    nginx_status[accepts]
    now_link   nginx_status[Active]
   waiting_num nginx_status[Waiting]
4).调用监控模板Atmp2 监控主机192.168.2.100
5).查看监控数据

添加应用集和监控项:
配置-->模板-->Atmp2  应用集-->创建应用集-->名称 nginx 添加-->nginx 监控项-->创建监控项-->名称 ,sum_link 键值 nginx_status[accepts] 应用集 nginx 添加      -->创建监控项-->名称 ,now_link 键值 nginx_status[Active] 应用集 nginx 添加    -->创建监控项-->名称 ,waiting_num 键值 nginx_status[Waiting] 应用集 nginx 添加   
 

###################################################################################################################


date 3

一 .Linux基本防护
chage -d 0 用户名    //强制用户首次登录必须修改密码
chage -l 用户名      //查看用户密码信息
chage -E yyyy-mm-dd 用户名   //指定用户密码失效时间

passwd命令 : -l 锁定  ,-u 解锁 , -S 查看状态
passwd (选项) 用户 

强制定期修改密码
配置文件/etc/login.defs -->对新建的用户有效
[root@zabbix ~]# grep -v '#\|^$' /etc/login.defs
MAIL_DIR	/var/spool/mail
PASS_MAX_DAYS	99999
PASS_MIN_DAYS	0
PASS_MIN_LEN	5
PASS_WARN_AGE	7
UID_MIN                  1000
UID_MAX                 60000
SYS_UID_MIN               201
SYS_UID_MAX               999
GID_MIN                  1000
GID_MAX                 60000
SYS_GID_MIN               201
SYS_GID_MAX               999
CREATE_HOME	yes
UMASK           077
USERGROUPS_ENAB yes
ENCRYPT_METHOD SHA512 

伪装登录提示:
配置文件/etc/issue  , /etc/issue.net
分别适用与本地,远程登录,默认会提示内核,系统等版本信息
[root@zabbix ~]# cat /etc/issue
\S
Kernel \r on an \m

[root@zabbix ~]# cat /etc/issue.net 
\S
Kernel \r on an \m

把这2个文件内容改掉,别人连接时不会显示内核和版本信息

程序和服务控制
RHEL7 ---->systemctl
RHEL6 ---->chkconfig

RHEL6 不能使用systemctl管理服务
使用chkconfig

RHEL6与RHEL7管理服务不一样:
chkconfig httpd on  = systemctl enable httpd
chkconfig httpd off  = systemctl disable httpd
service httpd start|stop|restart  = systemctl start|stop|restart httpd

锁定与解锁保护文件
EXT3/EXT4的文件属性控制
chattr          //设置文件属性 
lsattr          //查看文件属性
+ - =控制方式  ---->+:原先的属性不变,只添加,-:原先的属性不变,只删除, =:只给该属性,其它属性没有
属性i : 不可变(immutable) --->不可编辑,不可删除,不可移动等等
属性a : 仅可追加(append only)  --->只能用echo追加
eg:  chattr +a /etc/passwd   //给文件设置属性
     lsattr /etc/passwd      //查看文件属性
      
 
二 .用户切换与提权
 
2.1 用户切换
su [-] [目标用户]           //默认切换到root
su [-] -c "命令" [目标用户]    //切换到目标用户后以目标用户的身份执行命令
[-] 切换用户时系统的运行环境也切换,不带[-]时系统环境不会切换
 安全日志:/var/log/secure---->记录su验证,shell开启与关闭
 db1;
mysql>create table 
2.2 用户提取
sudo :操作系统的root用户给系统的普通用户配置可以使用自己使用的命令的权限
sudo 提权命令    //执行提权命令
sudo -l    //查看提权命令
/etc/sudoers     //sudo主配置文件(visudo也可以修改),退出时:wq!才可以
用户  主机列表=命令列表        //用户-->单个用户,%用户-->用户组,目录列表注意要绝对路径

root    ALL=(ALL)       ALL            //root用户在所有主机以root身份拥有所有权限

eg:允许mike以root权限执行/sbin/下的所有命令,但是,禁止修改eth0网卡的参数
[root@zabbix ~]# useradd mike
[root@zabbix ~]# echo "123456" |passwd --stdin mike
[root@zabbix ~]# vim /etc/sudoers
  93 mike localhost,zabbix=/sbin/*,!/sbin/ifconfig eth0
:wq!
[root@zabbix ~]# su - mike
[mike@zabbix ~]$ sudo -l
  User mike may run the following commands on zabbix:
    (root) /sbin/*, !/sbin/ifconfig eth0

wheel组无需验证可执行所有命令:
%wheel ALL=(ALL)  NOPASSWD:ALL

sudo别名设置:
提供可重用性,易读性,简化配置,使记录更有条理
别名必须大写:

[root@zabbix ~]# useradd yaya
[root@zabbix ~]# useradd dc
[root@zabbix ~]# echo "123456" |passwd --stdin yaya
[root@zabbix ~]# echo "123456" |passwd --stdin dc
[root@zabbix ~]# vim +93 /etc/sudoers
User_Alias MYUSER=yaya,dc
Host_Alias MYSER=localhost,zabbix
Cmnd_Alias MYCMD=/usr/bin/rpm,/usr/bin/yum,/usr/bin/systemctl * mariadb,/usr/bin/vim,/etc/my.cnf
MYUSER MYSER=MYCMD
mike MYSER=MYCMD,/sbin/*,NOPASSWD:!/sbin/ifconfig eth0
:wq!
注意:先定义别名,再定义用户权限




三 .SSH访问控制
3.1 常用配置项(基本防护)
[root@zabbix ~]# vim /etc/ssh/sshd_config
            17 Port 2222        //修改端口为任意不存在的端口
[root@zabbix ~]# systemctl stop sshd
[root@zabbix ~]# systemctl restart sshd
[root@zabbix ~]# ss -plunt |grep sshd
tcp    LISTEN     0      128       *:2222                  *:*  
]# ssh -p 2222 root@192.168.2.5     //ssh连接时加端口


vim /etc/ssh/sshd_config
Port 2222        //修改端口为任意不存在的端口
Protocol 2    //启用ssh v2版协议
ListenAddress 192.168.168.174
PermitRootLogin no       //禁止root登录
UseDNS no                //不解析客户机地址
LoginGraceTime 1m        //登录时限
MaxAuthTries 3           //每连接最多认证次数

3.2 黑白名单
vim /etc/ssh/sshd_config
DenyUsers USER1 USER2 ...     //黑名单
AllowUsers USER1@HOST  USER2...   //白名单
DenyGroups GROUP1 GROUP2...
AllowGroups GROUP1 GROUP2...

eg: AllowUsers yaya@192.168.0.*,192.168.4.100
    AllowUsers harry,tom,jerry

[root@zabbix ~]# vim /etc/ssh/sshd_config 
         Allowusers root@192.168.2.254 sdm      //允许root在192.168.2.254上登录192.168.2.5,允许sdm在任意IP地址登录192.168.2.5
[root@zabbix ~]# useradd sdm
[root@zabbix ~]# echo 123456 |passwd --stdin sdm
[root@zabbix ~]# systemctl restart sshd


3.3 密钥对认证登录配置
口令认证登录: 65 PasswordAuthentication yes
密钥对认证登录:
43 #PubkeyAuthentication yes
47 AuthorizedKeysFile      .ssh/authorized_keys    //公钥库,存放

[root@web100 ~]# ssh-keygen -f /root/.ssh/id,_rsa -N ''
[root@web100 ~]# ssh-copy-id john@192.168.2.5
[root@zabbix ~]# vim /etc/ssh/sshd_config
 65 PasswordAuthentication no    //口令认证登录改为no,此时输入密码将无法登录,持有公钥才能登录
[root@zabbix ~]# systemctl restart sshd
[root@web100 ~]# ssh john@192.168.2.5    --->可以登录
[root@web100 ~]# ssh yaya@192.168.2.5    --->不可以登录



扩展:    192.168.2.100可以通过用户John连接192.168.2.5,如何实现家里的电脑和笔记本连接192.168.2.5.环境和上面的一样密码登录取消(PasswordAuthentication no),只启用了秘钥对认证登录
  思路::::  在2.5上产生密钥对,私钥给2.100 ,2.200,2.254的话,可以与2.5的公钥匹配才能连接
[root@web200 ~]# rm -rf /root/.ssh/*
[root@web100 ~]# scp /root/.ssh/id_rsa 192.168.2.200:/root/.ssh/     //将私钥拷贝给2.200主机的家目录下的.ssh目录下


 

四 .SElinux 安全防护
   启用和禁用SElinux
1.selinux介绍:
2.启用和禁用selinux
[root@web100 ~]# rpm -qa |grep -i selinux         //查看内核自带的selinux相关软件
selinux-policy-targeted-3.13.1-192.el7.noarch
libselinux-utils-2.5-12.el7.x86_64
libselinux-python-2.5-12.el7.x86_64
libselinux-2.5-12.el7.x86_64
selinux-policy-3.13.1-192.el7.noarch

[root@web100 ~]# sestatus                       //查看selinux状态
SELinux status:                 disabled

主配置文件   /etc/selinux/config
mls - Multi Level Security protection.   //多级安全保护.所有文件都保护
targeted                                 //保护本机常用的网站服务

[root@web100 ~]# touch /.autorelabel     //标记下一次启动重设 Selinux 安全标签
[root@web100 ~]# reboot 

3.查看和修改安全上下文(标签)
文件   ls -lZ 文件名
目录   ls -ldZ 目录名
进程   ps  aux -Z |grep 进程

ls -lZ /etc/passwd
system_u:object_r:passwd_file_t:s0
ls -ldZ /etc/
system_u:object_r:etc_t:s0
ps -uax -Z |grep httpd
system_u:system_r:httpd_t:s0

用户:角色:访问类型:选项..

chcon -t 指定访问类型 
      -R 剃归修改
创建新的文件或目录会自动继承父目录的安全上下文
移动的文件,原有的上下文的属性不变
拷贝的文件,自动继承目标位置的上下文

restorecon  目录路径  //恢复为所在位置的默认上下文属性
      -R  剃归修改




4.恢复安全上下文
5.selinux布尔值(bool)

[root@web100 ~]# getsebool -a |grep http   //查看httpd的布尔值
[root@web100 ~]# setsebool -P 功能名称  on|off   //修改布尔值开关
 
[root@web200 ~]# yum -y install ftp
[root@web200 ~]# ftp 192.168.2.100
Name (192.168.2.100:root): ftp
Password:     --->回车无密码
ftp> cd share
ftp> get nginx-1.12.2.tar.gz    //下载压缩包到当前目录root下
ftp> lcd /etc            //切换到本机当前目录
ftp> put hosts           //上传文件到共享目录share里


6.查看日志解决问题

[root@web100 ~]# vim +42 /etc/httpd/conf/httpd.conf  //把默认端口改掉80-->8070
[root@web100 ~]# systemctl stop httpd
[root@web100 ~]# systemctl start httpd              //重启服务启不来
[root@web100 ~]# yum -y install setroubleshoot* ; reboot   //安装产生selinux日志的软件并重启
[root@web100 ~]# systemctl start httpd     //reboot后还是五福重启httpd服务

/var/log/messages          //selinux日志文件
[root@web100 ~]# grep setroubleshoot /var/log/messages |tail -1    //获取selinux日志文件报错信息
sealert -l 4f5a5be3-9a4f-4795-9f7d-ab371386a7b6
[root@web100 ~]# sealert -l 4f5a5be3-9a4f-4795-9f7d-ab371386a7b6    //命令行执行这条信息会告诉你具体信息
[root@web100 ~]# semanage port -a -t http_port_t -p tcp 8070
[root@web100 ~]# systemctl restart httpd
[root@web100 ~]# ss -plunt |grep httpd
[root@web100 ~]# semanage port -l |grep httpd                //查看httpd端口





lsof    //查看linux系统当前加载的库文(以点“.so”结尾的为库文件)

如何让history命令显示具体时间？
vim /etc/bashrc
export HISTTIMEFORMAT="%Y-%m-%d%H:%M:%S"

用什么命令定义某个程序的优先级别？
nice -n [-20-19] 数字越小级别越高

#####################################################################################################


date 4

一 .数据加密与解密
1.确保数据的机密性
对称加密: 加密/解密用同一个秘钥  ------>DES  ,  AES
非对称加密 : 加密/解密用不同一个秘钥 (公钥,私钥) ----->RSA  ,DSA

2.保护信息的完整性
信息摘要:基于输入的信息生成长度较短,位数固定的散列值    ----->MD5   , SHA
---根据输入的文本(长度不限),生成固定长度(如128位)的摘要文本
---只有输入的文本不同,则生存的摘要文本也不一样

[root@web100 ~]# md5sum /etc/passwd             //用MD5查看/etc/passwd的散列值
5dfc760bf01c08f41ee41cbdd05cb4ff  /etc/passwd
[root@web100 ~]# sha
sha1sum    sha224sum  sha256sum  sha384sum  sha512sum  
[root@web100 ~]# sha1sum  /etc/passwd                 //用SHA查看/etc/passwd的散列值
4149e3563a1012ef29aa5079898ea1fe3c79a68d  /etc/passwd


GPG对称加/解密工具
yum -y install gnupg2            //安装软件
gpg --version                    //查看版本
[usera@room9pc01 ~]$ vim a.txt
[usera@room9pc01 ~]$ gpg -c a.txt ---->输入密码口令2次   //给文件加密
[usera@room9pc01 ~]$ cat a.txt.gpg    //查看已加密后的文件以.gpg结尾

[usera@room9pc01 ~]$ mv a.txt.gpg /tmp/      //在usera用户上把加密文件放到公共目录下/tmp/,userb用户可以看到次加密文件
[userb@room9pc01 ~]$ ls /tmp/*.gpg
/tmp/a.txt.gpg

[userb@room9pc01 ~]$ gpg -d /tmp/a.txt.gpg       //给文件解密


GPG非对称加/解密工具
  解密方  userb
    1.创建密钥对
[userb@room9pc01 ~]$ gpg --gen-key

如果没有生成秘钥:
[root@room9pc01 ~]# mv /dev/random /dev/randomold
[root@room9pc01 ~]# ln -s /dev/urandom /dev/random        //需要生成大量的随机字节
[userb@room9pc01 ~]$ rm -rf ~/.gnupg/
[userb@room9pc01 ~]$ gpg --gen-key     //重新创建秘钥对

[userb@room9pc01 ~]$ cd .gnupg
pubring.gpg   //公钥
pubring.gpg~  //公钥备份文件
secring.gpg   //私钥

gpg --list-keys      //查看公钥环

    2.导出公钥
[userb@room9pc01 .gnupg]$ gpg --export -a > userb.pub 
 
    3.贡献公钥
[userb@room9pc01 .gnupg]$ mv userb.pub /tmp/          //mv到共享目录

  加密方 usera
    1.导入公钥
[usera@room9pc01 ~]$ gpg --import /tmp/userb.pub

    2.使用公钥加密明文文件
[usera@room9pc01 ~]$ cat t1.txt   //创建明文文件
aaaa
abbb
accc
[usera@room9pc01 ~]$ gpg -e -r userb t1.txt     //使用公钥加密明文文件,这里的userb是userb用户创建秘钥对是的真实姓名

    3.共享加密后的文件 
[usera@room9pc01 ~]$ mv t1.txt.gpg /tmp/


   4.userb用户解密加密文件
[userb@room9pc01 .gnupg]$ gpg -d /tmp/t1.txt.gpg  ---->输入创建密钥对时的密码


   5.userb用户解密后的文件内容
[userb@room9pc01 .gnupg]$ gpg -d /tmp/t1.txt.gpg > ~/t1.txt
[userb@room9pc01 .gnupg]$ cat ~/t1.txt


GPG的签名机制，检查数据来源的正确性

[userb@room9pc01 .gnupg]$ vim a1.txt      
[userb@room9pc01 .gnupg]$ gpg -b a1.txt   //创建分离式数字签名文件  --->输入创建密钥对时的密码

共享原文件和签名文件,公钥文件
[userb@room9pc01 .gnupg]$ mv a1.txt /tmp/
[userb@room9pc01 .gnupg]$ mv a1.txt.sig /tmp/

验证签名文件
[usera@room9pc01 ~]$ cat /tmp/a1.txt
[usera@room9pc01 ~]$ gpg --verify /tmp/a1.txt.sig    //验证签名文件



用户userf 导入公钥,验证签名文件
[userf@room9pc01 ~]$ gpg --import /tmp/userb.pub 
[userf@room9pc01 ~]$ gpg --verify /tmp/a1.txt.sig 



二 .使用AIDE做入侵检测
[root@web100 ~]# yum -y install aide
/etc/aide.conf      //主配置文件

[root@proxy ~]# vim /etc/aide.conf
@@define DBDIR /var/lib/aide                            //数据库目录
@@define LOGDIR /var/log/aide                            //日志目录
database_out=file:@@{DBDIR}/aide.db.new.gz                //数据库文件名
//一下内容为可以检查的项目（权限，用户，组，大小，哈希值等）
#p:      permissions
#i:      inode:
#n:      number of links
#u:      user
#g:      group
#s:      size
#md5:    md5 checksum
#sha1:   sha1 checksum
#sha256:        sha256 checksum
DATAONLY =  p+n+u+g+s+acl+selinux+xattrs+sha256
//以下内容设置需要对哪些数据进行入侵校验检查
//注意：为了校验的效率，这里将所有默认的校验目录与文件都注释
//仅保留/root目录，其他目录都注释掉
/root   DATAONLY
#/boot   NORMAL                                    //对哪些目录进行什么校验
#/bin    NORMAL
#/sbin   NORMAL
#/lib    NORMAL
#/lib64  NORMAL
#/opt    NORMAL
#/usr    NORMAL
#!/usr/src                                        //使用[!]，设置不校验的目录
#!/usr/tmp

[root@proxy ~]# sed -i "99,312s/^/#/" /etc/aide.conf
                    98 /root/  FIPSR



入侵前对数据进行校验，生成初始化数据库
[root@web100 ~]# aide --init            //生成校验数据库，数据保存在/var/lib/aide/aide.db.new.gz
[root@web100 ~]# mv /var/lib/aide/aide.db.new.gz /opt/       //备份数据库，将数据库文件拷贝到U盘
[root@web100 ~]# cp /opt/aide.db.new.gz /var/lib/aide/aide.db.gz

对/root进行一番操作后,配置文件只对/root/进行检测其它都注释掉了
[root@web100 ~]# aide --check                            //检查哪些数据发生了变化


 
三 .扫描与抓包分析 

1. 扫描
以获取一些公开/非公开信息为目的
--检测潜在的风险
--查找可攻击目标
--收集设备/主机/系统/软件信息
--发现可利用的安全漏洞

典型的扫描方式:
--Scan 主动探测
--Sniff 被动监听/嗅探
--Capture 数据包捕获(抓包)

常见的安全分析工具:
扫描器 : NMAP
协议分析 : tcpdump , WireShark

--一款强大的网络探测利器工具
--支持多种探测技术
     ----ping扫描
       ------多端口扫描
     ----TCP/IP指纹校验

[root@proxy ~]# yum -y install nmap
//基本用法：
# nmap  [扫描类型]  [选项]  <扫描目标 ...>
//常用的扫描类型
// -sS，TCP SYN扫描（半开）不执行完整的3次握手4次断开
// -sT，TCP 连接扫描（全开）
// -sU，UDP扫描
// -sP，ICMP扫描(ping)
// -A，目标系统全面分析
//  -p , 指定端口
//  -n   不做IP地址到主机名的解析

[root@room9pc01 ~]# nmap -sP 176.46.3.1-254    //ping网络内的所有主机
[root@room9pc01 ~]# nmap -p 8070,22,21 192.168.2.100  //-p , 指定端口,多个端口用","号间隔




2.抓包tcpdump   ----->ctrl+c 停止抓包
格式:  tcpdump [选项] [过滤条件]

[root@localhost ~]# which tcpdump    //查看本机是否有该命令的路径
/usr/sbin/tcpdump
[root@localhost ~]# rpm -qf /usr/sbin/tcpdump   //查看产生改名了的软件
tcpdump-4.9.2-3.el7.x86_64
[root@localhost ~]# 

  监控选项如下：
// -i，指定监控的网络接口（默认监听第一个网卡eth0）
// -A，转换为 ACSII 码，以方便阅读
// -w，将数据包信息保存到指定文件
// -r，从指定文件读取数据包信息
// -c, 定义抓包个数


  tcpdump的过滤条件：
// 类型：host(主机)、net(网段)、port(端口)、portrange(端口范围) 
// 方向：src(来自哪的源地址)、dst(目标地址)
// 协议：tcp、udp、ip、wlan、arp、icmp(ping)……
// 多个条件组合：and、or、not

[root@web100 ~]# tcpdump -i eth1 host 192.168.2.254     //指定网卡和主机
[root@web100 ~]# tcpdump -i eth1 icmp and host 192.168.2.254
[root@room9pc01 ~]# tcpdump -i eth0 port 22     //只有有人连接我的ssh就抓包
[root@web100 ~]# tcpdump -i eth1 port 22 and host 192.168.2.200

eg:数据在网络中传输如果没有加密就能被抓住
web100上:
systemctl restart vsftpd
useradd sdm 
echo 123456 | passwd --stdin sdm
setenforce 0  关闭selinux
[root@web100 ~]# systemctl stop firewalld.service
[root@web100 ~]# tcpdump -A -i eth1 tcp port 21      //抓包 连接本机ftp服务的eth1网卡


[root@room9pc01 ~] yum -y install ftp       //安装ftp命令
[root@room9pc01 ~]# ftp 192.168.2.100  ---->输入sdm用户名和123456密码

[root@web100 ~]# tcpdump -A -i eth1 tcp port 21  //抓包 抓住用户名和密码
USER sdm
FPASS 123456

wireshark抓包工具:
一款与tcpdump类似的抓包工具,需要图形环境
[root@room9pc01 ~]# yum -y install wireshark
[root@room9pc01 ~]# yum -y install wireshark-gnome
[root@room9pc01 ~]# wireshark       //命令行打开





################################################################################################

date 5


一 ,系统审计

什么是审计:

审计的目的是基于事先配置的规则生成日志，记录可能发生在系统上的事件（正常或非正常行为的事件），审计不会为系统提供额外的安全保护，但她会发现并记录违反安全策略的人及其对应的行为。

审计能够记录的日志内容：
日期与事件以及事件的结果
触发事件的用户
所有认证机制的使用都可以被记录，如ssh等
对关键数据文件的修改行为等都可以被记录

[root@proxy ~]# yum -y  install  audit                //安装软件包
[root@proxy ~]# cat /etc/audit/auditd.conf            //查看配置文件，确定日志位置
log_file = /var/log/audit/audit.log                //日志文件路径
[root@proxy ~]# systemctl start auditd                //启动服务
[root@proxy ~]# systemctl enable auditd            //设置开机自启

[root@proxy ~]# auditctl  -s                        //查询状态
[root@proxy ~]# auditctl  -l                        //查看规则
[root@proxy ~]# auditctl  -D                        //删除所有规则

#语法格式：auditctl  -w  path  -p  permission  -k  key_name
# path为需要审计的文件或目录
# 权限可以是r,w,x,a(文件或目录的属性发生变化)
# Key_name为可选项，方便识别哪些规则生成特定的日志项

[root@proxy ~]# auditctl  -w  /etc/passwd  -p wa  -k  passwd_change
//设置规则所有对passwd文件的写、属性修改操作都会被记录审计日志
 [root@proxy ~]# auditctl  -w  /etc/selinux/  -p wa  -k  selinux_change
//设置规则，监控/etc/selinux目录
 [root@proxy ~]# auditctl  -w  /usr/sbin/fdisk  -p x  -k  disk_partition
//设置规则，监控fdisk程序
[root@proxy ~]# auditclt  -w  /etc/ssh/sshd_conf  -p warx  -k  sshd_config
//设置规则，监控sshd_conf文件

[root@proxy ~]# vim  /etc/audit/rules.d/audit.rules
-w /etc/passwd -p wa -k passwd_changes
-w /usr/sbin/fdisk -p x -k partition_disks

[root@proxy ~]# tailf  /var/log/audit/audit.log      //手动查看日志
type=SYSCALL msg=audit(1517557590.644:229228): arch=c000003e 
syscall=2 success=yes exit=3 
a0=7fff71721839 a1=0 a2=1fffffffffff0000 a3=7fff717204c0 
items=1 ppid=7654 pid=7808 auid=0 uid=0 gid=0 euid=0 suid=0 
fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts2 ses=3 comm="cat" 
exe="/usr/bin/cat" 
subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key="sshd_config"
.. ..
#内容分析
# type为类型
# msg为(time_stamp:ID)，时间是date +%s（1970-1-1至今的秒数）
# arch=c000003e，代表x86_64（16进制）
# success=yes/no，事件是否成功
# a0-a3是程序调用时前4个参数，16进制编码了
# ppid父进程ID，如bash，pid进程ID，如cat命令
# auid是审核用户的id，su - test, 依然可以追踪su前的账户
# uid，gid用户与组 (0为root用户)
# tty:从哪个终端执行的命令
# comm="cat"            用户在命令行执行的指令
# exe="/bin/cat"        实际程序的路径
# key="sshd_config"    管理员定义的策略关键字key
# type=CWD        用来记录当前工作目录
# cwd="/home/username"
# type=PATH
# ouid(owner's user id）    对象所有者id
# guid(owner's groupid）    对象所有者id

2）通过工具搜索日志
[root@proxy ~]# ausearch -k sshd_config -i    
//根据key搜索日志，-i选项表示以交互式方式操作


二 , 服务安全(优化服务的手段)

Nginx安全优化包括：删除不要的模块、修改版本信息、限制并发、拒绝非法请求、防止buffer溢出。
MySQL安全优化包括：初始化安全脚本、密码安全、备份与还原、数据安全。
Tomcat安全优化包括：隐藏版本信息、降权启动、删除默认测试页面.


 1. 网站服务安全
   1). nginx (php)

在新虚拟机上准备nginx环境:

[student@room9pc01 03]$ scp -r /linux-soft/03/redis/lnmp/nginx-1.12.2.tar.gz  root@192.168.4.203:/root  
yum -y install gcc pcre-devel zlib-devel
tar -xf nginx-1.12.2.tar.gz
cd nginx-1.12.2/
./configure 
make && make install
[root@srv1 nginx-1.12.2]# /usr/local/nginx/sbin/nginx 
[root@srv1 nginx-1.12.2]# ss -plunt |grep nginx
[root@srv1 nginx-1.12.2]# echo 'web203' > /usr/local/nginx/html/test.html
[root@srv1 nginx-1.12.2]# curl 192.168.4.203/test.html
web203

a.安装软件时禁用不需要的模块

Nignx是模块化设计的软件，需要什么功能与模块以及不需要哪些模块，都可以在编译安装软件时自定义，使用--with参数可以开启某些模块，使用--without可以禁用某些模块。最小化安装永远都是对的方案

Nginx默认是不允许列出整个目录的。如需此功能，打开nginx.conf文件，在location server 或 http段中加入
autoindex on;
另外两个参数最好也加上去:

autoindex_exact_size off;
默认为on，显示出文件的确切大小，单位是bytes。
改为off后，显示出文件的大概大小，单位是kB或者MB或者GB
autoindex_localtime on;
默认为off，显示的文件时间为GMT时间。
改为on后，显示的文件时间为文件的服务器时间

[root@srv1 nginx-1.12.2]# ./configure --help       //查看编译脚本时默认安装的模块(带--without的)
[root@srv1 nginx-1.12.2]# ./configure --without-http_autoindex_module ; make ;make install


b.修改版本信息，并隐藏具体的版本号
默认Nginx会显示版本信息以及具体的版本号，这些信息给攻击者带来了便利性，便于他们找到具体版本的漏洞。
如果需要屏蔽版本号信息，执行如下操作，可以隐藏版本号。
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
… …
http{
     server_tokens off;                            //在http下面手动添加这么一行
     … …
}
[root@proxy ~]# nginx -s reload
[root@proxy ~]# curl -I http://192.168.4.5          //查看服务器响应的头部信息


但服务器还是显示了使用的软件为nginx，通过如下方法可以修改该信息。
[root@proxy nginx-1.12]# /usr/local/nginx/sbin/nginx -s stop
[root@proxy nginx-1.12]# vim +48 src/http/ngx_http_header_filter_module.c
//注意：vim这条命令必须在nginx-1.12源码包目录下执行！！！！！！
//该文件修改前效果如下：
static u_char ngx_http_server_string[] = "Server: nginx" CRLF;
static u_char ngx_http_server_full_string[] = "Server: " NGINX_VER CRLF;
static u_char ngx_http_server_build_string[] = "Server: " NGINX_VER_BUILD CRLF;
//下面是我们修改后的效果：
static u_char ngx_http_server_string[] = "Server: Jacob" CRLF;
static u_char ngx_http_server_full_string[] = "Server: Jacob" CRLF;
static u_char ngx_http_server_build_string[] = "Server: Jacob" CRLF;
//修改完成后，再去编译安装Nignx，版本信息将不再显示为Nginx，而是Jacob
[root@proxy nginx-1.12]# ./configure
[root@proxy nginx-1.12]# make && make install
[root@proxy nginx-1.12]# killall nginx
[root@proxy nginx-1.12]# /usr/local/nginx/sbin/nginx            //启动服务
[root@proxy nginx-1.12]# curl -I http://192.168.4.5            //查看版本信息验证
[root@proxy nginx-1.12]# curl -i http://192.168.4.5            //查看版本信息验证并显示页面内容

c. 限制并发量
yum provides ab
yum -y install httpd-tools
ab -c 10 -n 10 http://192.168.4.203/
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
… …
http{
… …
limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
    server {
//备注说明：
//limit_req_zone语法格式如下：
//limit_req_zone key zone=name:size rate=rate;
//上面案例中是将客户端IP信息存储名称为one的共享内存，内存空间为10M
//1M可以存储8千个IP信息，10M可以存储8万个主机连接的状态，容量可以根据需要任意调整
//每秒中仅接受1个请求，多余的放入漏斗
//漏斗超过5个则报错
]# /usr/local/nginx/sbin/nginx -s reload

d. 拒绝非法的请求
网站使用的是HTTP协议，该协议中定义了很多方法，可以让用户连接服务器，获得需要的资源。但实际应用中一般仅需要get和post。
GET   请求指定的页面信息,并返回实体主体
POST  向指定资源提交数据进行处理请求,
HEAD  类似于get请求,只不过返回的相应中没有具体内容,用于获取报头
PUT  向服务器特定位置上传资料

[root@client ~]# curl -i -X GET  http://192.168.4.5            //正常
[root@client ~]# curl -i -X HEAD http://192.168.4.5            //正常
//curl命令选项说明：
//-i选项：访问服务器页面时，显示HTTP的头部信息
//-X选项：指定请求服务器的方法

通过如下设置可以让Nginx拒绝非法的请求方法：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
http{
       server {
                 listen 80;
#这里，!符号表示对正则取反，~符号是正则匹配符号
#如果用户使用非GET或POST方法访问网站，则retrun返回444的错误信息
              if ($request_method !~ ^(GET|POST)$ ) {
                     return 444;
               }    
        }
}
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
修改服务器配置后，客户端使用不同请求方法测试：
[root@client ~]# curl -i -X GET  http://192.168.4.5            //正常
[root@client ~]# curl -i -X HEAD http://192.168.4.5            //报错


e. 防止buffer溢出( 防止缓冲区溢出)
当客户端连接服务器时，服务器会启用各种缓存，用来存放连接的状态信息
如果攻击者发送大量的连接请求，而服务器不对缓存做限制的话，内存数据就有可能溢出（空间不足）
修改Nginx配置文件，调整各种buffer参数，可以有效降低溢出风险

[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
http{
client_body_buffer_size  1K;    //页面数据在内存里占用的数据
client_header_buffer_size 1k;   
client_max_body_size 1k;
large_client_header_buffers 4 4k;
 … …
}
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload



 
 2). tomcat(java)
 在新的虚拟机上部署tomcat服务
[student@room9pc01 lnmp_soft]$ scp /linux-soft/02/lnmp_soft/apache-tomcat-8.0.30.tar.gz root@192.168.4.203:/root

[root@srv1 ~]# yum list |grep openjdk                           //查看JDK软件
[root@srv1 ~]# yum -y install java-1.8.0-openjdk.x86_64        //安装JDK软件
[root@srv1 ~]# tar -xf apache-tomcat-8.0.30.tar.gz 
[root@srv1 ~]# mv apache-tomcat-8.0.30/ /usr/local/tomcat/   //创建tomcat网站目录
[root@srv1 ~]# /usr/local/tomcat/bin/startup.sh            //启动tomcat服务
[root@srv1 ~]# ss -plunt |grep java                     //查看tomcat端口
[root@srv1 ~]# echo "I am tomcat" > /usr/local/tomcat/webapps/ROOT/a.html    //创建tomcat页面
[root@srv1 ~]# curl http://192.168.4.203:8080/a.html                         //访问tomcat页面

优化:
1.隐藏版本信息--->改源代码
[root@srv1 ~]# yum -y install java-1.8.0-openjdk-devel
[root@srv1 ~]# which jar    --->jar用来解压Java的压缩包的
/usr/bin/jar
[root@srv1 util]# cd /usr/local/tomcat/lib/org/apache/catalina/util/

[root@srv1 util]# vim ServerInfo.properties
server.info=Apache Tomcat/8.0.30^M               server.info=nginx^M
server.number=8.0.30.0^M                         server.built=Dec 12 2019 22:30:46 UTC             
server.number=10.0.30.0^M                        server.built=Dec 1 2015 22:30:46 UTC


[root@srv1 util]# vim +69 /usr/local/tomcat/conf/server.xml
 69     <Connector port="8080" protocol="HTTP/1.1"
 70                connectionTimeout="20000"
 71                redirectPort="8443" server="jacob"/>   ----->server里的双引号随便写个名字

  mv /dev/random /dev/random.bak
  ln -s /dev/unrandom /dev/random
  /usr/local/tomcat/bin/startup.sh 
  ss -plunt |grep java
  curl -i http://192.168.4.203:8080/test.html
  firefox http://192.168.4.203:8080/test.html

2.启动降权(使用非root用户启动tomcat)
  /usr/local/tomcat/bin/shutdown.sh 
  useradd tomcat
  chown -R tomcat:tomcat /usr/local/tomcat
  su - -c "/usr/local/tomcat/bin/startup.sh" tomcat
  ps aux |grep -i java    ----->启动Java服务的用户在在是root而是tomcat

3.删除默认的测试页面
]# rm -rf /usr/local/tomcat/webapps/*
然后在配置文件里重新定义默认页面

2.数据库服务安全
       mariadb

a. 管理员本机登录没有密码

b. 默认情况下任何用户都可以无密码登录并对test库有完全权限

安装完MariaDB或MySQL后，默认root没有密码，并且提供了一个任何人都可以操作的test测试数据库。有一个名称为mysql_secure_installation的脚本，该脚本可以帮助我们为root设置密码，并禁止root从远程其他主机登陆数据库，并删除测试性数据库test。

[root@srv1 nginx-1.12.2]# mysql_secure_installation
回车-->y-->y-->y-->y-->y

删除历史记录文件
[root@proxy ~]# cat .bash_history   //通过命令行修改的密码，bash会自动记录历史，历史记录中记录了明文密码
[root@proxy ~]# cat .mysql_history   //通过mysql命令修改的密码，mysql也会有所有操作指令的记录，这里也记录了明文密码



三. 打补丁
   1. 创建补丁文件 diff
diff的原则:告诉我们怎么修改第一个文件后能得到第二个文件
选项:
-u   输出统一内容的头部信息(打补丁使用)，计算机知道是哪个文件需要修改
-r   递归对比目录中的所有资源(可以对比目录)
-a   所有文件视为文本(包括二进制程序)
-N   无文件视为空文件(空文件怎么变成第二个文件)
-N选项备注说明：
A目录下没有txt文件，B目录下有txt文件
diff比较两个目录时，默认会提示txt仅在B目录有（无法对比差异，修复文件）
diff比较时使用N选项，则diff会拿B下的txt与A下的空文件对比，补丁信息会明确说明如何从空文件修改后变成txt文件，打补丁即可成功！

  2. 打补丁    patch
 使用patch命令打补丁
在代码相同目录下为代码打补丁
[root@proxy demo]# yum -y install patch
[root@proxy demo]# patch -p0 < test.patch                    //打补丁
patching file test1.sh
//patch -pnum（其中num为数字，指定删除补丁文件中多少层路径前缀）
//如原始路径为/u/howard/src/blurfl/blurfl.c
//-p0则整个路径不变
//-p1则修改路径为u/howard/src/blurfl/blurfl.c
//-p4则修改路径为blurfl/blurfl.c
//-R(reverse)反向修复，-E修复后如果文件为空，则删除该文件
[root@proxy demo]# patch -RE < test.patch                     //还原旧版本，反向修复


############################################################################################33

date 6

什么是防火墙:
一道保护性的安全屏障  保护  隔离

a主机:eth1 2.11   b主机:eth1 2.10 eth0 4.10  c主机:eth0 4.11

systemctl status firewall
yum -y install iptables-services.x86_64
systemctl start iptables
systemctl enable iptables
systemctl status iptables

1.iptables 服务组成(四表,五链,八策略)
  四表: 功能分类
     包过滤  filter---->默认表
     地址转换 nat
     打标记  mangle
     状态跟踪  raw

   五链: 数据包传输的方向
      进入防火墙主机的数据包   INPUT
      从防火墙主机出去的数据包  OUTPUT
      经过防火墙主机的数据包    FORWARD
      处理路由前的数据包       PREROUTING
      处理路由后的数据包       POSTROUTING

//处理动作(八策略)：
// ACCEPT：允许通过/放行  ----->所有链的初始默认规则
// DROP：直接丢弃，不给出任何回应
// REJECT：拒绝通过，必要时会给出提示
// LOG：记录日志，然后传给下一条规则
// DNAT: 目标地址转换
// SNAT: 源地址转换
//REDIRECT: 端口重定向
//MASQUERAND : 地址伪装

iptables只允许访问8002端口访问
a. iptables -A INPUT ! -p tcp --dport 8002 -j DROP

b. iptables -A INPUT -p tcp --dport 8002 -j ACCEPT 
   iptables -A INPUT -j DROP

如何将本地的80端口的请求转发到本地8080端口(远程的,两种情况)
本地:
iptables -t nat -A PREROUTING -p tcp -d 127.0.0.1 --dport 80 -j DNAT --to 127.0.0.1:8080
远程:
iptables -t nat -A PREROUTING -p tcp -d 127.0.0.1 --dport 80 -j DNAT --to-destination 远程ip:8080
iptables -t nat -A POSTROUTING -p tcp -d 远程ip --sport 8080 -j SNAT --to-source 本地ip

包过滤匹配流程:
规则链内的匹配顺序
--顺序比对,匹配即停止(LOG除外)
--若无任何匹配,则按该链的默认策略处理

防火墙管理命令
   ]# iptables [-t 表名] 选项  [链名]  [条件]  [-j 处理动作]


[root@b ~]# iptables -t filter -I INPUT -p icmp -j REJECT   //添加规则
[root@b ~]# iptables -t filter -L INPUT  [--line-numbers]   //显示filter表INPUT链所有规则[显示行号]
[root@b ~]# iptables -t filter -D INPUT 1                   //删除第一行规则
[root@b ~]# iptables -t filter -L INPUT --line-numbers


//注意事项与规律：
//可以不指定表，默认为filter表
//可以不指定链，默认为对应表的所有链
//如果没有找到匹配条件，则执行防火墙默认规则
//选项/链名/目标操作用大写字母，其余都小写
 

[root@b ~]# iptables -L             //查看默认表filter里所有规则INPUT,OUTPUT,FORWARD
[root@b ~]# iptables -L  INPUT      //查看默认表filter里指定链INPUT的规则
[root@b ~]# iptables -t mangle -L   //查看mangle表里所有规则PREROUTING,INPUT,FORWARD,OUTPUT,POSTROUTING
[root@b ~]# iptables -t nat -L      //查看nat表里所有规则PREROUTING,INPUT,OUTPUT,POSTROUTING
[root@b ~]# iptables -t nat -L OUTPUT //查看nat表里指定链OUTPUT的规则
[root@b ~]# iptables -t raw -L      //查看raw表里所有规则PREROUTING,OUTPUT


表-1 iptables常用选项

添加规则   -A  追加一条防火墙规则至链的末尾位置
         -I  插入一条防火墙规则至链的开头  
           
查看规则   -L  查看iptables所有规则
         -n  以数字形式显示地址,端口等信息
         --line-numbers  查看规则时,显示规则的行号

删除规则   -D  删除链内指定序号(或内容)的一条规则
         -F  清空所有规则

默认规则   -P 为指定的链设置默认规则


[root@b ~]# iptables -t filter -F   //清空表filter里所有规则
[root@b ~]# iptables -t nat -F
[root@b ~]# iptables -t raw -F
[root@b ~]# iptables -t mangle -F


主机型防火墙 (自己保护自己) 使用filter表的INPUT链
[root@hostb ~]# iptables -t filter -A INPUT -p tcp  --dport 22 -j ACCEPT  //放行22端口 
[root@hostb ~]# iptables -t filter -P INPUT DROP
[root@hostb ~]# iptables-save > /etc/sysconfig/iptables
[root@hostb ~]# tcpdump -i eth0 port 80         //抓包eth0网卡的数据包    
[root@hostb ~]# tcpdump -i eth1 port 3306
[root@hostb ~]# iptables -t filter -A INPUT -p tcp --dport 80 -j ACCEPT    //放行80端口 

[root@hostb ~]# iptables -t filter -A INPUT -p tcp dport 3306 -s 192.168.4.0/24 -j ACCEPT  //开启4.0网段访问本机3306端口的限制

基本的匹配条件
通用匹配
--可直接使用,不依赖于其他条件或扩展
--包括网络协议,IP地址,网络接口等条件
隐含匹配
--要求以特定的协议匹配作为前提
--包括端口,tcp标记,icmp(ping)类型等条件

通用匹配  协议匹配   -p 协议名
           地址匹配  -s 源地址 ,-d 目标地址
           借口匹配  -i 收数据的网卡,  -o 发数据的网卡
           
隐含匹配   端口匹配  --sport 源端口,  --dport 目标端口
         ICMP类型匹配  --icmp-type ICMP类型

-P  链  目标操作     //设置默认链操作

需要去反条件时,用叹号 (!)


禁止其他主机ping本机，允许本机ping其他主机
[root@hostb ~]# iptables -t filter -P INPUT DROP        //设置filter表的默认INPUT链为drop
//设置完上面的规则后，其他主机确实无法ping本机，但本机也无法ping其他主机
//当本机ping其他主机，其他主机回应也是使用icmp，对方的回应被丢弃
[root@hostb ~]# iptables -t filter -A INPUT -p icmp --icmp-type echo-reply -j ACCEPT    //开启icmp允许ping应答进入本机
[root@hostb ~]# iptables-save > /etc/sysconfig/iptables                 //保存到配置文件 



    
网络型防火墙 (防火墙服务器主机架设在2 个网络之间)  使用filter表的FORWARD链
[root@hostb ~]# iptables -t filter -P INPUT ACCEPT         //
[root@hostb ~]# iptables-save > /etc/sysconfig/iptables
[root@hostb ~]# iptables -t filter -F                //清除表filter所有规则(注意要做完上面2个操作之后再清除,否则无法ssh)
[root@hosta ~]# route  add default gw 192.168.2.10   //指定网关
[root@c ~]#  route  add default gw 192.168.4.10


[root@hostb ~]# iptables -t filter -P FORWARD DROP       设置filter表的默认 FORWARD链为drop
[root@hostb ~]# iptables -t filter -A FORWARD -p tcp --dport 22 -j ACCEPT    //放行端口为22的目标端口过  
[root@hostb ~]# iptables -t filter -A FORWARD -p tcp --sport 22 -j ACCEPT    //放行端口为22的源端口过
[root@hostb ~]# iptables-save > /etc/sysconfig/iptables

扩展匹配条件(-m 模块)
iptables在基本过滤条件的基础上还扩展了很多其他条件，在使用时需要使用-m参数来启动这些扩展功能，语法如下：
iptables 选项 链名称 -m 扩展模块 --具体扩展条件 -j 动作

扩展条件的方法:
前提条件----->有对应的防火墙模块支持
基本用法-----> -m 扩展模块  --扩展条件 条件值 eg:-m mac --mac-source 52:54:00:cc:0a:a0

iptables -t filter -A INPUT -m icmp -h    //查看模块名icmp后面接的模块

[root@hostb ~]# iptables -t filter -A FORWARD -m multiport -p tcp --sports 22,80,6379 -j ACCEPT     //多端口匹配,放行22,80,6379源端口列表
[root@hostb ~]# iptables -t filter -A FORWARD -m multiport -p tcp --dports 22,80,6379 -j ACCEPT     //多端口匹配,放行22,80,6379目标端口列表
[root@hostb ~]# iptables -t filter -nL FORWARD      //查看默认表的FORWARD链信息
[root@hostb ~]# iptables -t filter -A FORWARD -p icmp -m iprange --src-range 192.168.2.11-192.168.2.20 -j   ACCEPT    // IP范围匹配src源IP地址内允许通过  
[root@hostb ~]# iptables -t filter -I FORWARD 3 -p icmp -m mac --mac-source 52:54:00:cc:0a:a0 -j DROP        //不让ping, 禁止Mac(192.168.2.11的Mac)通过,-m mac(模块名) --mac-source(模块)

注意，这里也可以限制多个目标IP的范围，参数是--dst-range,用法与--src-range一致
--src-range  //源IP地址范围
--dst-range  //目标IP地址范围



nat 表的典型应用
(源地址转换(SNAT)--->共享一个公网IP地址上网,目标地址转换(DNAT)--->发布内网服务器,端口转换--->隐藏服务器端口)

还原防火墙:
[root@hostb ~]# iptables -t filter -P FORWARD ACCEPT
[root@hostb ~]# iptables -t filter -F FORWARD
[root@hostb ~]# iptables -t filter > /etc/sysconfig/iptables
删除a主机的网关
[root@hosta ~]# route del default gw 192.168.2.10

[root@hostb ~]# iptables -t nat -A POSTROUTING -s 192.168.4.0/24 -p tcp --dport 80 -j SNAT --to-source 192.168.2.10

[root@hostb ~]# tcpdump -i eth1 port 80  //抓包查看
[root@c ~]# curl http://192.168.2.11/t.html  //C上访问
hosta

当公司路由器的公网IP地址不固定时源地址转换规则写法:
]# iptables -t nat -A POSTROUTING -s 192.168.4.0/24 -o eth1 -j MASQUERADE





##########################################################################################################

poject02 -day1

主机                   IP地址                       角色
mysql11          192.168.4.11      MYSQL数据库服务器
mysql22          192.168.4.22      MYSQL数据库服务器
maxscale77       192.168.4.77      读写分离服务器
nfs30            192.168.4.30      共享存储服务器
web33            192.168.4.33      网站服务器
web44            192.168.4.44      网站服务器
zabbix55         192.168.4.55      监控服务器

一,部署数据库服务器MYSQL
1.创建逻辑卷 /dev/vg0/lv0  (mysql11 和 mysql22)
提前在2台虚拟机上准备2个人硬盘分别是5G大小
 fdisk /dev/vdb
 fdisk /dev/vdc
 lsblk
 vgcreate /dev/vdb1 /dev/vdc1
 pvcreate /dev/vdb1 /dev/vdc1
 yum -y install lvm2
 pvcreate /dev/vdb1 /dev/vdc1
 vgcreate vg0 /dev/vdb1 /dev/vdc1
 lvcreate -L 9.99G -n lv0 vg0
 mkfs.xfs /dev/vg0/lv0
 blkid /dev/vg0/lv0
 vgscan 

2.启动服务(mysql11 和 mysql22)

[student@room9pc01 mysql]$ for i in 11 22
> do 
>  scp mysql-5.7.17.tar root@192.168.4.$i:/root
> done

[root@mysql22 ~]# tar -xf mysql-5.7.17.tar
[root@mysql22 ~]# yum -y install mysql-comm*.rpm
[root@mysql22 ~]# vim /etc/fstab
[root@mysql22 ~]# mount -a
[root@mysql22 ~]# df -h
[root@mysql22 ~]# systemctl start mysqld
[root@mysql22 ~]# systemctl enable mysqld
[root@mysql22 ~]# ls /var/lib/mysql
[root@mysql22 ~]# netstat -plunt |grep 3306
[root@mysql22 ~]# ps aux |grep mysqld

3.管理员登录(mysql11 和 mysql22)
[root@mysql11 ~]# grep root@localhost /var/log/mysqld.log
[root@mysql11 ~]# mysql -uroot -p'*+tn>qEaT6vq'
mysql> alter user root@'localhost' identified by '123qqq...A';
[root@mysql11 ~]# mysql -uroot -p'123qqq...A'


二. 配置主从同步(mysql11为主服务器,mysql22为从服务器)
[root@mysql11 ~]# vim /etc/my.cnf
                   [mysqld]
                   server_id=11
                   log_bin=master11
[root@mysql11 ~]# systemctl restart mysqld
[root@mysql11 ~]# mysql -uroot -p123qqq...A
mysql> grant replication slave on *.* to repluser@"%" identified by "123qqq...A";
mysql> show master status;
+-----------------+----------+--------------+------------------+-------------------+
| File            | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-----------------+----------+--------------+------------------+-------------------+
| master11.000001 |      441 |              |                  |                   |



[root@mysql22 ~]# vim /etc/my.cnf
                   [mysqld]
                   server_id=11
[root@mysql22 ~]# systemctl restart mysqld
[root@mysql22 ~]# mysql -uroot -p123qqq...A
mysql> change master to master_host="192.168.4.11",master_user="repluser",master_password="123qqq...A",master_log_file="master11.000001",master_log_pos=441;
mysql> start slave;
mysql> show slave status\G;
            Slave_IO_Running: Yes
            Slave_SQL_Running: Yes

三.配置读写分离

1.在读写分离服务器maxscale上做
配置步骤如下：
安装软件
修改配置文件
配置数据库服务器
启动服务
查看服务状态
查看监控信息

[student@room9pc01 mysql]$ scp /linux-soft/03/mysql/maxscale-2.1.2-1.rhel.7.x86_64.rpm root@192.168.4.77:/root  //提供读写分离所需软件
[root@maxscale77 ~]# yum -y install maxscale-2.1.2-1.rhel.7.x86_64.rpm
[root@maxscale77 ~]# vim /etc/maxscale.cnf

[maxscale]
threads=auto

[server1]
type=server
address=192.168.4.11
port=3306
protocol=MySQLBackend

[server2]
type=server
address=192.168.4.22
port=3306
protocol=MySQLBackend

[MySQL Monitor]
type=monitor
module=mysqlmon
servers=server1,server2
user=maxscalemon
passwd=123qqq...A
monitor_interval=10000

[Read-Write Service]
type=service
router=readwritesplit
servers=server1,server2
user=maxscaleroute
passwd=123qqq...A
max_slave_connections=100%

[MaxAdmin Service]
type=service
router=cli

[Read-Write Listener]
type=listener
service=Read-Write Service
protocol=MySQLClient
port=4006

[MaxAdmin Listener]
type=listener
service=MaxAdmin Service
protocol=maxscaled
socket=default
port=4016

2. 在主服务器上添加，从服务器查看即可(从同步)
[root@mysql11 ~]# mysql -uroot -p123qqq...A     
mysql> grant replication slave,replication client on *.* to maxscalemon@"%" identified by '123qqq...A';
mysql> grant select on mysql.* to maxscalerouter@"%" identified by "123qqq...A";

[root@maxscale77 ~]# yum -y install mariadb
[root@maxscale77 ~]# maxscale  -f /etc/maxscale.cnf
[root@maxscale77 ~]# ps aux |grep maxscale
[root@maxscale77 ~]# ss -plunt |grep 4016
[root@maxscale77 ~]# ss -plunt |grep 4006
[root@maxscale77 ~]# maxadmin -uadmin -pmariadb -P4016
MaxScale> list servers
Servers.
-------------------+-----------------+-------+-------------+--------------------
Server             | Address         | Port  | Connections | Status              
-------------------+-----------------+-------+-------------+--------------------
server1            | 192.168.4.11    |  3306 |           0 | Master, Running
server2            | 192.168.4.22    |  3306 |           0 | Slave, Running

[root@maxscale77 ~]# mysql -h 192.168.4.11 -umaxscalemon -p'123qqq...A'
[root@maxscale77 ~]# mysql -h 192.168.4.22 -umaxscalemon -p'123qqq...A'
[root@maxscale77 ~]# mysql -h 192.168.4.11 -umaxscalerouter -p'123qqq...A'
[root@maxscale77 ~]# mysql -h 192.168.4.22 -umaxscalerouter -p'123qqq...A'


四. 准备NFS服务存储磁盘

1.挂载磁盘
给nfs30主机添加10G的硬盘
[root@nfs30 ~]# fdisk /dev/vdb
[root@nfs30 ~]# lsblk
vdb    253:16   0  10G  0 disk 
└─vdb1 253:17   0  10G  0 part
[root@nfs30 ~]# mkfs.xfs /dev/vdb1
[root@nfs30 ~]# mkdir /sitedir
[root@nfs30 ~]# chmod o+w /sitedir
[root@nfs30 ~]# vim /etc/fstab
/dev/vdb1 /sitedir xfs defaults 0 0 
[root@nfs30 ~]# mount -a
[root@nfs30 ~]# df -h

2.配置NFS服务
[root@nfs30 ~]# yum -y install nfs-utils rpcbind    //安装nfs软件
[root@nfs30 ~]# vim /etc/exports
/sitedir *(rw)
[root@nfs30 ~]# exportfs -r    //加载配置
[root@nfs30 ~]# systemctl start rpcbind
[root@nfs30 ~]# systemctl start nfs
[root@nfs30 ~]# systemctl enable nfs
[root@nfs30 ~]# systemctl enable rpcbind
[root@nfs30 ~]# showmount -e localhost      //查看本机共享目录
Export list for localhost:
/sitedir *

3.配置网站服务(2台web服务器都要做)
[root@web33 ~]# yum -y install httpd nfs-utils
[root@web33 ~]# showmount -e 192.168.4.30
[root@web33 ~]# echo "192.168.4.30:/sitedir /var/www/html nfs defaults 0 0 " >> /etc/fstab
[root@web33 ~]# mount -a ; df -h
[root@web33 ~]# systemctl start httpd
[root@web33 ~]# systemctl enable httpd
[root@web33 ~]# systemctl start nfs
[root@web33 ~]# systemctl enable remote-fs.target   //远程挂载服务
[root@web33 ~]# mount |grep "/var/www/html"      //查看共享信息

 
五. 测试配置
1. 测试NFS配置
 在web33上写网页文件web44是也能看到,这就是共享
[root@web33 ~]# vim /var/www/html/a.html
AAAAAAA
BBBBBB
[root@web44 ~]# curl 192.168.4.44/a.html
AAAAAAA
BBBBBB

或  在nfs共享目录里写页面,web33和web44都可以看到

[root@nfs30 ~]# echo "web test page" > /sitedir/test.html
[root@web33 ~]# curl 192.168.4.33/test.html
web test page
[root@web44 ~]# curl 192.168.4.33/test.html
web test page

2.测试MYSQL服务
[root@mysql11 ~]# mysql -uroot -p123qqq...A
mysql> create database gamedb;
mysql> grant select,insert,update,delete on gamedb.* to yaya99@"%" identified by '123qqq...A';
在web33上充当客户端访问数据库服务器
[root@web33 ~]# yum -y install mariadb
[root@web33 ~]# mysql -h192.168.4.77 -P4006 -uyaya99 -p123qqq...A



六. 升级网站运行平台
1.清空当前配置(mysql33,mysql44)
[root@web44 ~]# systemctl stop httpd
[root@web44 ~]# systemctl disable httpd
[root@web44 ~]# umount /var/www/html/
[root@web44 ~]# vim /etc/fstab
      #192.168.4.30:/sitedir /var/www/html nfs defaults 0 0 

2.部署LNMP
mariadb的软件可以不装,因为数据不存储在nginx服务器本机的数据库内
[student@room9pc01 02]$ scp /linux-soft/02/lnmp_soft.tar.gz root@192.168.4.33:/root
yum -y install gcc pcre-devel openssl-devel
tar -xf /root/lnmp_soft.tar.gz
useradd -s /sbin/nologin nginx
cd /root/lnmp_soft
tar -xf nginx-1.12.2.tar.gz
cd nginx-1.12.2
./configure
make
make install
cd ~
yum -y install mariadb mariadb-server mariadb-devel
yum -y install php php-mysql php-fpm
[root@web33 ~]# vim /etc/fstab 
       192.168.4.30:/sitedir /usr/local/nginx/html/ nfs defaults 0 0 
[root@web33 ~]# mount -a
[root@web33 ~]# systemctl enable remote-fs.target
/usr/local/nginx/sbin/nginx
systemctl start mariadb
systemctl enable mariadb
systemctl start php-fpm
systemctl enable php-fpm
sed -i '65,71s/#//;70s/fastcgi_params/fastcgi.conf/;69d' /usr/local/nginx/conf/nginx.conf
cp /root/lnmp_soft/php_scripts/mysql.php /usr/local/nginx/html/
/usr/local/nginx/sbin/nginx -s reload


七. 部署缓存服务器
redisA 192.168.4.51:6379
redisB 192.168.4.52:6379
redisC 192.168.4.53:6379
redisD 192.168.4.54:6379
redisE 192.168.4.56:6379
redisF 192.168.4.57:6379
mgm    192.168.4.58  管理主机

1. 搭建 redis 服务器 (A--F都做)
1)配置管理主机
[root@redisA ~]# rpm -q gcc || yum -y
install gcc    //安装编译工具
[root@redisA ~]# tar -zxvf redis-4.0.8.tar.gz   //解压
[root@redisA ~]# cd redis-4.0.8/      //进源码目录
[root@redisA redis-4.0.8]# make install //安装软件
[root@redisA redis-4.0.8]# ./utils/install_server.sh //初始化配置  6次回车
[root@redisA redis-4.0.8]# vim /etc/redis/6379.conf //修改配置文件,启用集群配置
70 bind 192.168.4.51
815 cluster-enabled yes
823 cluster-config-file nodes-6379.conf
829 cluster-node-timeout 5000
:wq
[root@redisA redis-4.0.8]# /etc/init.d/redis_6379 start //启动服务
[root@redisA redis-4.0.8]# netstat -utnlp | grep redis-server //查看端口

2). 创建 redis 集群

[student@room9pc01 ~]$ scp /linux-soft/03/redis/redis-3.2.1.gem root@192.168.4.58:/root
[student@room9pc01 ~]$ scp /linux-soft/03/redis/redis-4.0.8.tar.gz root@192.168.4.58:/root
[root@mgm ~]# yum -y install ruby rubygems //安装依赖
[root@mgm ~]# gem install redis-3.2.1.gem //安装依赖软件 gem 程序
[root@mgm ~]# mkdir /root/bin;
[root@mgm ~]# tar -xf redis-4.0.8.tar.gz;
[root@mgm ~]# cd redis-4.0.8/src;
[root@mgm ~]# cp redis-trib.rb /root/bin;
[root@mgm ~]# chmod +x /root/bin/redis-trib.rb
[root@mgm ~]# redis-trib.rb create --replicas 1 192.168.4.51:6379 192.168.4.52:6379 192.168.4.53:6379 192.168.4.54:6379 192.168.4.56:6379 192.168.4.57:6379
[root@mgm ~]# redis-trib.rb info 192.168.4.51:6379       //查看集群主服务器信息
[root@mgm ~]# redis-trib.rb check 192.168.4.51:6379      //查看集群详细信息

3)查看集群信息
[root@mgm ~]# redis-trib.rb info 192.168.4.51:6379 //查看集群信息

4)测试配置(在客户端连接集群中的任意一台服务器存取数据)
[root@client51 ~]# redis-cli -c -h 192.168.4.51 -p 6379 //连接服务器 51


3. 配置网站服务器(web33 web44)
1)  配置 PHP 支持 redis 服务
安装软件
[root@web33 ~ ]# yum -y install php-devel //安装依赖
[root@web33 ~]# tar -zxvf redis-cluster-4.3.0.tgz //解压
[root@web33 ~]# cd redis-4.3.0/ //进入源码目录
[root@web33 redis-4.3.0]# phpize //创建 configure 命令及配置信息文件/usr/bin/php-config
root@web33 redis-4.3.0]# ./configure --with-php-config=/usr/bin/php-config
[root@web33 redis-4.3.0]# make && make install //编译 安装
Installing shared extensions:   /usr/lib64/php/modules/   //提示模块安装目录
 [root@web44 redis-4.3.0]# ls /usr/lib64/php/modules/ //查看目录列表
curl.so fileinfo.so json.so mysqli.so mysql.so pdo_mysql.so pdo.so
pdo_sqlite.so phar.so redis.so sqlite3.so zip.so

2). 修改配置文件
[root@web33 redis-4.3.0]# vim /etc/php.ini
728 extension_dir = "/usr/lib64/php/modules/"      //模块目录
730 extension = "redis.so"           //模块名
:wq
[root@web33 redis-4.3.0]# systemctl restart php-fpm //重启 php-fpm 服务
[root@web33 redis-4.3.0]# php -m | grep -i redis   //查看模块
redis

4.测试配置
1)在存储服务器共享目录下,创建连接集群 PHP 脚本
[root@nfs30 ~]#  vim /sitedir/set_data.php   //存储数据脚本
<?php
$redis_list = ['192.168.4.51:6379','192.168.4.52:6379','192.168.4.53:6379','192.168.4.54:6379','192.168.4.56:6379','192.168.4.57:6379']; //定义 redis 服务器列表
$client = new RedisCluster(NUll,$redis_list);   //定义连接 redis 服务器变量
$client->set("i","tarenaA ");   //存储数据 变量名 i
$client->set("j","tarenaB ");   //存储数据 变量名 j
$client->set("k","tarenaC ");
?>

[root@nfs30 ~]# cat /sitedir/get_data.php    //获取数据脚本
<?php
$redis_list = ['192.168.4.51:6379','192.168.4.52:6379','192.168.4.53:6379','192.168.4.54:6379','192.168.4.56:6379','192.168.4.57:6379'];  //定义 redis 服务器列表
$client = new RedisCluster(NUll,$redis_list);   //定义连接 redis 服务器变量
echo $client->get("i");       //获取变量 i 的数据
echo $client->get("j");
echo $client->get("k");
?>

[root@nfs30 ~]# cat /sitedir/test3.php    //存/取数据脚本
<?php
$redis_list = ['192.168.4.51:6379','192.168.4.52:6379','192.168.4.53:6379','192.168.4.54:6379','192.168.4.56:6379','192.168.4.57:6379'];
$client = new RedisCluster(NUll,$redis_list);
$client->set("name","panglijing");      //存数据
echo $client->get("name");          //取数据
?>

2)访问网站执行脚本(在任意主机访问网站服务器都可以)
]# curl http://192.168.4.33/set_data.php
]# curl http://192.168.4.33/get_data.php
]# curl http://192.168.4.33/test3.php

3)命令行连接任意一台 redis 服务器查看数据(在任意主机连接 redis 服务器都可以)
]# redis-cli -c -h 192.168.4.51 -p 6379
192.168.4.51:6379> keys *


八. 数据迁移
要求如下:
1) 配置从服务器
2) 配置第 1 台 PXC 服务器
3) 配置第 2 台 PXC 服务器
4) 配置第 3 台 PXC 服务器
5) 公共配置
6) 测试配置
准备3台pxc集群主机:pxcnode66,pxcnode10,pxcnode88

1. 配置从服务器pxcnode66(为mysql11的从) ,在pxcnode66安装MYSQL并指定server_id=66
[student@room9pc01 ~]$ scp /linux-soft/03/mysql/mysql-5.7.17.tar root@192.168.4.66:/root
[root@pxcnode66 ~]# tar -xf mysql-5.7.17.tar 
[root@pxcnode66 ~]# yum -y install mysql-comm*.rpm
[root@pxcnode66 ~]# vim /etc/my.cnf
       server_id=66
[root@pxcnode66 ~]# systemctl start mysqld
[root@pxcnode66 ~]# systemctl enable mysqld //设置服务开机运行
[root@pxcnode66 ~]# ss -plunt |grep 80
[root@pxcnode66 ~]# grep password /var/log/mysqld.log
[root@pxcnode66 ~]# mysql -uroot -p'p>a?ok6?NHuL'
mysql> alter user root@'localhost' identified by '123qqq...A';

确保数据一致在MYSQL11上使用innobackupex在线热备份命令,备份MYSQL11上的数据
[student@room9pc01 ~]$ scp /linux-soft/03/mysql/percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm root@192.168.4.11:/root
[student@room9pc01 ~]$ scp /linux-soft/03/mysql/libev-4.15-1.el6.rf.x86_64.rpm root@192.168.4.11:/root
[root@mysql11 ~]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm 
[root@mysql11 ~]# yum -y install percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm

[root@mysql11 ~]# innobackupex --user root --password 123qqq...A --slave-info /allbak --no-timestamp  //备份所有数据,并记录备份数据对应的 binlog 日志名
[root@mysql11 ~]# scp -r /allbak  root@192.168.4.66:/root/    //把备份文件发送给pxcnode66 主机

在pxcnode66上安装innobackupxe 命令恢复数据
[student@room9pc01 ~]$ scp /linux-soft/03/mysql/percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm root@192.168.4.66:/root
[student@room9pc01 ~]$ scp /linux-soft/03/mysql/libev-4.15-1.el6.rf.x86_64.rpm root@192.168.4.66:/root
[root@pxcnode66 ~]# systemctl stop mysqld //停止服务
[root@pxcnode66 ~]# rm -rf /var/lib/mysql/* //清空数据库目录
[root@pxcnode66 ~]# innobackupex --apply-log /root/allbak/ //准备恢复数据
[root@pxcnode66 ~]# innobackupex --copy-back /root/allbak/ //恢复数据
[root@pxcnode66 ~]# chown -R mysql:mysql /var/lib/mysql //修改所有者
[root@pxcnode66 ~]# systemctl start mysqld //启动服务

[root@pxcnode66 ~]# cat /root/allbak/xtrabackup_info | grep master11 //查 binlog日志
binlog_pos = filename 'master11.000001', position '7700'
[root@pxcnode66 ~]# mysql -uroot -p123qqq...A //管理员登录指定主服务器信息
注意如果其它集群的pxc服务无法启动添加sstuser数据同步授权用户

mysql> change master to
master_host="192.168.4.11", //主服务器 ip 地址
master_user="repluser", //主服务器授权用户
master_password="123qqq...A", //授权密码
master_log_file="master11.000001", //binlog 日志名
master_log_pos=7700; //日志偏移量
Query OK, 0 rows affected, 2 warnings (0.31 sec)

mysql> start slave ; //启动 slave 程序
mysql> show slave status\G;
Slave_IO_Running: Yes    //IO 线程正常
Slave_SQL_Running: Yes   //SQL 线程正常
 
[root@web33 ~]# mysql -h 192.168.4.11 -uyaya99 -p123qqq...A   //客户端连接MYSQL11主服务器查看

2. 配置第1台pxc服务器
[root@pxcnode66 ~]# yum -y remove Percona-XtraDB-Cluster-*.rpm
[student@room9pc01 03]$ scp -r /linux-soft/03/PXC/  root@192.168.4.88:/root
[student@room9pc01 03]$ scp -r /linux-soft/03/PXC/  root@192.168.4.66:/root
[student@room9pc01 03]$ scp -r /linux-soft/03/PXC/  root@192.168.4.10:/root

1)停止 mysqld 服务、卸载 mysqld 服务软件
[root@pxcnode66 ~]# systemctl stop mysqld //停止服务
[root@pxcnode66 ~]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm;   //依赖包
[root@pxcnode66 ~]# yum -y install percona-xtrabackup-24-2.4.13-1.el7.x86_64.rpm;  //在线热备程序
[root@pxcnode66 ~]# rpm -ivh qpress-1.1-14.11.x86_64.rpm;                 //剃归压缩程序
[root@pxcnode66 ~]# tar -xf Percona-XtraDB-Cluster-5.7.25-31.35-r463-el7-x86_64-bundle.tar;   
[root@pxcnode66 ~]# yum -y install Percona-XtraDB-Cluster-*.rpm           //集群服务程序
[root@pxcnode66 PXC]# vim /etc/percona-xtradb-cluster.conf.d/mysqld.cnf //修改数据库服务配置文件
                               [mysqld]
                               server-id=66 //指定 server_id
[root@pxcnode66 PXC]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf //修改集群服务配置文件
wsrep_cluster_address=gcomm:       //不需要写 ip 地址
wsrep_node_address=192.168.4.66     //指定本机 Ip 地址
wsrep_cluster_name=pxc-cluster      //指定集群名称(另外 2 台的集群名称要于此相同)
wsrep_node_name=pxcnode66           //指定本机主机名
wsrep_sst_auth="sstuser:123qqq...A" //数据全量同步授权用户及密码
[root@pxcnode66 PXC]# systemctl start mysql //启动服务
[root@pxcnode66 PXC]# netstat -utnlp | grep :3306 //查看 MySQL 服务端口
[root@pxcnode66 PXC]# netstat -utnlp | grep :4567 //查看集群通信端口
[root@pxcnode66 PXC]# systemctl enable mysql //设置服务开机运行
[root@pxcnode66 PXC]# mysql -uroot -p123qqq...A //管理员登录
mysql> grant all on *.* to sstuser@"localhost" identified by "123qqq...A"; //用户授权
mysql> show status like "%wsrep%"; //查看集群状态信息
wsrep_incoming_addresses  192.168.4.66:3306
wsrep_connected   | ON
wsrep_ready       | ON
mysql> show slave status\G;
Slave_IO_Running: Yes    //IO 线程正常
Slave_SQL_Running: Yes   //SQL 线程正常
[root@pxcnode66 ~]#

3. 配置第 2 台 PXC 服务器(192.168.4.10)
同pxcnode66的配置---->
wsrep_cluster_address=gcomm://192.168.4.66,192.168.4.10   //集群成员列表

4.配置第 3 台 PXC 服务器(192.168.4.88)
同pxcnode66的配置---->
wsrep_cluster_address=gcomm://192.168.4.66            //集群成员列表

5. 公共配置(192.168.4.88、192.168.4.10、192.168.4.66) 3台都改
[root@pxcnode88 ~]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf
wsrep_cluster_address=gcomm://192.168.4.66,192.168.4.10,192.168.4.88 //指定集群成员列表

6. 测试配置:在网站服务器连接 PXC 集群主机存取数据:
1)存储数据:在网站服务器连接 PXC 集群主机存储数据
[root@web33 ~]# mysql -h192.168.4.66 -uyaya99 -p123qqq...A gamedb
Mysql> insert into gamedb.user values (“pljA”);
Mysql> exit ;
2)查询数据:在网站服务器连接 PXC 集群主机查询数据
[root@web44 ~]# mysql -h192.168.4.66 -uyaya99 -p123qqq...A gamedb  //分别查看66,10,88主机
Mysql> select * from gamedb.user;
+------+
| name|
+------+
| pljA|
| pljB|
| pljC|
+------+
Mysql> exit ; 



九. 部署 LB 集群
配置步骤如下:
1) 安装软件
2) 修改配置文件
3) 启动服务
4) 测试配置

创建 1 台新的虚拟机,配置 ip 地址 eth0 192.168.4.99主机名 haproxy99 ;运行 haproxy 服务 接受客户端访问数据库的连接请求,把请求平均分发给 3 台 PXC 集群主机
1. 安装软件: 在 haproxy99 主机上安装 haproxy 软件
[root@haproxy99 ~]# yum -y install haproxy

2. 修改配置文件
[root@haproxy99 ~]# vim /etc/haproxy/haproxy.cfg
Global //全局配置默认即可
log 127.0.0.1 local2
chroot /var/lib/haproxy
pidfile /var/run/haproxy.pid
maxconn 4000
user haproxy
group haproxy
daemon
stats socket /var/lib/haproxy/stats
defaults //默认配置(不需要修改)
mode http
log global
option httplog
option dontlognull
option http-server-close
option forwardfor except 127.0.0.0/8
option redispatch
retries 3
timeout http-request 10s
timeout queue 1m
timeout connect 10s
timeout client 1m
timeout server 1m
timeout http-keep-alive 10s
timeout check 10s
maxconn 3000

listen status //定义监控页面
mode http //模式为 http
bind *:80 //端口 80
stats enable //启用配置
stats uri /admin //访问目录名
stats auth admin:admin  //登录用户与密码
listen mysql_3306 *:3306 //定义 haproxy 服务名称与端口号
mode tcp   //mysql 服务 得使用 tcp 协议
option tcpka   //使用长连接
balance roundrobin //调度算法
server mysql_01 192.168.4.66:3306 check //第 1 台数据库服务器
server mysql_02 192.168.4.10:3306 check //第 2 台数据库服务器
server mysql_03 192.168.4.88:3306 check //第 3 台数据库服务器

[root@haproxy99 ~]# systemctl start haproxy //启动服务
[root@haproxy99 ~]# systemctl enable haproxy //开机运行
[root@haproxy99 ~]# netstat -utnlp | grep :3306 //查看端口

3.测试配置:在网站服务器连接 haproxy99 主机访问数据
[root@web33 ~]# mysql –h192.168.4.99 –uyaya99 –p123qqq...A -e 'select @@hostname'
| @@hostname |
+------------+
| pxcnode66 | //第 1 次连接

[root@web33 ~]# mysql –h192.168.4.99 –uyaya99 –p123qqq...A -e 'select @@hostname'
| @@hostname |
+------------+
| pxcnode66 | //第 1 次连接

[root@web33 ~]# mysql –h192.168.4.99 –uyaya99 –p123qqq...A -e 'select @@hostname'
@@hostname |
+------------+
| pxcnode88 | //第 3 次连接


十. 部署 HA 集群
 
问题
具体配置如下:
1) 准备备用调度器主机
2) 安装软件
3) 修改配置文件
4) 启动服务
创建 1 台新的虚拟机, 在 eth0 接口配置 ip 地址为192.168.4.98 做备用调度器
1.准备备用调度器主机
1)克隆好虚拟机后配置 ip 地址、设置主机名
2) 在 haproxy98 主机安装 haproxy 软件
[root@haproxy98 ~]# yum -y install haproxy
3)修改 haproxy98 主机 haproxy.conf 文件(直接拷贝 haproxy99 主机的配置文件也可以)
[root@haproxy98 ~]# scp root@192.168.4.99:/etc/haproxy/haproxy.cfg /etc/haproxy/
4)启动 haproxy 服务
[root@haproxy98 ~]# systemctl start haproxy  //启动服务
[root@haproxy98 ~]# systemctl enable haproxy //服务开机运行
[root@haproxy98 ~]# netstat -utnlp | grep :3306 //查看端口

2. 安装软件
1)在 haproxy99 主机安装 keepalived 软件
[root@haproxy99 ~]# yum -y install keepalived.x86_64
2)在 haproxy98 主机安装 keepalived 软件
[root@haproxy98 ~]# yum -y install keepalived.x86_64

3. 修改配置文件

[root@haproxy99 ~]# sed -i '36,$d' /etc/keepalived/keepalived.conf  //删除无关的配置行
[root@haproxy99 ~]#vim /etc/keepalived/keepalived.conf
global_defs {
......
......
vrrp_iptables //禁止 iptables
}
vrrp_instance VI_1 {
state MASTER //主服务器标识
interface eth0
virtual_router_id 51
priority 150      //haproxy99 主机做主服务器,优先级要比 haproxy88 主机高
advert_int 1
authentication {
auth_type PASS //主备服务器连接方式
auth_pass 1111 //连接密码
}
virtual_ipaddress {
192.168.4.100 //定义 vip 地址
}
}
[root@haproxy99 ~]# scp /etc/keepalived/ root@192.168.4.98:/etc/keepalived/keepalived.conf

2)修改 haproxy98 主机的配置文件
 state BACKUP //备用服务器标识
 priority 100   //优先级要比 haproxy99 低
其它一样

4. 启动服务
1)在 haproxy99 主机启动 keepalived 服务
[root@haproxy99 ~]# systemctl start keepalived.service //启动服务
[root@haproxy99 ~]# ip addr show | grep 192.168.4.100  //查看 vip 地址
2)在 haproxy98 主机启动 keepalived 服务
[root@haproxy98 ~]# systemctl start keepalived.service //启动服务
[root@haproxy98 ~]# ip addr show | grep 192.168.4.100 //查看不到 vip

5. 测试配置
1)客户端连接 vip 地址,访问数据库服务
[root@web33 ~]# mysql -h192.168.4.100 –uyaya99 –p123qqq...A -e 'select @@hostname'
@@hostname |
+------------+
| pxcnode66
[root@web33 ~]# mysql -h192.168.4.100 –uyaya99 –p123qqq...A -e 'select @@hostname'
@@hostname |
+------------+
| pxcnode10
[root@web33 ~]# mysql -h192.168.4.100 –uyaya99 –p123qqq...A -e 'select @@hostname'
@@hostname |
+------------+
| pxcnode88

[root@haproxy99 ~]# systemctl stop keepalived.service //停止 keepalived 服务
[root@haproxy99 ~]# ip addr show | grep 192.168.4.100 //查看不到 vip 地址
[root@haproxy98 ~]# ip addr show | grep 192.168.4.100 //在备用的 haproxy98 主机查看地址



####################################################################################################

                                          云平台
date 1

www.libvirt.org


yum -y install git

外地校区,git clone git://43.254.90.134/nsd1907.git

base-vm 名称  //克隆虚拟机脚本
eip (ip地址最后一部分)  //快速设置IP地址脚本,但需要reboot  一个虚拟机只能设置一次,位置/usr/local/bin/eip

lsmod    //列出已加载的内核模块

虚拟化概念
virtualization资源管理
x个物理资源--->y个逻辑资源  (x>y)
实现程度: 完全,部分,硬件辅助(CPU)

安装kvm软件
qemu-kvm ---->为kvm提供底层仿真支持
libvirt-daemon --->libvirtd守护进程,管理虚拟机
libvirt-client---->用户端软件,提供客户端管理命令
libvirt-daemon-driver-qemu--->libvirtd连接qemu的驱动

可选功能
virt-install    //系统安装工具
virt-manager    //图形管理工具
virt-v2v        //虚拟机迁移工具
virt-p2v        //物理机迁移工具

kvm虚拟机的组成
--内核虚拟化模块(kvm)
--系统设备仿真(qemu)
--虚拟机管理程序(libvirt)

--一个xml文件(虚拟机配置声明文件)---->/etc/libvirt/qemu/
--一个磁盘镜像文件(虚拟机的硬盘)---->/var/lib/libvirt/images/

格式:virsh 控制指令 [虚拟机名称]  [参数]
virsh list [--all]               //列出虚拟机
virsh start|shutdown|reboot 名称  // 虚拟机启动 ,停止, 重启
virsh destroy 强制停止虚拟机
virsh define|undefine 名称         //根据xml文件 创建,删除虚拟机
virsh console 名称                   //连接虚拟机的console控制台

virsh edit 名称                       //修改虚拟机的配置
virsh autostart  名称               //设置虚拟机自启动
virsh domiflist  名称               //查看虚拟机网卡信息
virsh domblklist  名称              //查看虚拟机硬盘信息
virsh dominfo nsd1907           //查看指定虚拟机信息


virsh 虚拟网络管理
net-list [--all]     //列出虚拟网络
net-start            //启动虚拟交换机
net-destroy          //强制停止虚拟交换机
net-define           //根据xml文件 创建虚拟网络
net-undefine         //删除一个虚拟网络设备
net-edit             //修改虚拟交换机的配置
net-autostart        //设置虚拟交换机自启动

qemu-img 命令
qemu-img是虚拟机的磁盘管理命令,支持非常多的磁盘格式

格式:  qemu-img 命令 参数 块文件名称  大小

命令  : 
create  创建一个磁盘
convert 转换磁盘格式
info    查看磁盘信息
resize  扩容磁盘空间

创建新的镜像盘文件
qemu-img create -f 格式 磁盘路径 大小

查询镜像盘文件的信息
qemu-img info 磁盘路径

❤  -b 使用后端模板文件
qemu-img create -b 后端盘 -f qcow2 前端盘名称 大小

eg:qemu-img create -b disk.img -f qcow2 nova01.img 10G

Copy On Write 写时复制
--直接映射原始盘的数据内容
--当数据有修改要求时,在修改之前自动将旧数据拷贝存入前端盘后,对前端盘进行修改
--原始盘始终是只读的	`	


创建XML文件
对虚拟机的配置进行调整
virsh edit 虚拟机名称    ---->修改CPU memory(内存) 磁盘 网络

克隆虚拟机:
1). 创建虚拟机 镜像文件(.img) ---->qcow2格式
cd /var/lib/libvirt/images/
qemu-img create -f qcow2 -b node.qcow2 nsd1907.img 20G
2). 修改xml文件(注意xml文件的权限)
cp /var/lib/libvirt/images/.node_base.xml /etc/libvirt/qemu/nsd1000.xml
sed -i "9s/node_base/nsd1907/;33s/node_base/nsd1907/" /etc/libvirt/qemu/nsd1907.xml
3). 定义xml文件
virsh define /etc/libvirt/qemu/nsd1907.xml
4). 开启虚拟机
virsh start nsd1907

网络配置文件说明
-----/etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE="eth0"    //驱动名称
ONBOOT="yes"     //开机启动
NM_CONTROLLED="no"   //不接受networkmanager控制
TYPE="Ethernet"      //类型
BOOTPROTO="static"   //协议(dhcp|static|none)
IPADDR="192.168.1.10" //ip地址
NETMASK="255.255.255.0" //子网掩码
GATEWAY="192.168.1.254" //默认网关


virsh 扩容磁盘:
 [student@room9pc01 ~]$ virsh domblklist openstack     //查看虚拟机openstack硬盘信息
 [student@room9pc01 ~]$ virsh blockresize --path /var/lib/libvirt/images/openstack.img --size 50G openstack  //扩容硬盘
 [root@openstack ~]# LANG=C     //语言必须设置为英语
 [root@openstack ~]# /usr/bin/growpart /dev/vda 1    //扩容第一个分区
 [root@openstack ~]# /usr/sbin/xfs_growfs /          //扩容文件系统
 [root@openstack ~]# lsblk                           //查看硬盘空间

云计算:
云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问，进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互,可简单理解为动态的服务器集群

IAAS: 基础设施即服务 (三种用法: 公有云、私有云、混合云) ----->openstack是一套IAAS解决方案
PAAS: 平台即服务  --->应用基础设施服务
SAAS: 软件即服务





 
#####################################################################33

date 2

什么是Openstack  七大主键
Openstack 是一个开源的云计算管理平台,是一套Iaas 解决方案,是有NASA和Rackspace合作研发的项目.他有七大主键

Horizon ---->用于管理openstack各种服务,基于web的管理接口
Swift --->对象存储
Quantum --->网络主键
Nova ----->计算节点,管理虚拟机的服务
GLance ----->扮演虚拟机镜像注册的角色
Cinder ------> 为虚拟机管理存储卷的服务
Keystone ----->为其它服务提供认证和授权的集中身份管理服务,也提供集中的目录服务
Neutron ----> 一种软件定义网络服务

安装Openstack 
1.先检查内存  --->free -m 要16G

2.创建虚拟机openstack和nova01和nova02(计算节点)
openstack管理主机 2CPU,8G内存,50G硬盘 IP-->192.168.1.10
nova01计算节点 2CPU,4G内存,100G硬盘IP--->192.168.1.11	
nova02计算节点 2CPU,4G内存,100G硬盘IP--->192.168.1.12

3. 配置主机名 /etc/hosts(3台都配置)
在/etc/hosts里添加 192.168.1.10 openstack,192.168.1.11 nova01,192.168.1.12 nova02

4. 能够相互ping通,也可以ping通外网

5.配置DNS服务器/etc/resolv.conf(3台都配置)
 在配置文件/etc/resolv.conf里 去掉search开头的所有行

6.NTP时间同步(3台都配置)
/etc/chrony.conf
server 192.168.1.254 iburst
[root@openstack ~]# systemctl restart chronyd
验证:[root@openstack ~]# chronyc sources -v    -->出现^* gateway就成功(其中chronyc中的c表示客户端)

7.配置yum仓库
三台主机配置yum源（以一台主机为例，共10670个软件包）

[student@room9pc01 ~]$ cd /linux-soft/04/openstack/
[student@room9pc01 openstack]$ ls
cirros.qcow2  RHEL7-extras.iso  RHEL7OSP-10.iso  small.qcow2
[student@room9pc01 openstack]$ mkdir /var/ftp/RHEL7-extras
[student@room9pc01 openstack]$ mkdir /var/ftp/RHEL7OSP-10
[student@room9pc01 openstack]$ mount RHEL7-extras.iso  /var/ftp/RHEL7-extras/     //注意这里只是临时挂载
mount: /dev/loop1 写保护，将以只读方式挂载
[student@room9pc01 openstack]$ mount RHEL7OSP-10.iso /var/ftp/RHEL7OSP-10/
mount: /dev/loop2 写保护，将以只读方式挂载
[root@openstack ~]# vim /etc/yum.repos.d/local.repo
[local_repo]
name=CentOS-$releasever - Base
baseurl="ftp://192.168.1.254/centos-1804"
enabled=1
gpgcheck=1
[RHEL7-extras]
name=RHEL7-extras
baseurl="ftp://192.168.1.254/RHEL7-extras"
enabled=1
gpgcheck=0      //没有秘钥,不检测签名

[RHEL7OSP-package]
name=RHEL7OSP-package
baseurl="ftp://192.168.1.254/RHEL7OSP-10/rhel-7-server-openstack-10-rpms"
enabled=1
gpgcheck=0
[RHEL7OSP-devtools]
name=RHEL7OSP-devtools
baseurl="ftp://192.168.1.254/RHEL7OSP-10/rhel-7-server-openstack-10-devtools-rpms"
enabled=1
gpgcheck=0
[root@openstack ~]# scp /etc/yum.repos.d/local.repo 192.168.1.11:/etc/yum.repos.d/
root@192.168.1.11's password: 
local.repo                                                                                          100%  490   484.4KB/s   00:00  
  
[root@openstack ~]# scp /etc/yum.repos.d/local.repo 192.168.1.12:/etc/yum.repos.d/
root@192.168.1.12's password: 
local.repo

8. 安装额外软件包
在nova01和nova02上安装软件
[root@room9pc01 ~]# for i in 11 12; do  ssh root@192.168.1.$i "yum -y install qemu-kvm libvirt-daemon libvirt-daemon-driver-qemu libvirt-client python-setuptools;systemctl start libvirtd"; done

在openstack上安装软件:
[root@openstack ~]# yum -y install python-setuptools

安装之前需要30分钟左右,所以要提前检查安装环境:(3台)

是否卸载firewalld 和 NetworkManager ---->rpm -qa | grep -i "firewall|networkmanager"
检查配置主机网络参数（静态IP） ------->cat /etc/sysconfig/network-scripts/ifcfg-eth0 (BOOTPROTO="static")
主机名必须能够相互 ping 通  ------->[root@openstack ~]# ping nova01  ping nova02 ......相互ping通
检查配置主机yum源（4个，10670）----->[root@openstack ~]# yum repolist  10670
依赖软件包是否安装    ------>在nova01和nova02   systemctl status libvirtd  查看服务状态
检查NTP服务器是否可用  -------->chronyc sources -v (^* gateway)
检查 /etc/resolv.conf 不能有 search 开头的行   ------->grep search /etc/resolv.conf


9. 部署Openstack(在openstack上安装)
[root@openstack ~]# yum install -y openstack-packstack
[root@openstack ~]# packstack --gen-answer-file=answer.ini   //生成应答文件  answer.ini与answer.txt是一样的，只是用vim打开answer.ini文件有颜色

[root@openstack ~]# vim answer.ini
42  CONFIG_SWIFT_INSTALL=n                        //SWIFT模块不用 关掉
45  CONFIG_CEILOMETER_INSTALL=n                   //计费相关模块
49  CONFIG_AODH_INSTALL=n                         //计费相关模块
53  CONFIG_GNOCCHI_INSTALL=n                      //计费相关模块
75  CONFIG_NTP_SERVERS=192.168.1.254              //时间服务器的地址
98  CONFIG_COMPUTE_HOSTS=192.168.1.11             //安装nova节点
102 CONFIG_NETWORK_HOSTS=192.168.1.10,192.168.1.11 //配置NETWORK主键
333 CONFIG_KEYSTONE_ADMIN_PW=a     //修改管理员的密码
840 CONFIG_NEUTRON_ML2_TYPE_DRIVERS=flat,vxlan   //驱动类型 flat直连网络,vxlan高级vlan(解决vlan个数只有4096个的数量)
876 CONFIG_NEUTRON_ML2_VXLAN_GROUP=239.1.1.5   //设置组播地址,最后一个随意不能为0和255,其他固定 
910 CONFIG_NEUTRON_OVS_BRIDGE_MAPPINGS=physnet1:br-ex  //物理网桥的名称
921 CONFIG_NEUTRON_OVS_BRIDGE_IFACES=br-ex:eth0   //br-ex桥的名称与eth0连接，管理eth0,网桥与哪个物理网卡连接
1179 CONFIG_PROVISION_DEMO=n   //DEMO是否测试

 [root@openstack ~]# packstack --answer-file=answer.ini    //切记安装过程中不能停止,也不能Ctrl+c 
Welcome to the Packstack setup utility
输入11的密码:
输入12的密码:
**** Installation completed successfully ******        //出现这个为成功


10. 网络管理
root@openstack ~]# systemctl list-unit-files     //列出虚拟机所有服务

查看外部OVS网桥
1）查看br-ex网桥配置（br-ex为OVS网桥设备）
[root@openstack ~]# cat /etc/sysconfig/network-scripts/ifcfg-br-ex 
2）查看eth0网卡配置（该网卡为OVS网桥的接口）
[root@openstack ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 
3) 验证OVS配置
[root@openstack ~]# ovs-vsctl show

11. web页面登录:

firefox 192.168.1.10  //访问失败(因为配置文件默认错误)
需要改配置文件并重新加载
[root@openstack conf.d]# vim 15-horizon_vhost.conf
     35   WSGIProcessGroup apache
     36   WSGIApplicationGroup %{GLOBAL}     //添加这一行

[root@openstack conf.d]# apachectl -t   //检测httpd配置是否错误
[root@openstack conf.d]# apachectl  graceful  //重新载入配置文件
[root@openstack conf.d]# firefox 192.168.1.10  输入用户名和密码


命令行登录:
[root@openstack ~]# source keystonerc_admin   //初始化环境变量
[root@openstack ~(keystone_admin)]# openstack user list
创建名为myproject的项目
[root@openstack ~(keystone_admin)]# openstack project create myproject
查看项目信息
[root@openstack ~(keystone_admin)]# openstack project list
更新vcpu配额为30
[root@openstack ~(keystone_admin)]# nova quota-update --cores 30 myproject
删除myproject
[root@openstack ~(keystone_admin)]# openstack project delete myproject


安装openstack可能会出现的错误以及排错方法

1）ntp时间不同步 ---->Error: /usr/sbin/ntpdate 192.168.1.254 returned 1 instead of one [0]
解决办法：查看ntp时间服务器，是否出现*号，若没有，查看配置文件，配置ntp服务器
[root@room9pc01 ~]# chronyc sources -v    //出现*号代表NTP时间可用

2）网桥名称写错  ----->Error: /usr/bin/ovs-vsctl list ports br-exeth0 returned 1:ovs-vsctl:no bridge named br-exeth0
解决办法：检查配置文件
[root@openstack ~]# vim answer.ini
...
921 CONFIG_NEUTRON_OVS_BRIDGE_IFACES=br-ex:eth0   //br-ex桥的名称与eth0连接，管理eth0,网桥与哪个物理网卡连接

3）若/root/.ssh/id_rsa.pub，提示password，同样是配置文件没有写对

4）yum源没有配置正确
解决办法：检查yum是否为10853个软件包，查看是否是yum源没有配置正确，之后安装oprnstack-dashboard


5）出现Cannot allocate memory
解决办法：
内存不足，重新启动主机

6）出现/usr/bin/systemctl start openvswith ... falied，说明是ssse3指令集的错误

解决办法：编辑openstack的xml文件，在里面添加
  <cpu mode='host-passthrough'>
  </cpu>

7）若出现 Could not prefetch... ‘openstack’。 
配置文件里面有中文符号

8）访问openstack出错
没有修改Apache配置文件

###############################################################################


date 3

1. 创建项目分配资源
1). 创建项目
创建项目-->带*必填(部分有默认值) 名称  tedu --->配额* 创建项目

2). 添加授权用户
用户-->创建用户-->用户名*  uu, 密码 a, 主项目 tedu, 角色 _member_,  --->创建用户

3). 用uu用户登录私有云openstack
用户名: uu -->密码: a

2. 云主机类型管理
管理员-->云主机类型-->创建云主机类型-->名称 abc,vcpu 2,内存 512M, 根磁盘 5G -->创建云主机类型

3. 镜像管理(红帽官方下载的small.qcow2)
[student@room9pc01 openstack]$ pwd
/linux-soft/04/openstack
[student@room9pc01 openstack]$ ls
cirros.qcow2  RHEL7-extras.iso  RHEL7OSP-10.iso  small.qcow2
[student@room9pc01 openstack]$ qemu-img info small.qcow2     //查看镜像格式
image: small.qcow2
file format: qcow2

管理员-->镜像-->创建镜像-->镜像名称 centos6, 文件 (浏览 /linux-soft/04/openstack/small.qcow2),镜像格式 QCOW2-QEMU模拟器 -->创建镜像

4. 网络管理
1). 公共网络(由openstack云管理员创建-->费用昂贵)-->能访问互联网

管理员-->网络-->创建网络-->名称 wan, 项目 tedu, 供应商网络类型 float(直连路由),物理网络 physent_tedu, 共享的 √,外部模式 √ -->提交

切换用户uu -->项目-->网络-->网络拓扑-->点击左边长条的wan-->增加子网-->子网名称 wan_subnet,网络地址 192.168.1.0/24, 网关IP 192.168.1.254 ,下一步 -->子网详情 -->激活DHCP √ 去掉 -->分配地址池 192.168.1.150,192.168.1.159  (客户购买的IP地址范围) -->已创建


2). 私有网络(企业管理员创建)

切换用户uu -->项目-->网络-->网络拓扑-->创建网络-->网络-->网络名称 lan -->下一步--->子网-->子网名称 lan_subnet, 网络地址 10.10.10.0/24,网关 10.10.10.254 -->下一步 -->分配地址池 10.10.10.1,10.10.10.250,DNS服务器 192.168.1.254(只要能解析主机名即可) --->已创建


3). 创建路由连接wan网络与lan网络
新建路由-->名称 rr, 外部网络 wan -->新建路由
鼠标放在路由器上 -->增加接口-->子网 lan:10.10.10.0/24(lan_subnet) , ip地址 10.10.10.254 -->提交

4).创建云主机
项目-->计算-->云主机数量-->创建云主机-->云主机名称  h1 -->源 选择源 镜像,创建新卷 否,  名称(centos6)  点击+ 添加-->云主机类型 abc 点击+添加-->网络 点击 lan 后面的+添加--->创建云主机

1006错误:
[root@nova01 ~]# vim +8430 /etc/nova/nova.conf --->vncserver_proxyclient_address后面定义主机名
在3台虚拟机的/etc/hosts 里添加解析的主机名 192.168.1.11 nova01 noca01.abcbb

5). 浮动IP地址(一般是花钱购买的)
计算-->访问和安全-->浮动IP-->分配IP给项目-->分配IP(3次,分3 个IP)-->云主机数量-->创建快照里(绑定浮动IP)-->选择IP地址-->关联

6). 配置openstack防火墙(以组为单位,服务器属于某个组)
项目-->计算-->访问与安全-->安全组-->创建安全组 名(hello) -->创建安全组
添加规则-->规则 all icmp ,添加-->云主机数量-->



安装计算节点(nova02)
更nova01一样操作  (注意临时挂载镜像文件)


在管理员里实现云主机热迁移
watch 
screen

 
修改openstack登录密码:

[root@openstack ~]# cat token    //随便编辑一个文件
export OS_token=581436e35e8d4c82bb47caaafb0f1836
export OS_URL=http://127.0.0.1:35357/v2.0
export OS_INDETITY_PRI_VERSION=2
[root@openstack ~]# vim +18 /etc/keystone/keystone.conf
获取token的连接码581436e35e8d4c82bb47caaafb0f1836
[root@openstack ~]# source token
[root@openstack ~]# source ~/keystonerc_admin
[root@openstack ~]# openstack user set --password  密码 admin   


1. 在redhat6和centos6里启动服务的2种方法
/etc/init.d/httpd start
或者
service httpd  start 
开机自启:chkconfig 服务名  on/off
chkconfig --list    //列出开机自启项

在redhat7里用systemctl命令




###############################################################################

date 04


什么容器:
容器技术已经成为应用程序封装和交付的核心技术,由3个内核技术组成:
Cgroups ---> 资源管理
NameSpace ---> 进程隔离
SElinux安全
 
Docker容器
Docker是完整的一套容器管理系统


NameSpace  (进程隔离) 六大命名空间  --->主机名,文件系统,用户,进程,信号,网络
chroot   unshare


虚拟机有自己独立的操作系统,容器不需要系统,它共享系统,需要切分,完后本质不变

Docker容器优点:  快速,高效,高性能,不需要操作系统,它共享系统,需要切分,完后本质不变
Docker容器缺点:  无法跨平台,容器隔离性没有虚拟化强,共用Linux内核安全性先天缺陷,selinux难以驾驭,监控容器和容器排错难.


安装前准备:
--需要64位操作系统
--至少RHEL7以上的版本,内核版本3.0以上也可以
--关闭防火墙(不是必须)

docker核心概念:     镜像、容器、仓库
1. 镜像:  就是启动容器的模板,所有镜像是只读的,
--在Docker中容器是基于镜像启动的
--镜像是启动容器的核心
--镜像采用分层设计
--使用快照的COW技术,确保底层数据不丢失

Docker官方提供公共镜像的仓库 --->https://hub.docker.com

1. 配置yum源:
[student@room9pc01 openstack]$ cat /etc/fstab 
/linux-soft/04/openstack/RHEL7-extras.iso /var/ftp/extras iso9660 defaults 0 0    //在真机上挂载镜像文件在共享目录里

2台docker机器都要做:
[root@docker1 ~]# cat /etc/yum.repos.d/local.repo
[local_repo]
name=CentOS-$releasever - Base
baseurl="ftp://192.168.1.254/centos-1804"
enabled=1
gpgcheck=1
[local_extras]
name=CentOS-$releasever - extras
baseurl="ftp://192.168.1.254/extras"
enabled=1
gpgcheck=0
[root@docker1 ~]# yum -y install docker

[root@docker1 ~]# docker images   //查看镜像
下载镜像模板------>https://hub.docker.com 下载好后还要导入

[root@docker1 ~]# docker search centos          //搜索镜像
[root@docker1 ~]# docker search busybox         //搜索镜像
[root@docker1 ~]# docker pull docker.io/busybox   //下载镜像

[root@docker1 ~]# docker push docker.io/busybox   //上传镜像

[root@docker1 ~]# docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED                      SIZE
docker.io/busybox(名称)   latest(标签)              020584afccce(ID号)   11 days ago(创建时间)         1.22 MB(大小)
名称 + 标签 =唯一
名称:标签(不能重复)

ls -i /etc/passwd    //查看内核识别文件的id 

docker save docker.io/busybox:latest -o busybox.tar     //打tar包
file busybox.tar    //查看文件
docker load -i busybox.tar  //导入镜像 


2. 容器
[student@room9pc01 docker]$ pwd
/linux-soft/04/docker
[student@room9pc01 docker]$ scp centos.tar nginx.tar redis.tar ubuntu.tar root@192.168.1.31:/root
[student@room9pc01 docker]$ scp centos.tar nginx.tar redis.tar ubuntu.tar root@192.168.1.32:/root
[root@docker2 ~]# ls
busybox.tar  centos.tar  f1  nginx.tar	redis.tar  ubuntu.tar
[root@docker2 ~]# for i in *;do docker load -i $i;done    //用for循环分别导入镜像 *指的是该目录下所有文件



启动容器: (run=create+start)  容器里很多命令都没有
[root@docker2 ~]# docker run -it docker.io/centos:latest /bin/bash   //标签默认是latest,可以省略,启动/bin/bash命令可以省略,就启用默认命令  但是nginx、redis除外(启动的是进程,服务)
进入容器后修改yum源为真机的yun源
[root@b7f8648200e9 /]# cat /etc/yum.repos.d/local.repo
[local_repo]
name=CentOS-$releasever - Base
baseurl="ftp://192.168.1.254/centos-1804"
enabled=1
gpgcheck=0
 
yum -y install which        //安装产生which命令
yum -y install  net-tools    //安装产生ifconfig命令的软件



Debian(ubuntu)系统与redhat系统
dpkg  ---->rpm
apt-get  ----->yum

软件包.deb  ---->.rpm

镜像命令列表:(管理镜像用名称+标签)
[root@docker1 ~]# docker pull docker.io/busybox   //下载镜像
[root@docker1 ~]# docker load -i busybox.tar      //使用tar包导入镜像 
[root@docker1 ~]# docker search docker.io/nginx   //搜索镜像
[root@docker1 ~]# docker push 镜像名                   //上传镜像
[root@docker1 ~]# docker save docker.io/busybox:latest -o busybox.tar     //用docker命令打tar包,-o指定tar包名
[root@docker1 ~]# docker images                   //查看镜像列表
[root@docker1 ~]# docker history docker.io/nginx:latest   //查看镜像制作历史,主要是看镜像盘有几层
[root@docker1 ~]# docker inspect docker.io/busybox:latest  //查看镜像底层信息 ,了解镜像环境变量、存储卷、标签等信息
[root@docker1 ~]# docker rmi docker.io/镜像名:标签 或id       //删除本地镜像
[root@docker1 ~]# docker tag 新镜像名:标签                         //修改镜像名称和标签(相当于硬链接指向id号,id号不变)
     eg: docker tag docker.io/nginx:latest docker.io/nginxs:latest  //本地没有改镜像名才能改名成功  

容器命令列表:(管理容器用容器id,注意不是镜像id)
docker run id             //运行容器  ----->docker run -it docker.io/centos:latest /bin/bash
docker ps  -a             //查看所有容器列表
docker stop id            //关闭容器
docker start id           //启动容器
docker restart id         //重启容器
docker attach|exec id     //进入容器  ---->attach连接上帝进程systemd,exec连接 用-it选项指定连接命令(/bin/bash)
docker inspect id         //查看容器底层信息
docker top id             //查看容器进程信息
docker rm id              //删除容器 --->docker rm $(docker stop $(docker ps -qa))

  Ctrl +p q    //放入后台



###################################################################################################


date  05



一. 自定义镜像:

1). [root@docker1 ~]# docker run -it docker.io/centos:latest    //以centos模板创建容器
2). 创建yum源
[root@bc2aa241504c /]# cd /etc/yum.repos.d/
[root@bc2aa241504c yum.repos.d]# ls
CentOS-Base.repo  CentOS-CR.repo  CentOS-Debuginfo.repo  CentOS-Media.repo  CentOS-Sources.repo  CentOS-Vault.repo  CentOS-fasttrack.repo
[root@bc2aa241504c yum.repos.d]# rm -rf *

[root@bc2aa241504c yum.repos.d]# vi local.repo
[local_repo]
name=CentOS-$releasever - Base
baseurl="ftp://192.168.1.254/centos-1804"
enabled=1
gpgcheck=0

3).安装相关命令

net-tools -----> ifconfig
vim 
psmisc------>pstree
iproute----->ip
base-com*-----> <tab>

[root@bc2aa241504c ~]# yum -y install net-tools vim psmisc iproute base-com* 
[root@bc2aa241504c ~]# exit      //退出容器
[root@docker1 ~]# docker ps -a    //查看所有容器id
CONTAINER ID        IMAGE                     COMMAND             CREATED             STATUS                     PORTS               NAMES
bc2aa241504c        docker.io/centos:latest   "/bin/bash"         10 minutes ago      Exited (0) 9 seconds ago                       focused_ride

4). 利用容器创建一个新的镜像

[root@docker1 ~]# docker commit bc2aa241504c myios:latest
sha256:738320ea4795f88f0e5b2e02d5ee0d0f6e22eae6054c75fc74eb987c99f60854
[root@docker1 ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
myios               latest              738320ea4795        34 seconds ago      317.7 MB


二. 利用脚本创建镜像

1). mkdir abc  //创建目录
2). touch abc/Dockerfile   //在目录下创建Dockerfile文件
3). cp /etc/yum.repos.d/local.repo /root/abc/local.repo
4). vim /root/abc/local.repo
5). cat local.repo
    [local_repo]
  name=CentOS-$releasever - Base
  baseurl="ftp://192.168.1.254/centos-1804"
  enabled=1
  gpgcheck=0
          
6). vim abc/Dockerfile     //编辑文件
FROM  docker.io/centos:latest
RUN   rm -rf /etc/yum.repos.d/*
ADD   local.repo /etc/yum.repos.d/local.repo
RUN   yum -y install net-tools vim psmisc base-completion iproute
7). cd ..    //返回root目录
8). docker build -t 镜像名:标签  Dockerfile所在目录
[root@docker1 ~]# docker images

[root@docker1 ~]# yum search ssh    //在yum源里搜索产生ssh命令的软件

  Dockerfile语法格式:
FROM --->基础镜像
MAINTAINER  -----> 镜像创建者信息
EXPOSE -----> 开发的端口
ENV -----> 设置变量
RUN  ---> 在容器内执行命令,可以有多个
ADD  --> 复制文件到镜像,当前目录的文件放进容器里
CMD  --->容器启动时执行的命令,仅可以有一条CMD
WORHDIR ----->定义容器默认工作目录 (代替cd命令)


ENV PS1= "[web@\h \W]# "      //在容器里定义一级提示符


docker exec -it 容器id  /bin/bash    //登录容器



       搭建私有镜像仓库:
1. 装包,注意yum源,,,仓库主机192.168.1.30
[student@room9pc01 openstack]$ mount -t iso9660 -o ro,loop RHEL7-extras.iso /var/ftp/extras/   //真机挂载
[root@web1 ~]# cat /etc/yum.repos.d/local.repo 
[local_repo]
name=CentOS-$releasever - Base
baseurl="ftp://192.168.1.254/centos-1804"
enabled=1
gpgcheck=1
[extras]
name=CentOS-$releasever - extras
baseurl="ftp://192.168.1.254/extras"
enabled=1
gpgcheck=0

yum -y install docker-distribution
2.配置
/etc/docker-distribution/registry/config.yml
/var/lib/registry
3.启动服务
systemctl start docker-distribution
systemctl enable docker-distribution
4.查看端口
[root@web1 ~]# ss -plunt |grep 5000
5.在docker1主机 修改配置
docker1]# vim /etc/sysconfig/docker  //改2行
13 ADD_REGISTRY='--add-registry docker1(仓库的IP):5000'
24 INSECURE_REGISTRY='--insecure-registry docker1(仓库的IP):5000'
docker1]# docker ps
docker1]# docker stop $(docker ps -q)
docker1]# systemctl restart docker
docker1]# rsync -av /etc/sysconfig/docker docker2:/etc/sysconfig/

验证:
从docker1 上,上传镜像到仓库主机
docker tag myos:latest 仓库的IP:5000/myos:latest
docker push 仓库的IP:5000/myos:latest

从docker2 上,直接使用仓库里面的镜像启动容器
docker run -it 192.168.1.30:5000/myos:latest

查看:
[root@docker2 ~]# curl http://192.168.1.30:5000/v2/_catalog


     存储卷
--docker容器不保持任何数据
--重要数据请使用外部卷存储(数据持久化)
--容器可以挂载真实机目录或共享存储为卷

主机卷的映射
--将真实机目录挂载到容器中提供持久化存储
    ----目录不存在就自动创建
    -----目录存在就直接覆盖
[root@docker1 ~]# docker run -v /bbb(主机目录):/usr/share/nginx/html(容器里的目录) -it docker.io/nginx bash

共享存储
一台共享存储服务器可以提供给所有Docker主机使用   --->NFS
1). nfs服务器共享目录(192.168.1.30)



创建docker1 
docker network create --subnet=10.10.10.0/24 docker1

与 docker0 连接的容器
docker run -it myos:latest

与docker1 连接的容器
docker run -it --network=docker1 myos:latest




客户端访问容器内的资源
--默认容器可以访问外网
--但外部网络的主机不可以访问容器内的资源
--容器的特征是可以把宿主机变成对应的服务
       ----我们可以使用 -p 参数把容器端口和宿主机端口绑定
       ------  -p 宿主机端口:容器端口
         eg: 把docker1 变成 httpd
              docker run -itd -p 80:80 docker.io/myos:httpd
                 把docker1 变成 nginx
              docker run -itd -p 80:80 docker.io/nginx:latest


#############################################################################################
                                        
                                 大型架构及配置技术
date 1
    ansible --->批量配置管理的工具
是基于Python研发,糅合很多老运维工具的优点,实现了批量操作系统配置,批量程序部署,批量运行命令等功能

ansible特性:
--基于Python语言实现
--模块支持json标准输出格式
--部署简单
--主从模式工作
--支持自定义模块
--支持playbook
--易于使用
--支持多层部署
--支持异构IT环境

ansible优点:
--只需要ssh和Python即可使用
--无客户端
--ansible 功能强大,模块丰富
-- 上手容易,门槛低
-- 基于Python开发,做二次开发更容易
--使用公司比较多,社区活跃

ansible所需软件:
--ansible
--python-httplib2
--python2-jmespath
--python-paramiko
--python-passlib
--sshpass

ansible 配置文件查找顺序:
1.ANSIBLE_CONFIG变量定义的配置文件
2.检查当前目录下的./ansible.cfg文件
3.检查当前用户家目录下~/ansible.cfg文件
4.最后检查/etc/ansible/ansible.cfg文件(默认配置文件路径)

部署ansible主机
在真机上拷贝软件到ansible主机:
[student@room9pc01 ansible]$ pwd
/linux-soft/04/ansible
[student@room9pc01 [root@ansible ~]# ]$ scp * root@192.168.1.40:/root

[root@ansible ~]# ls
ansible-2.4.2.0-2.el7.noarch.rpm         python-paramiko-2.1.1-4.el7.noarch.rpm
python2-jmespath-0.9.0-3.el7.noarch.rpm  python-passlib-1.6.5-2.el7.noarch.rpm
python-httplib2-0.9.2-1.el7.noarch.rpm   sshpass-1.06-2.el7.x86_64.rpm
[root@ansible ~]# yum -y install *.rpm

[root@ansible ~]# ansible --version    //查看版本信息

主机定义与分组:
[root@ansible ~]# vim /etc/ansible/ansible.cfg
14 inventory      = /etc/ansible/hosts   //主机集合配置文件,把#去掉
61 host_key_checking = False             //把#去掉,第一次ssh主机时不需要输入yes(ssh主机key验证配置参数)

[root@ansible ~]# vim /etc/ansible/hosts  //在主机集合配置文件里定义组名和组员
 44 [web]    //组名
 45 web1     //组员  ---->web[1:20] 代表1到20的主机(范围定义)
 46 web2     //组员
 47 
 48 [db]
 49 db1
 50 db2
 51 
 52 [other]
 53 cache



命令格式:  ansible 主机集合  -m 模块名称   -a 模块参数

主机集合  主机名或分组名,多个 使用","分隔
-m 模块名称,默认command模块
-a or  --args模块参数

其它参数




列出要执行主机:
[root@ansible ~]# ansible web --list-host    //列出web组的主机
  hosts (2):
    web1
    web2
[root@ansible ~]# ansible all --list-host    //列出所有主机
  hosts (5):
    web1
    web2
    cache
    db1
    db2


批量检测主机:(所检测的主机密码要一致,否则部署证书文件key)
[root@ansible ~]# ansible web -m ping -k  ---->显示绿色的文字就是成功的
SSH password: 


部署证书文件key
[root@ansible .ssh]# ssh-keygen -t rsa -b 2048 -N '' -f key  //-t 指定秘钥类型,-b 指定秘钥长度,-N 指定密码,-f 指定秘钥文件
[root@ansible .ssh]# ssh-copy-id -i key.pub web1       //给所有主机部署秘钥,传替公钥给其它所有主机
[root@ansible .ssh]# ssh -i key web1                   //连接主机,-i 指定秘钥文件


ansible  inventory 扩展参数(a.可以在单台主机后面配置参数  b.也可以在组名后面定义参数  c.也可以[all:vars]下面定义参数)

-ansible_ssh_port     ssh端口号:如果不是默认端口号,通过次变量设置
-ansible_ssh_user     默认的ssh用户名
-ansible_ssh_pass     ssh密码(这种方法不安全,强烈建议使用--ask-pass或ssh秘钥)
-ansible_ssh_private_key_file //ssh使用的私钥文件,适用于有多个秘钥,而你不想使用SSH代理的情况
-vars 变量定义,用于组名后面
[root@ansible .ssh]# vim /etc/ansible/hosts    
[all:vars]
ansible_ssh_private_key_file="/root/.ssh/key"   //使ansible主机知道私钥文件位置
[root@ansible .ssh]# ansible all -m ping

-children 子组定义,用于引用其它组名称
[app:children]
web    //组
db     //组

自定义主机:
1. 创建文件夹 myansible
2. 创建配置文件ansible.cfg
[defaults]
inventory = myhost
host_key_checking = False
3. 创建[配置主机文件hosts
[app1]
web1
db1

动态主机:

--无限可能
--Json



批量配置管理
absible-doc  模块手册相当于man帮助,很重要
ansible-doc -l   //列出所有模块
ansible-doc modulename  //查看帮助

1. ping 模块  测试网络连通性,ping模块没有参数
2. command模块不启用bash,不能解析系统变量,远程执行命令(默认模块)
            -a 跟上执行的命令,不能有一下字符 "<",  ">",  "|",  "&"
3. shell模块(万能模块,启用/bin/sh)可以执行任意命令----->解析2次(第一次在本机执行,第二次在执行机器解析,需要第二次解析的变量要转义(\))
               ansible是使用ssh多次连接执行,退出后之前的状态就全部失效,解决办法:使用chdir代替cd命令
               eg: ansible cache -m shell -a 'chdir=/tmp touch testfile'  
4. script模块  在本地修脚本,然后使用script模块批量执行
[root@ansible ~]# ansible web -m shell -a "echo ${HOSTNAME}" --->输出ansible本机名称
[root@ansible ~]# ansible web -m shell -a 'echo ${HOSTNAME}' --->输出被管理主机的名称
书写命令:nsible web -m shell -a "echo ${HOSTNAME}"
解析命令:nsible web -m shell -a echo ansible
传输命令:echo ansible
_______________________上面在ansible本机执行,下面在远程主机执行

解析命令:[/bin/sh]  echo ansible --->web1 web2
执行命令:echo ansible
输出结果:echo ansible
       echo ansible



书写命令:nsible web -m shell -a 'echo ${HOSTNAME}'
解析命令:nsible web -m shell -a echo ${HOSTNAME}
传输命令:echo ${HOSTNAME}
_______________________上面在ansible本机执行,下面在远程主机执行

解析命令:[/bin/sh]  echo ${HOSTNAME} --->web1 web2
执行命令:echo web1
       echo web2
输出结果: web1
        web2



添加用户:
给web1 db2 添加用户nb,并设置密码123
ansible web1,db2 -m command -a 'useradd nb'
ansible web1,db2 -m shell -a 'echo 123 |passwd --stdin nb'
或者:
ansible web1,db2 -m shell -a 'useradd nb;echo 123 |passwd --stdin nb'   //多条命令用";"隔开


添加用户:
给所有web主机添加用户wk
要求nb用户与wk用户不能出现在同一台主机上
设置wk用户密码456
[root@ansible ~]# vim ur.sh
#!/bin/bash
id nb
if [ $? != 0 ];then
  useradd wk
  echo 456 | passwd --stdin wk
fi
[root@ansible ~]# ansible web -m script -a 'ur.sh'

5. yum 模块
   使用yum包管理器来管理软件包
   name(必选项) : 要进行操作的软件包名字
   state :  动作(installed,removed)----->install = installed, remove = removed
  eg : ansible db -m yum -a 'name=mariadb-server state=installed'

6. service模块
  name :
  enabled:
  sleep:
  state :
 eg : ansible db -m service -a 'name=mariadb state=started enabled=yes'

7. copy 模块
 --复制文件到远程主机
--scr= :本地文件或目录,以"/"结尾,只复制目录里的内容,若不以"/"结尾,则复制包含目录在内的所有内容,类似于rsync
--dest= :必选项,远程主机的绝对路径,如果源文件是目录,那么该路径必须是目录
--backup : 覆盖前先备份原文件,备份文件包含时间信息.有2 个选项 yes|no
--force : 若目标主机包含改文件,但内容不同--->设置yes(默认)强制覆盖,设置no 目标主机目标位置不存在该文件时才复制
eg : ansible all -m copy -a 'src=/etc/resolv.conf dest=/etc/resolv.conf'  //拷贝文件
     ansible all -m copy -a 'src=/root/aaa dest=/root/'   //拷贝目录/root/aaa/本身及目录下所有内容到目标主机的/root/下
     ansible all -m copy -a 'src=/root/aaa/ dest=/root/'  //拷贝目录/root/aaa/下所有内容到目标主机的/root/下
     ansible db -m copy -a 'src=/etc/my.cnf dest=/etc/my.cnf'
     ansible db -m service -a 'name=mariadb state=restarted'   //给远程主机重启mariadb服务

8. lineinfile模块 ---->修改整行
 --类似sed的一种行编辑替换模块
--path 目标文件,要修改的文件
--regexp 正则表达式,要修改的行(整行都改)
--line  最终修改的结果

eg: 在/etc/my.cnf里将binlog-format=mixed改为binlog-format=row
[root@ansible ~]# ansible db -m lineinfile -a 'path="/etc/my.cnf" regexp="^binlog" line="binlog-format=row"'

9. replace  模块  --->替换匹配的内容
--类似sed的一种行编辑替换模块
--path 目标文件,要修改的文件
--regexp 正则表达式,只修改匹配的内容
--replace 替换后的结果

eg : 在/etc/my.cnf里将binlog-format=row改为binlog-format=mixed
[root@ansible ~]# ansible db -m replace -a 'path="/etc/my.cnf" regexp="row$" replace="mixed"'

10. setup 模块
主要用于获取目标主机信息,
--filter过滤所需信息

###################################################################################################33



date 2
ansible 七种武器(命令)
1. ansible 命令, 用于执行临时性的工作,必须掌握
2. ansible-doc 是ansible模块的文档说明,必须掌握
3. ansible-console 为用户提供的交互工具
4. ansible-galaxy 从github上下载管理roles的一款工具
5. ansible-playbook 是日常应用中使用频率最高的命令,必须掌握
6. ansible-vault 主要用于配置文件加密
7. ansible-pull ansible有2种工作模式pull/push,默认push模式工作,

· JSON 
一种基于文本独立于语言的轻量级数据交换格式,分隔符 ' 、()、[ ]、{}、:、, 六种符号
特性:
纯文本、具有"自我描述性"(人类可读)、具有层级结构(值中存在值)、通过JavaScript进行解析
· JSON语法规则:
--数据在名称/值对中
--数据由逗号分隔
--大括号保存对象
--中括号保存数组
格式:    "名称": "值"  --->注意冒号后面有个空格
数组;  eg:  { "诗人":
                   [ "李白","杜甫","白居易","李贺"]
              }
复合复杂: eg: 
   { "诗人":
       [ {"李白": "诗仙","年代": "唐"},
         {"杜甫": "诗圣","年代": "唐"},
         {"白居易": "诗魔","年代": "唐"},
         {"李贺": "诗鬼","年代": "唐"},
       ]
    }

· YAML
是一个可读性高,用来表达数据序列的格式
语法基础:
--结构通过空格来展示
--数组使用"- "来表示
--键值对使用": "来表示
--使用一个固定的缩进风格表示数据层级结构关系
--一般每个缩进级别由2个以上空格组成
--# 表示注释

注意:
不能用tab键,同一层级缩进必须对齐
格式: 冒号分隔,后面必须有一个空格
eg:  "诗仙": "李白"  或者
    "诗仙":
       "李白"
数组: 
   - "李白"
   - "杜甫"
   - "白居易"
   - "李贺"
哈希数组复合表达式:
    "诗人":
        - "李白"
        - "杜甫"
        - "白居易"
        - "李贺"
高级复合表达式:
       "诗人":
          - 
             "李白": "诗仙"
             "年代": "唐"
          -
             "杜甫": "诗圣"
             "年代": "唐"

· jinja2模板
jinja2是基于Python的模板引擎,包含变量和表达式2部分,两者在模板求值时会被替换为值,模板中还有标签,控制模板的逻辑

playbook的模板使用Python的jinja2模块来处理

jinja2模板基本语法:
---模板的表达式都是包含在分隔符"{{   }}"内的
---模板控制语句都是包含在分隔符"{%  %}"内的
---模板支持注释,都是包含在分隔符"{#   #}"内的,支持快注释
---调用变量 {{varname}}
---计算 {{2+3}}
---判断 {{1 in [1,2,3]}}

jinja2模板控制语句:
{% if name == '诗仙' %}
   李白
{% elif name == '诗圣' %}
   杜甫
{% elif name == '诗魔' %}
   白居易
{% else %}
   李贺
{% endif %}

jinja2过滤器
--变量可以通过过滤器修改,过滤器与变量用管道符号(|) 分割
--eg: 加密一个字符串: {{ 'astr' | password_hash('sha512')}}
可以查询在线文档找过滤器--->http://docs.jinkan.org/docs/jinja2/templates.html 


· playbook 
playbook是ansible用于配置,部署和管理托管主机剧本,通过playbook的详细描述,执行其中的一系列tasks,可以让远端主机达到预期状态

playbook语法格式:
---playbook由YAML语言编写,遵循YAML标准
---在同一行中,#之后的内容表示注释
---同一个列表中的元素应该保持相同的缩进
---playbook由一个或多个play组成
---play中hosts,variables,roles,tasks等对象的表示方法都是键值中间以:分隔表示
---YAML它的文件开始行以---开始,这是YAML的格式

playbook构成:
--hosts : 定义将要执行playbook的远程主机组,多个主机(组)以,隔离
--vars: 定义playbook运行时需要使用的变量
--tasks: 定义将要在远程主机上执行的任务列表
--handlers: 定义task执行完成后需要调用的任务    


[root@ansible ~]# cat ping.yml  //编写ping的playbook脚本
---
- name: test ping
  hosts: all
  remote_user: root
  tasks: 
    - ping: 
    - ping: 
    - ping: 

[root@ansible ~]# ansible-playbook ping.yml -f 5   //执行playbook脚本,-f并发进程数,默认是5

---
- name: test ping
  hosts: all
  remote_user: root
  tasks:
    - name: 1 ping  //给每个ping加注释
      ping:
    - name: 2 ping
      ping:
    - name: 3 ping
      ping:
 
练习1 : playbook练习
1. 所有web主机安装Apache
2. 修改配置文件的监听端口为8080
3. 设置配置文件主页 hello world
4. 启动服务
5. 设置开机自启
[root@ansible ~]# vim apache.yml
---
- name: install apache
  hosts: web
  tasks:
    - name: yum httpd
      yum:
        name: httpd
        state: latest
    - name: lineinfile 8080
      lineinfile:
        path: /etc/httpd/conf/httpd.conf
        regexp: '^Listen'
        line: 'Listen 8080'
    - name: copy html
      copy:
        src: a.html
        dest: /var/www/html/index.html
        owner: apache
        group: apache
        mode: 0644     ------>权限
    - name: start httpd
      service:
        name: httpd
        state: started
        enabled: yes
[root@ansible ~]# echo "hello world haha" > a.html
[root@ansible ~]# ansible-playbook apache.yml 
[root@ansible ~]# curl web1:8080   //访问查看网站

vim 编辑技巧--->在文件里把光标放在文件上 按g f 可直接查看改文件,按Ctrl+o 返回


playbook进阶

1. 引用变量批量添加用户:(防止一个值过多的写入不好修改)
[root@ansible ~]# cat user.yml 
---
- name: add user
  hosts: web
  vars:           //定义变量username
    username: lisi
  tasks:
    - name: add user "{{username}}"    //在playbook里引用变量用 双大括号
      user:
        name: "{{username}}"
        group: users
    - name: set password
      shell: echo 123 |passwd --stdin "{{username}}"
[root@ansible ~]# ansible-playbook user.yml

设置密码: 解决密码明文问题,在/etc/shadow里明文存入

变量过滤器password_hash --->password: "{{ 'abc' | password_hash('sha512') }}"  //密码abc用单引引起来
[root@ansible ~]# cat user.yml
---
- name: add user
  hosts: cache
  vars:
    username: lisi
  tasks:
    - name: add user "{{username}}"
      user:
        name: "{{username}}"
        group: users
        password: "{{ 'abc' | password_hash('sha512') }}"

变量参数
---传替参数
---  -e 参数
--- 参数格式必须是json 或  yaml
--- yaml格式 可以使用参数文件,eg args.yml   
格式:   ansible-playbook user.yml -e @args.yml

[root@ansible ~]# cat a.json 
{ "username": "plj","pwd": "123qqq...A" }   ----->json格式
[root@ansible ~]# ansible-playbook user.yml -e '{ "username": "plj","pwd": "123qqq...A" }'

[root@ansible ~]# cat args.yml   ----->yaml格式
---
username: nb
pwd: 123456
[root@ansible ~]# ansible-playbook user.yml -e @args.yml



2.error
ansible-playbook 对错误的处理
--默认情况判断$? , 如果值不为0就停止执行
--但某些情况我们需要忽略错误继续执行
--例如 创建缓存目录,然后重启 Apache


错误处理方法
--ignore_errors: 对错误的处理方式
--True 表示忽略错误继续执行
-- False 表示遇到错误就停止执行
--默认:False

3. tags
给指定的任务定义一个调用标识
格式:
   - name: NAME
   - module: arguments
   - tags:TAG_ID
playbook调用方式
  -t TAGS, --tags=TAGS

[root@ansible tmp]# cat webconf.yml 
---
- hosts: web      //定义主机组
  tasks:          //远程主机执行的任务列表
    - name: modify httpd.conf     //定义模块名
      copy:                       //copy模块
        src: httpd.conf           //源文件
        dest: /etc/httpd/conf/httpd.conf   //目标文件
        owner: root                 //所有者
        group: root                 //所属组
        mode: 0644                  //文件的权限
      tags: update_conf             //给指定任务copy一个调用标识
      notify: reload httpd          //最后被触发的操作指令
    - name: modify index.html
      copy:
        src: index.html
        dest: /var/www/html/index.html
        owner: apache
        group: apache
        mode: 0644
      tags: update_index
  handlers:
    - name: reload httpd
      service:
        name: httpd
        state: restarted



4. when 
有些时候需要在满足特定的条件后在触发某一项操作.或在特定的条件下终止某个行为,
这个时候需要进行条件判断,when正是解决这个问题的最佳选择,远程中的系统变量facts
作为when的条件,可以通过setup模块查看

5. register
保存前一个命令的返回状态,在后面进行调用

6. with_items
with_items是playbook标准循环,可以用于迭代一个列表或字典,通过{{ item }}获取每次迭代的值

eg:  为不同用户定义不同组,设置不同密码:
[root@ansible tmp]# cat user02.yml
---
- hosts: db1
  tasks:
    - name: create user {{ item.uname }}
      user:
        name: "{{ item.uname }}"
        group: "{{ item.group }}"
        password: "{{ item.passwd | password_hash('sha512') }}"
      with_items:
        - 
          uname: nb
          group: bin
          passwd: "123456"
        - 
          uname: wk
          group: man
          passwd: banana
        - 
          uname: dd
          group: daemon
          passwd: book
        - 
          uname: jj
          group: mysql
          passwd: 123qqq...A
        - 
          uname: xx
          group: root
          passwd: a


###################################################################################################

date  3

  elk   
-- Elasticsearch : 负责日志检索和储存
-- Logstash : 负责日志的收集和分析、处理
-- Kibana : 负责日志的可视化

   elk能做什么?
ＥＬＫ组件在海量日志文件系统的运维中，可用于解决：
－－分布式日志数据集中式查询和管理
－－系统监控，包含系统硬件和应用各个组件的监控
－－故障排查
－－安全信息和时间管理
－－报表功能


awk '{a[$1]++}END{for(i in a)print a[i],i}' | sort -nr   //在http日志里统计单机访问IP最高

ES安装:    脚本
#!/bin/bash
for i in 51 52 53 54 55
do
 scp /linux-soft/04/elk/*.rpm root@192.168.1.$i:/root/     //拷贝elasticsearch及依赖包
 ssh root@192.168.1.$i "
                        echo -e \"192.168.1.51 es1\n192.168.1.52 es2\n192.168.1.53 es3\n192.168.1.54 es4\n192.168.1.55 es5\" >> /etc/hosts;
                        yum -y install java-1.8.0-openjdk;
                        yum -y install *.rpm ;
                        sed -i '17c cluster.name: nsd1907' /etc/elasticsearch/elasticsearch.yml;
                        sed -i '23c node.name: es$i' /etc/elasticsearch/elasticsearch.yml;
                        sed -i '54c network.host: 0.0.0.0' /etc/elasticsearch/elasticsearch.yml;
                        sed -i '68c discovery.zen.ping.unicast.hosts: ["es1", "es2" , "es3"]' /etc/elasticsearch/elasticsearch.yml;
                        systemctl start elasticsearch;
                        systemctl enable elasticsearch;
                        netstat -plunt
                   "
done

[root@es1 ~]# grep -v "^#" /etc/elasticsearch/elasticsearch.yml   //查看配置文件有效行
cluster.name: nsd1907                    //集群名称
node.name: es1                           //主机节点名
network.host: 0.0.0.0                    //本机IP地址(不能是回环地址)
discovery.zen.ping.unicast.hosts: ["es1", "es2" , "es3"]            //声明集群节点成员(一般声明3个)

vimdiff a.txt b.txt    //比较两个文件的不同点


ES插件的使用

1. head 插件


2. kopf 插件


3. bigdesk 插件

安装插件 :
[student@room9pc01 ~]$ scp /linux-soft/04/elk/*.zip root@192.168.1.55:/root
[root@es5 ~]# /usr/share/elasticsearch/bin/plugin install file:///root/bigdesk-master.zip    //安装bigdesk插件
[root@es5 ~]# /usr/share/elasticsearch/bin/plugin install file:///root/elasticsearch-head-master.zip  //安装head插件
[root@es5 ~]# /usr/share/elasticsearch/bin/plugin install file:///root/elasticsearch-kopf-master.zip  //安装kopf插件


         
          扩展插件 RESTful API

HTTP协议简介
  http请求方法(三部分组成 : 请求行, 信息报头, 请求正文)
      --- 常用方法 GET , POST , HEAD
      --- 其它方法 OPTIONS , PUT , DELETE , TRACE , CONNECT
  ES常用
      --- PUT      //增
      --- DELETE   //删
      --- POST     //改
      --- GET      //查 (默认)


curl常用参数介绍:
　－ -A 修改请求agent
　－ -X 设置请求方法
　－ -i 显示返回头信息

　－　_cat  API查询集群状态,节点信息
　－  v 参数显示详细信息　
　－  help 显示帮助信息

       curl http://192.168.1.55:9200/_cat/master
       curl http://192.168.1.55:9200/_cat/master?v
       curl http://192.168.1.55:9200/_cat/shards
       curl http://192.168.1.55:9200/_cat/shards/tedu
       curl http://192.168.1.55:9200/_cat/shards/tedu?v
       curl http://192.168.1.55:9200/_cat/

用API的方式创建索引:
curl -XPUT "http://192.168.1.52:9200/tedu" -d '
{ "settings": {
     "index": {
        number_of_shards: 5,
        number_of_replicas: 2
        }
    }
}'


用API的方式插入数据 ----->PUT插入
          -d 后面是json格式
curl -XPUT "http://192.168.1.52:9200/tedu/teacher/1" -d '    //tedu(索引)插入数据并建表( 类型)teacher后面是第一条记录
{ "姓名": "犇犇",
  "爱好": "烫头",
  "阶段": "1"
}'

用API的方式更改数据 ------>POST修改
curl -XPOST "http://192.168.1.52:9200/tedu/teacher/1/_update" -d '
{"doc": {"爱好": "做头发"}}'        //doc指定要修改的字段


用API的方式查询数据 ------>默认就是GET
 [root@es5 ~]# curl -XGET "http://192.168.1.51:9200/tedu/teacher/1?pretty"
{
  "_index" : "tedu",
  "_type" : "teacher",
  "_id" : "1",
  "_version" : 2,
  "found" : true,
  "_source" : {
    "姓名" : "犇犇",
    "爱好" : "做头发",
    "阶段" : "1"
  }
}


用API的方式删除数据 ------>DELETE
[root@es5 ~]# curl -XDELETE "http://192.168.1.51:9200/tedu/teacher/1"   //删除一条记录


批量导入数据

用API的方式导入数据 ------>
[student@room9pc01 ~]$ scp /linux-soft/04/elk/*.gz root@192.168.1.51:/root   //将数据拷贝到任意一台集群主机
[root@es1 ~]# gzip -d accounts.json.gz   //解压压缩包
[root@es1 ~]# gzip -d logs.jsonl.gz 
[root@es1 ~]# gzip -d shakespeare.json.gz
导入数据:
curl -XPOST "http://192.168.1.51:9200/_bulk" --data-binary @shakespeare.json   //此json文件里有索引和 类型,所以不需要指定索引和 类型
curl -XPOST "http://192.168.1.51:9200/logstash/xx/_bulk" --data-binary @accounts.json   //此json文件里没有索引和 类型,需指定
curl -XPOST "http://192.168.1.51:9200/logstash/xx/_bulk" --data-binary @logs.jsonl   //此json文件里没有索引和 类型,需指定

在浏览器: 192.168.1.51:9200/_plugin/head/  插件里查看


##########################################################################################################

 date  04

kibana ----->192.168.1.56 主机名kibana

[student@room9pc01 ~]$ scp /linux-soft/04/elk/kibana-4.5.2-1.x86_64.rpm root@192.168.1.56:/root    //从真机上拷贝软件到56主机上
[root@kibana ~]# yum -y install kibana-4.5.2-1.x86_64.rpm    //注意配置yum源
[root@kibana ~]# vim /opt/kibana/config/kibana.yml         //kibana主配置文件在/opt下

[root@kibana ~]# grep -v "^#" /opt/kibana/config/kibana.yml | grep -v "^$"
2 server.port: 5601
5 server.host: "0.0.0.0"
15 elasticsearch.url: "http://es1:9200"
23 kibana.index: ".kibana"
26 kibana.defaultAppId: "discover"     //显示默认页面
53 elasticsearch.pingTimeout: 1500       //ping超时时间
57 elasticsearch.requestTimeout: 30000
64 elasticsearch.startupTimeout: 5000

[root@kibana ~]# systemctl start kibana
[root@kibana ~]# systemctl enable kibana



安装logstash
[student@room9pc01 ~]$ scp /linux-soft/04/elk/logstash-2.3.4-1.noarch.rpm  root@192.168.1.56:/root    //从真机上拷贝软件到56主机上
[root@logstash ~]# rsync -aXSH --delete 192.168.1.51:/etc/hosts /etc
[root@logstash ~]# vim /etc/hosts
192.168.1.51 es1
192.168.1.52 es2
192.168.1.53 es3
192.168.1.54 es4
192.168.1.55 es5
192.168.1.56 kibana
192.168.1.57 logstash

[root@logstash ~]# yum -y install java-1.8.0-openjdk logstash-2.3.4-1.noarch.rpm
[root@logstash ~]# touch /etc/logstash/logstash.conf     //创建空的配置文件
[root@logstash ~]# ls /opt/logstash/bin/logstash      //软件默认安装在/opt下




[root@logstash ~]# echo $((5|2))   //或(or)运算
7
[root@logstash ~]# echo $((5&2))   //与(and)运算
0
logstash第一个配置文件
[root@logstash ~]# cat /etc/logstash/logstash.conf   ===>四个模块
input {        ---->input模块,读取
  stdin {}     ------->里面可以加codec插件
}

filter {       ----->filter模块,过滤
}
output {       ----->output模块,写入
  stdout {}
}

验证:
[root@logstash ~]# cd /opt/logstash/bin/
[root@logstash bin]# /opt/logstash/bin/logstash -f /etc/logstash/logstash.conf  //启动并验证




logstash插件:

1. codec累插件
[root@logstash ~]# /opt/logstash/bin/logstash-plugin list    //列出所有插件

官方手册文档:----> https://www.elastic.co/guide/en/logstash/current/index.html


input {
  stdin {codec => "json"}      ----->用codec区域指定输入格式json
}

filter {
}
 output {
  stdout {codec => "rubydebug"}     ---->用codec插件rubydebug测试用的格式
}


修改完配置文件重新启动验证:
[root@logstash ~]# /opt/logstash/bin/logstash -f /etc/logstash/logstash.conf
{"a": "1", "b": "2", "c": "3"}      //输入json格式,下面显示
{
             "a" => "1",
             "b" => "2",
             "c" => "3",
      "@version" => "1",
    "@timestamp" => "2019-11-16T06:17:51.505Z",
          "host" => "logstash"
}


2. input file 插件
[root@logstash ~]# cat /etc/logstash/logstash.conf 
input {
  file {
    path => ["/tmp/a.log", "/var/tmp/b.log"]       //path插件指定监听的日志文件路径,当日志有变动时可以监控到
    start_position =>  "beginning"         // 配置第一次读取文件从什么地方开始
    sincedb_path => "/var/lib/logstash/since.db"    //记录读取文件的位置
    type => "apache.log"        //指定文件类型
  }
}

filter {
}
 output {
  stdout{ codec => "rubydebug" }
}

 3. filter grok 插件
filter {
      grok {
        match => { "message" => "%{IP:client} %{WORD:method} %{URIPATHPARAM:request} %{NUMBER:bytes} %{NUMBER:duration}" }
      }

match => { "message" => "(?<client_ip>([12]?\d?\d.){3}[12]?\d?\d) (?<oo>\S+) " }



金步国------>专门翻译官方文档 



###############################################################################################

              大数据

date  1 


 安装单机版的Hadoop :  ------> http://hadoop.apache.org (获取软件)
[root@hadoop ~]# yum -y install java-1.8.0-openjdk-devel.x86_64   //安装jps工具,
[root@hadoop ~]# jps
[student@room9pc01 ~]$ scp /linux-soft/04/hadoop/hadoop-2.7.7.tar.gz root@192.168.1.60:/root
[root@hadoop ~]# mv hadoop-2.7.7 /usr/local/hadoop
[root@hadoop ~]# cd /usr/local/hadoop/
[root@hadoop hadoop]# ./bin/hadoop version
[root@hadoop hadoop]# mkdir oo
[root@hadoop hadoop]# cp *.txt oo
[root@hadoop hadoop]#  ./bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar wordcount oo 123        //运行Hadoop jar(工具) 后面接jar包的路径   算法   源目录 目标显示目录




































































































































































